/**

License:
	Boost Software License - Version 1.0 - August 17th, 2003

    Permission is hereby granted, free of charge, to any person or organization
    obtaining a copy of the software and accompanying documentation covered by
    this license (the "Software") to use, reproduce, display, distribute,
    execute, and transmit the Software, and to prepare derivative works of the
    Software, and to permit third-parties to whom the Software is furnished to
    do so, all subject to the following:

    The copyright notices in the Software and this entire statement, including
    the above license grant, this restriction and the following disclaimer,
    must be included in all copies of the Software, in whole or in part, and
    all derivative works of the Software, unless such copies or derivative
    works are solely in the form of machine-executable object code generated by
    a source language processor.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
    SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
    FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
    ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
    DEALINGS IN THE SOFTWARE.

Authors:
	Alexandru Ermicioi
**/
module aermicioi.aedi.factory.generic_factory;


import aermicioi.aedi.exception;
import aermicioi.aedi.factory.factory;
import aermicioi.aedi.factory.reference;
import aermicioi.aedi.storage.decorator;
import aermicioi.aedi.storage.locator;
import aermicioi.aedi.storage.allocator_aware;
import aermicioi.aedi.storage.locator_aware;
import aermicioi.aedi.storage.wrapper;
import aermicioi.aedi.util.traits;
import aermicioi.aedi.util.formatting : separated, wrapped;
import aermicioi.aedi.util.typecons : Subscribable;


import std.conv : to;
import std.experimental.logger;
import std.meta;
import std.traits;

/**
A property configurer, has the purpose to modify component of type T according to some logic encapsulated in it.

**/
@safe interface PropertyConfigurer(T) : LocatorAware!() {

    public {

        /**
        Accepts a reference to an object that is to be configured by the configurer.

        Params:
        	object = An object of type T, that will be configured
        **/
        void configure(ref T object) @safe;
    }
}

/**
A default implementation that delegates to decorated configurator.
**/
mixin template PropertyConfigurerDecoratorMixin(T) {
    public {

        /**
        Accepts a reference to an object that is to be configured by the configurer.

        Params:
        	object = An object of type T, that will be configured
        **/
        void configure(ref T object) @safe {
            this.decorated.configure(object);
        }
    }
}

/**
An instance factory, instantiates component of type T.
**/
@safe interface InstanceFactory(T) : LocatorAware!(), AllocatorAware!() {

    public {

        /**
        Create a new instance of object of type T.

        Returns:
            T instantiated component
        **/
        T factory() @safe;
    }
}

/**
A default implementation that delegates construction to decorated implementation
**/
mixin template InstanceFactoryDecoratorMixin(T) {
    public {

        /**
        Create a new instance of object of type T.

        Returns:
            T instantiated component
        **/
        T factory() @safe {
            return this.decorated.factory();
        }
    }
}

/**
An interface for components that can destruct components of type T and deallocate them using provided allocator.
**/
@safe interface InstanceDestructor(T) : LocatorAware!(), AllocatorAware!() {

    public {

        /**
        Destruct a component of type T and deallocate it using stored allocator.

        Params:
            destructable = element to be destructed and deallocated using stored allocator
        **/
        void destruct(ref T destructable) @safe;
    }
}

/**
A default implementation that delegates the destrcution to decorated component.
**/
mixin template InstanceDestructorDecoratorMixin(T) {
    public {

        /**
        Destruct a component of type T and deallocate it using stored allocator.

        Params:
            destructable = element to be destructed and deallocated using stored allocator
        **/
        void destruct(ref T destructable) @safe {
            return this.decorated.destruct(destructable);
        }
    }
}

/**
Interface for objects that are aware of an instance factory
and can use it to instantiate a component.
**/
@safe interface InstanceFactoryAware(T) {
    public {

        @property {
        	/**
            Sets the constructor of new object.

            Params:
            	factory = a factory of objects of type T.

        	Returns:
    			The InstanceFactoryAware
            **/
            InstanceFactoryAware!T setInstanceFactory(InstanceFactory!T factory) @safe;
        }
    }
}

/**
A default implementation that delegates the instance factory setting to decorated component.
**/
mixin template InstanceFactoryAwareDecoratorMixin(T) {
    public {

        /**
        Sets the constructor of new object.

        Params:
            factory = a factory of objects of type T.

        Returns:
            The InstanceFactoryAware
        **/
        InstanceFactoryAware!T setInstanceFactory(InstanceFactory!T factory) @safe
        in (factory !is null, "Expected a instance factory to be passed not null.") {
            return this.decorated.setInstanceFactory(factory);
        }
    }
}

/**
A default implementation for storing/accessing instance factory.
**/
mixin template InstanceFactoryAwareMixin(T) {
    private {
        InstanceFactory!T instanceFactory;
    }

    public {

        /**
        Sets the constructor of new object.

        Params:
            factory = a factory of objects of type T.

        Returns:
            The InstanceFactoryAware
        **/
        typeof(this) setInstanceFactory(InstanceFactory!T factory) @safe
            in (factory !is null, "Expected a instance factory, got a null reference.") {
            instanceFactory = factory;
            return this;
        }
    }
}

/**
Interface for objects that are aware of an instance factory
and can use it to instantiate a component.
**/
@safe interface InstanceDestructorAware(T) {
    public @property {

        /**
        Sets the destructor of component.

        Params:
            destructor = destructor for components of type T.

        Returns:
            The InstanceDestructorAware!T
        **/
        InstanceDestructorAware!T setInstanceDestructor(InstanceDestructor!T destructor) @safe;
    }
}

/**
A default implementation that delegates the instance destructor setting to decorated component.
**/
mixin template InstanceDestructorAwareDecoratorMixin(T) {
    public {

        /**
        Sets the destructor of component.

        Params:
            destructor = destructor for components of type T.

        Returns:
            The InstanceDestructorAware!T
        **/
        InstanceDestructorAware!T setInstanceDestructor(InstanceDestructor!T destructor) @safe
        in (destructor !is null, "Expected an instance destructor to passed not null.") {
            return this.decorated.setInstanceDestructor(destructor);
        }
    }
}

/**
A default implementation for storing/accessing instance destructor.
**/
mixin template InstanceDestructorAwareMixin(T) {
    private {
        InstanceDestructor!T instanceDestructor;
    }

    public {

        /**
        Sets the destructor of component.

        Params:
            destructor = destructor for components of type T.

        Returns:
            The InstanceDestructorAware!T
        **/
        typeof(this) setInstanceDestructor(InstanceDestructor!T destructor) @safe
        in (destructor !is null, "Expected a instance destructor, got a null reference.") {
            instanceDestructor = destructor;

            return this;
        }
    }
}

/**
Interface for objects that are aware of a set of property configurers
and can use them to configure some component.
**/
@safe interface PropertyConfigurersAware(T) {
    public {
        /**
        Adds an configurer to the PropertyConfigurersAware.

        Params:
        	configurer = a configurer that will be invoked after factory of an object.

    	Returns:
    		The PropertyConfigurersAware instance
        **/
        PropertyConfigurersAware!T addPropertyConfigurer(PropertyConfigurer!T configurer) @safe;
    }
}

/**
A default implementation that delegates the instance destructor setting to decorated component.
**/
mixin template PropertyConfigurersAwareDecoratorMixin(T) {
    public {

        /**
        Adds an configurer to the PropertyConfigurersAware.

        Params:
        	configurer = a configurer that will be invoked after factory of an object.

    	Returns:
    		The PropertyConfigurersAware instance
        **/
        PropertyConfigurersAware!T addPropertyConfigurer(PropertyConfigurer!T configurer) @safe {
            return this.decorated.addPropertyConfigurer(configurer);
        }
    }
}

/**
A default implementation for storing property configurers.
**/
mixin template PropertyConfigurersAwareMixin(T) {
    private {
        PropertyConfigurer!T[] propertyConfigurers;
    }
    public {

        /**
        Adds an configurer to the PropertyConfigurersAware.

        Params:
        	configurer = a configurer that will be invoked after factory of an object.

    	Returns:
    		The PropertyConfigurersAware instance
        **/
        typeof(this) addPropertyConfigurer(PropertyConfigurer!T configurer) @safe
        in (configurer !is null, "Expected a instance configurer, got a null reference.") {
            this.propertyConfigurers ~= configurer;

            return this;
        }
    }
}

/**
A generic factory, is a factory that instantiates component of type T using InstanceFactory and a list of PropertyConfigurers.

A generic factory, is a factory that instantiates component of type T using InstanceFactory and a list of PropertyConfigurers.
It can optionally provide a Locator!() object to InstanceFactory and PropertyConfigurer to be used as a source of component.
**/
@safe interface GenericFactory(T) : Factory!T, InstanceFactoryAware!T, PropertyConfigurersAware!T, InstanceDestructorAware!T {

    public {

        @property {

            alias locator = Factory!T.locator;

            /**
            Get the GenericFactory locator.

            Returns:
            	Locator!() the locator that should be used by underlying constructor or property configurer.
            **/
            inout(Locator!()) locator() @safe inout;
        }
    }
}

/**
A concrete implementation of GenericFactory interface.
**/
@safe class GenericFactoryImpl(T) : GenericFactory!T, LocatorAware!() {
    import aermicioi.aedi.storage.allocator_aware : AllocatorAwareMixin;

    private {
        /**
        Somehow scoped methods got leaked into overload set of generic factory messing up additional logic.
        **/
        struct Payload {
            mixin LocatorAwareMixin!() DefaultLocatorImplementation;
            mixin AllocatorAwareMixin!RCIAllocator DefaultAllocatorImplementation;
            mixin InstanceFactoryAwareMixin!T DefaultInstanceFactoryAwareImplementation;
            mixin InstanceDestructorAwareMixin!T DefaultInstanceDestructorAwareImplementation;
            mixin PropertyConfigurersAwareMixin!T DefaultPropertyConfigurersAwareImplementation;
        }

        Payload payload;
        alias payload this;
    }


    public {

        /**
            Constructor for GenericFactoryImpl

            Params:
                locator = the locator used by constructor to fetch dependencies of the created object
        **/
        this(Locator!() locator) {
            import std.experimental.allocator : theAllocator;

            DefaultLocatorImplementation.locator = locator;
            DefaultAllocatorImplementation.allocator = theAllocator;

            static if (hasDefaultCtor!T) {
                this.setInstanceFactory(new DefaultInstanceFactory!T);
            } else {
                this.setInstanceFactory(new DefaultFailingInstanceFactory!T);
            }

            this.setInstanceDestructor(new DefaultInstanceDestructor!T);
        }

        /**
        Create a new instance of object of type T using provided instance factory and property configurers.

        Returns:
            T instantiated component
        **/
        T factory() @safe {
            debug(trace) trace("Instantiating component of type ", typeid(T));
            T instance = this.instanceFactory.factory();

            foreach (configurer; this.propertyConfigurers) {

                debug(trace) trace("Running ", configurer, " configurer over instantiated component.");
                configurer.configure(instance);
            }

            return instance;
        }

        /**
        Destructs a component of type T.

        Params:
            component = component that is to ve destroyed.
        **/
        void destruct(ref T component) @safe {
            debug(trace) trace("Destroying component of type ", typeid(T));
            this.instanceDestructor.destruct(component);
        }

        @property {

            /**
    		Get the type info of object that is created.

    		Returns:
    			TypeInfo object of created object.
    		**/
    		TypeInfo type() @safe nothrow const {
    		    return typeid(T);
    		}
        }

        /**
        Set destructor

        Params:
            destructor = the destructor used to destruct components created by this factory.

        Returns:
            typeof(this)
        **/
        typeof(this) setInstanceDestructor(InstanceDestructor!T destructor) @safe
        in (destructor !is null, "Expected a destructor for component " ~ typeid(T).toString ~ " to be passed not null.") {
            DefaultInstanceDestructorAwareImplementation.setInstanceDestructor(destructor);

            this.instanceDestructor.allocator = DefaultAllocatorImplementation.allocator;
            this.instanceDestructor.locator = DefaultLocatorImplementation.locator;

            return this;
        }

        /**
        Sets the constructor of new object.

        Params:
            factory = a factory of objects of type T.

        Returns:
            The InstanceFactoryAware
        **/
        GenericFactory!T setInstanceFactory(InstanceFactory!T factory) @safe
        in (factory !is null, "Expected for instance factory to be passed for component " ~ typeid(T).toString ~ " not null.") {
            DefaultInstanceFactoryAwareImplementation.setInstanceFactory(factory);

            this.instanceFactory.allocator = DefaultAllocatorImplementation.allocator;
            this.instanceFactory.locator = DefaultLocatorImplementation.locator;

            return this;
        }

        /**
            Set locator

            Params:
                locator = the locator used to fetch created's object dependencies
            Returns:
                typeof(this)
        **/
        GenericFactory!T locator(Locator!() locator) @safe nothrow {
            DefaultLocatorImplementation.locator(locator);

            this.instanceFactory.locator = DefaultLocatorImplementation.locator;
            this.instanceDestructor.locator = DefaultLocatorImplementation.locator;

            foreach (configurer; this.propertyConfigurers) {
                configurer.locator = locator;
            }

            return this;
        }

        /**
        Get locator

        Returns:
            Locator!()
        **/
        inout(Locator!()) locator() @safe nothrow inout {
            return DefaultLocatorImplementation.locator;
        }

        /**
        Set allocator

        Params:
            allocator = the allocator used to allocate place for component.

        Returns:
            typeof(this)
        **/
        typeof(this) allocator(RCIAllocator allocator) @safe nothrow {
            DefaultAllocatorImplementation.allocator(allocator);

            this.instanceFactory.allocator = DefaultAllocatorImplementation.allocator;
            this.instanceDestructor.allocator = DefaultAllocatorImplementation.allocator;

            return this;
        }

        /**
        Get allocator

        Returns:
            RCIAllocator
        **/
        inout(RCIAllocator) allocator() @safe nothrow inout {
            return DefaultAllocatorImplementation.allocator;
        }

        /**
        Adds an configurer to the PropertyConfigurersAware.

        Params:
        	configurer = a configurer that will be invoked after factory of an object.

    	Returns:
    		The PropertyConfigurersAware instance
        **/
        GenericFactory!T addPropertyConfigurer(PropertyConfigurer!T configurer) @safe {
            DefaultPropertyConfigurersAwareImplementation.addPropertyConfigurer(configurer);
            configurer.locator = DefaultLocatorImplementation.locator;

            return this;
        }
    }

}

/**
ditto
**/
GenericFactory!T genericFactory(T)(Locator!() locator) {
    return new GenericFactoryImpl!T(locator);
}

/**
ParameterHolder Stores a set of Args for futher usage in it's subclasses.

Params:
    Args = a type tuple of args that ParameterHolder can hold.
**/
mixin template ParameterHolder(Args...) {

    protected {
        Args args;
    }
}

/**
Calls component's method with a set of arguments.

Encapsulates a call to component's method, with a set of arguments.
The algorithm that calls component's method, will automatically replace
RuntimeReferences from args list with components extracted from container, casted to
type that is extracted from method's signature.

Params:
    T = the component type
    property = method that will be called
    Args = type tuple of args that method can be called with.
**/
@safe class MethodConfigurer(T, string property, Args...) : PropertyConfigurer!T
	if (
	    isMethodCompatible!(T, property, Args)
    ) {

    mixin ParameterHolder!Args;
    mixin LocatorAwareMixin!(typeof(this));

    public {

        /**
            Constructor for MethodConfigurer!(T, property, Args)

            Params:
                args = list of arguments passed to T's method
        **/
        this(ref Args args) @safe {
            this.args = args;
        }

        /**
        See PropertyConfigurer interface

        Throws:
            InvalidCastException when extracted component by reference, is not of type expected by argument
            of component's method
        **/
        void configure(ref T obj) @trusted {

            try {
                static foreach (overload; __traits(getOverloads, T, property)) {
                    static if (!is(typeof(called)) && isArgumentListCompatible!(overload, Args)) {
                        enum called = true;
                        alias ArgTuple = Parameters!overload;
                        debug(trace) trace("Calling method ", property, " over ", typeid(T), " with arguments of ",   ", ".separated(this.args).wrapped);
                        mixin(q{__traits(getMember, obj, property)(} ~ compileArgumentsTuple!ArgTuple(q{ArgTuple}, q{this.args}, q{this.locator}) ~ q{);});
                    }
                }
            } catch (Exception e) {
                throw new PropertyConfigurerException("Error occurred while invoking method ${type}.${property} of ${identity} component ", null, property, typeid(T), e);
            }
        }
    }
}

/**
ditto
**/
auto methodConfigurer(string property, T, Args...)(auto ref Args args)
    if (!isField!(T, property)) {
    mixin assertObjectMethodCompatible!(T, property, Args);

    auto propertySetter = new MethodConfigurer!(T, property, Args)(args);

    return propertySetter;
}

/**
Sets component's field to a value.

Encapsulates logic that sets component's field to a certain value.
If argument that is contained by configurer is a RuntimeReference, it will be automatically
replaced with value extracted from locator, and set to component's field.
**/
@safe class FieldConfigurer(T, string property, Arg) : PropertyConfigurer!T
	if (
	    isFieldCompatible!(T, property, Arg)
    ) {

    mixin ParameterHolder!Arg;
    mixin LocatorAwareMixin!(typeof(this));

    public {
        /**
            Constructor for MethodConfigurer!(T, property, Args)

            Params:
                arg = list of arguments passed to T's method
        **/
        this(ref Arg arg) @safe {
            this.args[0] = arg;
        }

        /**
        See PropertyConfigurer interface

        Throws:
            InvalidCastException when extracted component by reference, is not of type expected by argument
            of component's field
        **/
        void configure(ref T obj) @trusted {

            try {

                debug(trace) trace("Assigning to field ", property, " of ", typeid(T), " value of ", this.args[0]);
                __traits(getMember, obj, property) = args[0].resolve!(
                    typeof(__traits(getMember, obj, property))
                )(
                    this.locator
                );
            } catch (Exception e) {

                throw new PropertyConfigurerException("Error occurred while assigning a value to ${type}.${property} of ${identity} component", null, property, typeid(T), e);
            }
        }
    }
}

/**
ditto
**/
auto fieldConfigurer(string property, T, Arg)(auto ref Arg arg)
    if (isField!(T, property)) {
    mixin assertFieldCompatible!(T, property, Arg);

    auto propertySetter = new FieldConfigurer!(T, property, Arg)(arg);

    return propertySetter;
}

/**
Instantiates a component using it's constructor with no arguments.
**/
@safe class DefaultInstanceFactory(T) : InstanceFactory!T
    if (
        hasDefaultCtor!T
    ) {

    mixin LocatorAwareMixin!(typeof(this));
    mixin AllocatorAwareMixin!(typeof(this));

    public {
        /**
        Create a new instance of object of type T.

        Returns:
            T instantiated component
        **/
        T factory() @trusted {

            try {
                debug(trace) trace("Instantiating ", typeid(T), " using default constructor or value.");

                static if (is(T == class) && !isAbstractClass!T) {
                    return this.allocator.make!T();
                } else {
                    return T.init;
                }
            } catch (Exception e) {
                throw new InstanceFactoryException("Error occurred while default constructor was run for ${identity} of ${type} type", null, typeid(T), e);
            }
        }
    }
}

/**
An instance constructor aimed to throw exception.

An instance constructor aimed to throw exception,
when a component has elaborate constructor, yet
no constructor was configured for generic factory to
use those elaborate constructors.
**/
@safe class DefaultFailingInstanceFactory(T) : InstanceFactory!T {

    mixin LocatorAwareMixin!(typeof(this));
    mixin AllocatorAwareMixin!(typeof(this));

    public {
        /**
        Create a new instance of object of type T.

        Returns:
            T instantiated component
        **/
        T factory() @safe {

            throw new InstanceFactoryException("Component ${identity} of ${type} has elaborate constructor, yet it wasn't configured to run it.", null, typeid(T));
        }
    }
}

/**
Instantiates component using it's constructor with args.

Encapsulates construction of component using a constructor, with args.
Arguments from argument list that are RuntimeReferences, are automatically
replaced with component extracted from locator.

Params:
    T = component type
    Args = type tuple of args that are passed to T's constructor
**/
@safe class ConstructorBasedFactory(T, Args...) : InstanceFactory!T
	if (
	    isObjectConstructorCompatible!(T, Args)
	) {

    mixin ParameterHolder!Args;
    mixin AllocatorAwareMixin!(typeof(this));
    mixin LocatorAwareMixin!(typeof(this));

    public {
        /**
            Constructor for ConstructorBasedFactory!(T, Args)

            Params:
                args = arguments used for constructor
        **/
        this(ref Args args) @safe {
            this.args = args;
        }

        /**
        See InstanceFactory interface

        Throws:
            InvalidCastException when extracted component by reference, is not of type expected by argument
            of component's constructor
        **/
        T factory() @trusted {

            try {

                static foreach (overload; __traits(getOverloads, T, "__ctor")) {
                    static if (!is(typeof(called)) && isArgumentListCompatible!(overload, Args)) {
                        enum called = true;
                        alias ConstructorArgs = Parameters!overload;
                        debug(trace) trace("Instantiating ", typeid(T), " using constructor with arguments of ",   ", ".separated(this.args).wrapped);
                        static if (is(T : Object)) {
                            mixin(q{return this.allocator.make!T(} ~ compileArgumentsTuple!ConstructorArgs(q{ConstructorArgs}, q{this.args}, q{this.locator}) ~ q{);});
                        } else {
                            mixin(q{return T(} ~ compileArgumentsTuple!ConstructorArgs(q{ConstructorArgs}, q{this.args}, q{this.locator}) ~ q{);});
                        }
                    }
                }
            } catch (Exception e) {

                throw new InstanceFactoryException("Error occurred while elaborate constructor was run on ${identity} of ${type} type", null, typeid(T), e);
            }
        }
    }
}

/**
ditto
**/
auto constructorBasedFactory(T, Args...)(auto ref Args args) {
    mixin assertObjectConstructorCompatible!(T, Args);
    auto constructor = new ConstructorBasedFactory!(T, Args)(args);

    return constructor;
}

/**
Instantiates a component using a function/delegate with args

Encapsulates construction of component using a function, with args.
Arguments from argument list that are RuntimeReferences, are automatically
replaced with component extracted from locator.

Params:
    Dg = type of function or delegate
    Args = arguments mixed with references used to resolve function arguments
**/
template FunctionInstanceFactory(Dg, Args...)
    if (isSomeFunction!Dg) {

    alias Z = ReturnType!Dg;
    alias Params = Parameters!Dg;

    @safe class FunctionInstanceFactory : InstanceFactory!Z {
        mixin AllocatorAwareMixin!(typeof(this));
        mixin LocatorAwareMixin!(typeof(this));
        mixin ParameterHolder!Args;

        private {
            Dg dg;
        }

        this(Dg dg, Args args)
            in (dg !is null, "Cannot have a null function factory, required " ~ typeid(Dg).toString ~ " function.") {
            this.dg = dg;
            this.args = args;
        }

        /**
        Create a new instance of object of type T.

        Returns:
            T instantiated component
        **/
        Z factory() @trusted {
            try {
                debug(trace) trace("Instantiating ", typeid(Z), " using function/delegate ", typeid(Dg), " with arguments of ",   ", ".separated(this.args).wrapped);
                mixin(
                    q{return dg(} ~
                    compileArgumentsTuple!Params(q{Params}, q{this.args}, q{this.locator}) ~
                    q{);}
                );
            } catch (Exception e) {
                import std.conv : text;
                throw new InstanceFactoryException(
                    text(
                        "Error occurred during construction of ${type} using function/delegate ",
                        typeid(Dg).toString
                    ),
                    null,
                    typeid(Z),
                    e
                );
            }
        }
    }
}

/**
ditto
**/
auto functionInstanceFactory(Dg, Args...)(Dg dg, Args args) {
    return new FunctionInstanceFactory!(Dg, Args)(dg, args);
}

/**
Instantiates a component using a method from other component (factory method pattern).

Encapsulates construction of component using factory method.
Arguments that are RuntimeReferences, will be replaced with components extracted
from locator, and passed to factory's method.
In case when method is not static member, the algorithm will use
an instantiaton of factory passed to it, or extracted from locator
if a RuntimeReference is passed.

Params:
    T = factory that is used to instantiate component using it's method
    method = the name of method used to instantiate component
    W = the factory T, or a RuntimeReference to the factory.
    Args = type tuple of arguments passed to factory.
**/

template FactoryMethodBasedFactory(T, string method, W, Args...) {
    alias FactoryMethodBasedFactory = FactoryMethodInstanceFactory!(method, T, W, Args);
}

/**
ditto
**/
template FactoryMethodInstanceFactory(string method, T, W, Args...)
    if (
        isMethodCompatible!(T, method, Args) &&
        isAggregateType!(ReturnType!(getCompatibleOverload!(T, method, Args))) &&
        (is(W : RuntimeReference) || is(W : T))
    ) {

    alias Compatible = getCompatibleOverload!(T, method, Args);
    alias Z = ReturnType!Compatible;
    alias Params = Parameters!Compatible;

    @safe class FactoryMethodInstanceFactory : InstanceFactory!Z {

        mixin AllocatorAwareMixin!(typeof(this));
        mixin LocatorAwareMixin!(typeof(this));
        mixin ParameterHolder!Args;
        W componentFactory;

        this(W componentFactory, Args args)
            in ((is(typeof(componentFactory is null) : bool) && (componentFactory !is W.init))
                || !is(typeof(componentFactory is null) : bool),
                "Cannot instantiate a component using a factory method when factory itself is not provided. Expected " ~ typeid(T).toString) {

            this.componentFactory = componentFactory;
            this.args = args;
        }

        /**
        Create a new instance of object of type T.

        Returns:
            T instantiated component
        **/
        Z factory() @trusted {
            try {
                debug(trace) trace("Instantiating ", typeid(Z), " using factory method ", method, " of ", typeid(T), " with arguments of ",   ", ".separated(this.args).wrapped);
                mixin(
                    q{return __traits(getMember, this.componentFactory.resolve!T(this.locator), method)(} ~
                    compileArgumentsTuple!Params(q{Params}, q{this.args}, q{this.locator}) ~
                    q{);}
                    );
            } catch (Exception e) {
                import std.conv : text;
                throw new InstanceFactoryException(
                    text(
                        "Error occurred during construction of ${type} using factory method of ",
                        name!T,
                        ".",
                        method
                    ),
                    null,
                    typeid(Z),
                    e
                );
            }
        }
    }
}

/**
ditto
**/
auto factoryMethodBasedFactory
        (T, string method, Args...)
        (Args args)
{
    static if (
            (Args.length > 0) &&
            (
                is(Args[0] : RuntimeReference) ||
                is(Args[0] : T)
            ) &&
            isNonStaticMethodCompatible!(T, method, Args[1 .. $])
        ) {

        return new FactoryMethodInstanceFactory!(method, T, Args)(args);
    } else static if (
            isStaticMethodCompatible!(T, method, Args)
        ) {

        alias overload = getCompatibleOverload!(T, method, Args);
        return functionInstanceFactory(&overload, args);
    } else {

        return null;
    }
}


/**
Instantiates component of type T using a delegate or function.

Encapsulates component's construction logic using a delegate.
The algorithm uses a delegate to create required component,
with a set of Args that are passed to delegate, and a locator
for dependency fetching.

Params:
    T = the constructed component
    Args = type tuple of arguments passed to delegate for component's construction.
**/
@safe class CallbackFactory(T, Dg, Args...) : InstanceFactory!T
    if ((is(Dg == T delegate (RCIAllocator, Locator!(), Args)) || is(Dg == T function (RCIAllocator, Locator!(), Args)))) {

    mixin AllocatorAwareMixin!(typeof(this));
    mixin LocatorAwareMixin!(typeof(this));
    mixin ParameterHolder!Args;

    private {
        Dg dg;
    }

    public {
        /**
            Constructor for CallbackFactory!(T, Dg, Args)

            Params:
                dg = delegate used to create object
                args = arguments passed to delegate
        **/
        this(Dg dg, ref Args args) @safe {
            this.dg = dg;
            this.args = args;
        }

        /**
        See InstanceFactory interface
        **/
        T factory() @trusted {
            try {
                debug(trace) trace("Instantiating ", typeid(T), " using function/delegate ", typeid(Dg), " with arguments of ",   ", ".separated(this.args).wrapped);
                return this.dg(this.allocator, this.locator, args);
            } catch (Exception e) {

                throw new InstanceFactoryException(
                    "Error occurred during construction of ${identity} of ${type} type using callback factory", null, typeid(T),
                    e
                );
            }
        }
    }
}

/**
ditto
**/
auto callbackFactory(T, Args...)(T delegate(RCIAllocator, Locator!(), Args) dg, auto ref Args args) {
    auto constr = new CallbackFactory!(T, T delegate(RCIAllocator, Locator!(), Args), Args)(dg, args);
    return constr;
}

/**
ditto
**/
auto callbackFactory(T, Args...)(T function(RCIAllocator, Locator!(), Args) dg, auto ref Args args) {
    auto constr = new CallbackFactory!(T, T function(RCIAllocator, Locator!(), Args), Args)(dg, args);
    return constr;
}

/**
Configures/modifies component of type T with help of a delegate or function.

Encapsulates component configuration logic using a delegate.
The algorithm calls delegate, with a locator, a set of Args,
and configured component, in order to modify the component.

Note:
    If component is not a reference type it is recommended to pass it by ref
    in order to avoid receiving of a copy and not original one in delegate.
    It is expected that the callback will use somehow method on which it was annotated with.
Params:
    T = the component
    Args = type tuple of arguments used by delegate for customization.
**/
@safe class CallbackConfigurer(T, X, Dg, Args...) : PropertyConfigurer!T
    if (
        is(T : X) && (
            is(Dg : void delegate (Locator!(), X, Args)) ||
            is(Dg : void function (Locator!(), X, Args)) ||
            is(Dg : void delegate (Locator!(), ref X, Args)) ||
            is(Dg : void function (Locator!(), ref X, Args))
        )
    ) {

    mixin ParameterHolder!Args;
    mixin LocatorAwareMixin!(typeof(this));

    private {
        Dg dg;
    }

    public {
        /**
            Constructor for CallbackConfigurer!(T, Dg, Args)

            Params:
                dg = delegate used to configure the created object
                args = arguments passed to delegate
        **/
        this(Dg dg, ref Args args) @safe {
            this.dg = dg;
            this.args = args;
        }

        /**
        Accepts a reference to an object that is to be configured by the configurer.

        Params:
        	object = An object of type T, that will be configured
        **/
        void configure(ref T object) @trusted {

            try {
                debug(trace) trace("Configuring ", typeid(T), " using function/delegate ", typeid(Dg), " with arguments of ",   ", ".separated(this.args).wrapped);
                return this.dg(this.locator, object, args);
            } catch (Exception e) {
            	throw new PropertyConfigurerException("Error occurred while running a callback over ${identity} of ${type} component", null, null, typeid(T), e);
            }
        }
    }
}

/**
ditto
**/
auto callbackConfigurer(T, X, Args...)(void delegate(Locator!(), X, Args) dg, auto ref Args args) if (is(T : X)) {
    auto constr = new CallbackConfigurer!(T, X, void delegate(Locator!(), X, Args), Args)(dg, args);
    return constr;
}

/**
ditto
**/
auto callbackConfigurer(T, X, Args...)(void function(Locator!(), X, Args) dg, auto ref Args args) if (is(T : X))  {
    auto constr = new CallbackConfigurer!(T, X, void function(Locator!(), X, Args), Args)(dg, args);
    return constr;
}

/**
ditto
**/
auto callbackConfigurer(T, X, Args...)(void delegate(Locator!(), ref X, Args) dg, auto ref Args args) if (is(T : X))  {
    auto constr = new CallbackConfigurer!(T, X, void delegate(Locator!(), ref X, Args), Args)(dg, args);
    return constr;
}

/**
ditto
**/
auto callbackConfigurer(T, X, Args...)(void function(Locator!(), ref X, Args) dg, auto ref Args args) if (is(T : X))  {
    auto constr = new CallbackConfigurer!(T, X, void function(Locator!(), ref X, Args), Args)(dg, args);
    return constr;
}


/**
Instantiates a component using a value as basis.

Instantiates a component using a value as basis.
As a consequence, any reference based type will
point to same content when it is instantiated
multiple times.
**/
@safe class ValueInstanceFactory(T) : InstanceFactory!T {
    private {
        T initial_;
    }

    mixin AllocatorAwareMixin!(typeof(this));
    mixin LocatorAwareMixin!(typeof(this));

    public {
        /**
            Constructor for ValueInstanceFactory!T

            Params:
                initial = argument that is to be passed as created object
        **/
        this(T initial) @safe {
            this.initial = initial;
        }

        @property {

            /**
                Set initial

                Params:
                    initial = value which will be passed as created component
                Returns:
                    typeof(this)
            **/
        	ValueInstanceFactory!T initial(T initial) @safe nothrow {
        		this.initial_ = initial;

        		return this;
        	}

            /**
                Get initial

                Returns:
                    T
            **/
        	T initial() @safe nothrow {
        		return this.initial_;
        	}
        }

        /**
        Create a new instance of object of type T.

        Returns:
            T instantiated component
        **/
        T factory() @safe {
            debug(trace) trace("Providing existing ", typeid(T), " as instantiated component.");
            return this.initial();
        }
    }
}

/**
InstanceFactory that delegates the task of instantiating a component
to some third party factory.
**/
@safe class DelegatingInstanceFactory(T, X : T) : InstanceFactory!T, MutableDecorator!(Factory!X) {

    mixin AllocatorAwareMixin!(typeof(this));
    mixin LocatorAwareMixin!(typeof(this));

    private {
        Factory!X decorated_;
    }

    public {

        /**
            Default constructor for DelegatingInstanceFactory!(T, X)
        **/
        this() @safe {

        }

        /**
            Constructor for DelegatingInstanceFactory!(T, X)

            Params:
                factory = the factory to which this instance will delegate the task of creating a component
        **/
        this(Factory!X factory) @safe {
            this.decorated = factory;
        }

        mixin MutableDecoratorMixin!(Factory!X);

        /**
        Create a new instance of object of type T.

        Returns:
            T instantiated component
        **/
        T factory() @safe {
            debug(trace) trace("Delegating contruction of ", typeid(T), " to third party factory.");
            return this.decorated.factory();
        }
    }
}

/**
Default implementation of destructor that calls dispose upon @safe classes only.
**/
@safe class DefaultInstanceDestructor(T) : InstanceDestructor!T {

    mixin AllocatorAwareMixin!(typeof(this));
    mixin LocatorAwareMixin!(typeof(this));

    /**
    Destruct a component of type T and deallocate it using stored allocator.

    Params:
        destructable = element to be destructed and deallocated using stored allocator
    **/
    void destruct(ref T component) @trusted {
        import std.experimental.allocator : dispose;

        static if (is(T == class)) {
            debug(trace) trace("Destroying existing component of ", typeid(T));
            this.allocator.dispose(component);
        }

        // Do nothing here.
    }
}

/**
Instance destructor that uses a callback to destroy and deallocate components of type T.
**/
@safe class CallbackInstaceDestructor(T, Dg : void delegate(RCIAllocator, ref T destructable, Args), Args...) : InstanceDestructor!T {
    mixin AllocatorAwareMixin!(typeof(this));
    mixin LocatorAwareMixin!(typeof(this));
    mixin ParameterHolder!(Args);

    private {
        Dg dg_;
    }

    public {
        @property {
            /**
            Set dg

            Params:
                dg = the delegate used to destroy component
            Returns:
                typeof(this)
            **/
            typeof(this) dg(Dg dg) @safe nothrow pure {
                this.dg_ = dg;

                return this;
            }

            /**
            Get dg

            Returns:
                Dg
            **/
            Dg dg() @safe nothrow pure {
                return this.dg_;
            }
        }

        /**
        Destruct a component of type T and deallocate it using stored allocator.

        Params:
            destructable = element to be destructed and deallocated using stored allocator
        **/
        void destruct(ref T destructable) @trusted {
            debug(trace) trace("Destroying ", typeid(T), " using function/delegate ", typeid(Dg), " with arguments of ",   ", ".separated(this.args).wrapped);
            this.dg()(this.allocator, destructable, this.args);
        }
    }
}

/**
ditto
**/
CallbackInstaceDestructor!(T, Dg, Args) callbackInstanceDestructor
    (T, Dg : void delegate(RCIAllocator, ref T destructable, Args), Args...)
    (Dg dg, Args args) {

    auto callbackInstanceDestructor =
        new CallbackInstaceDestructor!(T, Dg, Args)()
        .dg(dg);

    static if (Args.length > 0) {

        callbackInstanceDestructor.args = args;
    }

    return callbackInstanceDestructor;
}

/**
Instance destructor using an third party component to do destruction of components.
**/
template FactoryMethodInstanceDestructor(string method, T, Z, Args...)
    if (
        isSomeFunction!(getMember!(T, method)) &&
        isMethodCompatible!(T, method, Z, Args)
    ) {

    alias Compatible = getCompatibleOverload!(T, method, Z, Args);

    @safe class FactoryMethodInstanceDestructor : InstanceDestructor!Z {

        mixin LocatorAwareMixin!(typeof(this));
        mixin AllocatorAwareMixin!(typeof(this));
        mixin ParameterHolder!(Args);

        public {

            static if (!isStaticFunction!(Compatible)) {

                T destructor_;

                @property {
                    /**
                    Set destructor

                    Params:
                        destructor = the component destructor used to destroy component

                    Returns:
                        typeof(this)
                    **/
                    typeof(this) destructor(T destructor) @safe nothrow pure {
                        this.destructor_ = destructor;

                        return this;
                    }

                    /**
                    Get destructor

                    Returns:
                        T
                    **/
                    T destructor() @safe nothrow pure {
                        return this.destructor_;
                    }
                }
            }

            /**
            Destruct a component of type T and deallocate it using stored allocator.

            Params:
                destructable = element to be destructed and deallocated using stored allocator
            **/
            void destruct(ref Z destructable) @trusted {
                debug(trace) trace("Destroying ", typeid(Z), " using destruction method ", method, " of ", typeid(T), " with arguments of ",   ", ".separated(this.args).wrapped);
                static if (!isStaticFunction!(Compatible)) {
                    __traits(getMember, this.destructor, method)(destructable, this.args);
                } else {
                    __traits(getMember, T, method)(destructable, this.args);
                }
            }
        }
    }
}

/**
Create an instance destructor that uses third party component's method to do destruction of a component.

Create an instance destructor that uses third party component's method to do destruction of a component.

Params:
    Z = the type of destructed object
    method = method used from component T to destroy component Z
    destructor = type of destructor component
    arguments = list of arguments passed to destructor component's method

Returns:
    FactoryMethodInstanceDestructor!(method, T, Z, Args)
**/
auto factoryMethodInstanceDestructor(
    Z,
    string method,
    T,
    Args...
)(
    T destructor,
    Args arguments
) if (isNonStaticMethodCompatible!(T, method, Z, Args)) {

    auto instanceDestructor = new FactoryMethodInstanceDestructor!(method, T, Z, Args)();
    instanceDestructor.destructor = destructor;

    static if (Args.length > 0) {

        instanceDestructor.args = arguments;
    }

    return instanceDestructor;
}

/**
ditto
**/
auto factoryMethodInstanceDestructor(
    Z,
    string method,
    T,
    Args...
)(
    Args arguments
)
if (isStaticMethodCompatible!(T, method, Z, Args)) {

    auto destructor = new FactoryMethodInstanceDestructor!(method, T, Z, Args)();

    static if (Args.length > 0) {
        destructor.args = arguments;
    }

    return destructor;
}

/**
A check if the argument list passed to ConstructorBasedFactory or MethodConfigurer is compatible with signature of underlying
method or constructor.

Note:
	For now it checks if the lengths are equal. For future it should also check if types are compatible.
**/
template isArgumentListCompatible(alias func, ArgTuple...)
	if (isSomeFunction!func) {
    bool isArgumentListCompatible() @safe {
        alias FuncParams = Parameters!func;
        alias Required = Filter!(partialSuffixed!(isValueOfType, void), ParameterDefaults!func);

        static if ((ArgTuple.length < Required.length) || (ArgTuple.length > FuncParams.length)) {

            return false;
        } else {

            bool result = true;
            foreach (index, Argument; ArgTuple) {

                static if (!is(Argument : RuntimeReference) && !isImplicitlyConvertible!(Argument, FuncParams[index])) {

                    result = false;
                    break;
                }
            }

            return result;
        }
    }
}

mixin template assertFieldCompatible(T, string field, Arg) {
    import aermicioi.aedi.util.traits;
    import std.traits;
    import std.meta;

    static assert(isField!(T, field), name!T ~ "'s " ~ field ~ " member is not a field");
    static assert(isProtection!(T, field, "public"), name!T ~ "'s " ~ field ~ " is not public and therefore cannot be accessed.");
    static assert(is(Arg : RuntimeReference) ? true : isImplicitlyConvertible!(Arg, typeof(getMember!(T, field))), name!T ~"'s " ~ field ~ " type " ~ name!(typeof(getMember!(T, field))) ~ " doesn't match with passed arguments type " ~ name!Arg);
}

enum bool isFieldCompatible(T, string field, Arg) =
    isField!(T, field) &&
    isProtection!(T, field, "public") &&
    is(Arg : RuntimeReference) ? true : isImplicitlyConvertible!(Arg, typeof(getMember!(T, field)));

mixin template assertObjectConstructorCompatible(T, Args...) {
    import aermicioi.aedi.util.traits;
    import std.traits;
    import std.meta;

    static assert(hasMember!(T, "__ctor"), name!T ~ " doesn't have any constructor to call.");
    static assert(isProtection!(T, "__ctor", "public"), name!T ~ "'s constructor is not public.");
    static assert(isSomeFunction!(__traits(getMember, T, "__ctor")), name!T ~ "'s constructor is not a function, probably a template.");
    static assert(variadicFunctionStyle!(__traits(getMember, T, "__ctor")) == Variadic.no, name!T ~ "'s constructor is a variadic function. Only non-variadic constructors are supported.");
    static assert(Filter!(partialSuffixed!(isArgumentListCompatible, Args), __traits(getOverloads, T, "__ctor")).length == 1, "None, or multiple overloads found for " ~ name!T ~ "'s constructor with passed arguments.");
}

enum bool isObjectConstructorCompatible(T, Args...) = isMethodCompatible!(T, "__ctor", Args);

mixin template assertObjectMethodCompatible(T, string method, Args...) {
    import std.range : only;
    import std.algorithm : joiner;
    import std.array : array;
    import aermicioi.aedi.util.traits;
    import std.traits;
    import std.meta;

    static assert(hasMember!(T, method), name!T ~ "'s method " ~ method ~ " not found.");
    static assert(isProtection!(T, method, "public"), name!T ~ "'s method " ~ method ~ " is not public");
    static assert(isSomeFunction!(__traits(getMember, T, method)), name!T ~ "'s member " ~ method ~ " is not a function, probably a field, or a template.");
    static assert(variadicFunctionStyle!(__traits(getMember, T, method)) == Variadic.no, name!T ~ "'s method " ~ method ~ "is variadic function. Only non-variadic methods are supported.");
    static assert(Filter!(partialSuffixed!(isArgumentListCompatible, Args), getOverloads!(T, method)).length == 1, name!T ~ "'s " ~ method ~ " doesn't have overload matching passed arguments (" ~ only("", staticMap!(name, Args)).joiner(", ").array ~ "), or has several overloads that match.");
}

enum bool isObjectMethodCompatible(T, string method, Args...) = isMethodCompatible!(T, method, Args);

template isMethodCompatible(T, string method, Args...) {
    enum bool isMethodCompatible =
            hasMember!(T, method) &&
            isProtection!(T, method, "public") &&
            isSomeFunction!(__traits(getMember, T, method)) &&
            (variadicFunctionStyle!(__traits(getMember, T, method)) == Variadic.no) &&
            (Filter!(partialSuffixed!(isArgumentListCompatible, Args), getOverloads!(T, method)).length == 1);
}

template getCompatibleOverload(T, string method, Args...)
    if (isObjectMethodCompatible!(T, method, Args)) {

    alias getCompatibleOverload = Filter!(partialSuffixed!(isArgumentListCompatible, Args), getOverloads!(T, method))[0];
}

alias isStaticMethodCompatible = templateAnd!(
    isMethodCompatible,
    chain!(
        isStaticFunction,
        getCompatibleOverload
    )
);

alias isNonStaticMethodCompatible = templateAnd!(
    isMethodCompatible,
    chain!(
        templateNot!isStaticFunction,
        getCompatibleOverload
    )
);

alias isNonStaticMethodCompatibleAndReturnTypeOf(X) = templateAnd!(
    isMethodCompatible,
    chain!(
        templateNot!isStaticFunction,
        getCompatibleOverload
    ),
    partialSuffixed!(
        chain!(
            partialPrefixed!(
                get,
                0
            ),
            getCompatibleOverload
        ),
        X
    )
);

private {
    template isValueOfType(alias value, Type) {
        enum bool isValueOfType = is(typeof(value) == Type);
    }

    template isValueOfType(Value, Type) {
        enum bool isValueOfType = is(Value == Type);
    }

    enum bool isStruct(T) = is(T == struct);


    template hasDefaultCtor(T) {
        static if (!__traits(hasMember, T, "__ctor")) {
            enum found = true;
        }

        static if (!is(typeof(found)) && is(T == struct)) {
            enum found = true;
        }

        static if (!is(typeof(found)) && isProtection!(T, "__ctor", "public")) {
            static foreach (overload; __traits(getOverloads, T, "__ctor")) {
                static if (!is(typeof(found)) && (variadicFunctionStyle!overload == Variadic.no)) {
                    static if (arity!overload == 0) {
                        enum found = true;
                    }
                }
            }
        }

        static if (!is(typeof(found))) {
            enum found = false;
        }

        enum hasDefaultCtor = found;
    }
}

private {
    string compileArgumentsTuple(Tuple...)(string types, string array, string locator) @safe {
        import std.conv : to;
        import std.array : join;
        string[] stmt;

        foreach (index, Type; Tuple) {
            stmt ~= array ~ "[" ~ index.to!string ~ "].resolve!(" ~ types ~ "[" ~ index.to!string ~ "])(" ~ locator ~ ")";
        }

        return stmt.join(", ");
    }
}