/**

License:
	Boost Software License - Version 1.0 - August 17th, 2003
    
    Permission is hereby granted, free of charge, to any person or organization
    obtaining a copy of the software and accompanying documentation covered by
    this license (the "Software") to use, reproduce, display, distribute,
    execute, and transmit the Software, and to prepare derivative works of the
    Software, and to permit third-parties to whom the Software is furnished to
    do so, all subject to the following:
    
    The copyright notices in the Software and this entire statement, including
    the above license grant, this restriction and the following disclaimer,
    must be included in all copies of the Software, in whole or in part, and
    all derivative works of the Software, unless such copies or derivative
    works are solely in the form of machine-executable object code generated by
    a source language processor.
    
    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
    SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
    FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
    ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
    DEALINGS IN THE SOFTWARE.

Authors:
	Alexandru Ermicioi
**/
module aermicioi.aedi.factory.generic_factory;

import aermicioi.aedi.factory.factory;
import aermicioi.aedi.factory.reference;

import aermicioi.aedi.storage.locator;
import aermicioi.aedi.storage.locator_aware;
import aermicioi.aedi.exception;
import aermicioi.aedi.storage.wrapper;
import aermicioi.util.traits;

import std.typecons;
import std.traits;
import std.meta;
import std.conv : to;

/**
A property configurer, has the purpose to modify data of type T according to some logic encapsulated in it.

**/
interface PropertyConfigurer(T) {
    
    public {
        
        /**
        Accepts a reference to an object that is to be configured by the configurer.
        
        Params:
        	object = An object of type T, that will be configured
        **/
        void configure(ref T object);
    }
}

/**
An instance factory, instantiates data of type T.
**/
interface InstanceFactory(T) {
    
    public {
        
        /**
        Create a new instance of object of type T.
        **/
        T factory();
    }
}

/**
A generic factory, is a factory that instantiates data of type T using InstanceFactory and a list of PropertyConfigurers.

A generic factory, is a factory that instantiates data of type T using InstanceFactory and a list of PropertyConfigurers.
It can optionally provide a Locator!() object to InstanceFactory and PropertyConfigurer to be used as a source of data. 
**/
interface GenericFactory(T) : Factory!T {
    
    public {
        
        @property {
            
            /**
            Sets the constructor of new object.
            
            Params:
            	factory = a factory of objects of type T.
        	
        	Returns:
    			The GenericFactoryInstance
            **/
            GenericFactory!T setInstanceFactory(InstanceFactory!T factory);
            
            
            alias locator = Factory!T.locator;
            
            /**
            Get the GenericFactory locator.
            
            Returns:
            	Locator!() the locator that should be used by underlying constructor or property configurer.
            **/
            Locator!() locator();
        }
        
        /**
        Adds an configurer to the GenericFactory.
        
        Params:
        	configurer = a configurer that will be invoked after factory of an object.
        	
    	Returns:
    		The GenericFactoryInstance
        **/
        GenericFactory!T addPropertyConfigurer(PropertyConfigurer!T configurer);
    }
}

/**
A concrete implementation of GenericFactory interface.
**/
class GenericFactoryImpl(T) : GenericFactory!T, LocatorAware!() {
    
    private {
        Locator!() locator_;
        
        InstanceFactory!T factory_;
        
        PropertyConfigurer!T[] configurers;
    }
    
    public {
        
        this(Locator!() locator) {
            this.locator = locator;
            
            static if (hasDefaultCtor!T) {
                
                this.setInstanceFactory(
                    new DefaultConstructorBasedFactory!T
                );
            }
        }
        
        T factory() {
            T instance;
            
            if (this.factory_ !is null) {
                instance = this.factory_.factory;
            } else {
                
                throw new AediException("Failed to construct object due to no constructor");
            }

            foreach (key, configurer; this.configurers) {
                configurer.configure(instance);
            }
            
            return instance;
        }
        
        @property {
            
            GenericFactory!T setInstanceFactory(InstanceFactory!T factory) {
                this.factory_ = factory;
                
                return this;
            }
            
            GenericFactoryImpl!T locator(Locator!() locator) {
                this.locator_ = locator;
                return this;
            }
            
            Locator!() locator() {
                return this.locator_;
            }
            
            /**
    		Get the type info of object that is created.
    		
    		Returns:
    			TypeInfo object of created object.
    		**/
    		TypeInfo type() {
    		    return typeid(T);
    		}
        }
            
        GenericFactory!T addPropertyConfigurer(PropertyConfigurer!T configurer) {
            
            this.configurers ~= configurer;
            
            return this;
        }
    }
    
}

/**
ParameterHolder Stores a set of Args for futher usage in it's subclasses.

Params:
    Args = a type tuple of args that ParameterHolder can hold.
**/
abstract class ParameterHolder(Args...) : LocatorAware!() {
    
    protected {
        Tuple!Args args_;
        Locator!() locator_;
    }
    
    public {
        
        static if (Args.length > 0) {
            ParameterHolder args(ref Args args) @safe nothrow {
            	this.args_ = tuple(args);
            
            	return this;
            }
        }
        
        Tuple!Args args() @safe nothrow {
        	return this.args_;
        } 
    
        @property {
            /**
    		Sets the locator that will be used by configurer to fetch object referenced in argument list.
    		
    		Params:
    			locator = the (service) locator that will be used to fetch required objects.
    		
    		Returns:
    			The ParameterHolder instance.
    		**/
            ParameterHolder!Args locator(Locator!() locator)  {
            	this.locator_ = locator;
            
            	return this;
            }
            
            Locator!() locator() @safe nothrow {
            	return this.locator_;
            }
        }
    }
}

/**
Calls aggregate's method with a set of arguments.

Encapsulates a call to aggregate's method, with a set of arguments.
The algorithm that calls aggregate's method, will automatically replace
references from args list with data extracted from container, casted to 
type that is extracted from method's signature.

Params:
    T = the aggregate type
    property = method that will be called
    Args = type tuple of args that method can be called with.
**/
class MethodConfigurer(T, string property, Args...) : ParameterHolder!Args, PropertyConfigurer!T
	if (
	    isMethodCompatible!(T, property, Args)
    ) {
    
    public {
        
        this(ref Args args) {
            this.args(args);
        }
        
        /**
        See PropertyConfigurer interface
        
        Throws:
            InvalidCastException when extracted data by reference, is not of type expected by argument
            of aggregate's method
        **/
        void configure(ref T obj) {
            
            try {
                
                alias ArgTuple = Parameters!(Filter!(partialSuffixed!(isArgumentListCompatible, Args), getOverloads!(T, property))[0]);
                Tuple!ArgTuple parameters;
                
                foreach (index, ref parameter; parameters) {
                    
                    parameter = args[index].resolve!(typeof(parameter))(this.locator);
                }
                __traits(getMember, obj, property)(parameters.expand);
            } catch (Exception e) {
                throw new PropertyConfigurerException("Error occurred during call of " ~ name!T ~ "." ~ property, e);
            }
        }
    }
}
    
/**
Invoke aggregate's method with supplied args.

Configures aggregate's factory to call specified method with passed args.
The function will check if the arguments passed to it are compatible with at 
least one method from possible overload set.
The args list can contain references to other objects in locator as well, though
no type compatibility checks will be performed at compile time.

Params:
	factory = the factory which will be configured to invoke method.
	args = the arguments that will be used to invoke method on the new object.
	
Returns:
	GenericFactory!T.
**/
auto methodConfigurer(string property, T, Args...)(Locator!() locator, auto ref Args args) 
    if (!isField!(T, property)) {
    mixin assertObjectMethodCompatible!(T, property, Args);
    
    auto propertySetter = new MethodConfigurer!(T, property, Args)(args);
    propertySetter.locator = locator;
    
    return propertySetter;
}

/**
Sets aggregate's field to a value.

Encapsulates logic that sets aggregates field to a certain value.
If argument that is contained by configurer is a reference, it will be automatically
replaced with value extracted from locator, and set to aggregate's field.
**/
class FieldConfigurer(T, string property, Arg) : ParameterHolder!Arg, PropertyConfigurer!T
	if (
	    isFieldCompatible!(T, property, Arg)
    ) {
    
    public {
        
        this(ref Arg arg) {
            this.args(arg);
        }
        
        /**
        See PropertyConfigurer interface
        
        Throws:
            InvalidCastException when extracted data by reference, is not of type expected by argument
            of aggregate's field
        **/
        void configure(ref T obj) {
            
            try {
            
                __traits(getMember, obj, property) = args[0].resolve!(typeof(__traits(getMember, obj, property)))(this.locator);
            } catch (Exception e) {
                
                throw new PropertyConfigurerException("Error occurred during set of " ~ name!T ~ "." ~ property, e);
            }
        }
    }
}
    
/**
Set aggregate's public field to passed arg.

Configures aggregate's factory to set specified field to passed arg.
The function will check if passed argument is type compatible with specified field.
The argument can be a reference as well. In case of argument being reference to another data
in container, no type compatiblity checking will be done.

Params
    factory = the factory which will be configured to set property.
	arg = the value of property to be set, or reference to data in container.

Returns:
	GenericFactory!T.
**/
auto fieldConfigurer(string property, T, Arg)(Locator!() locator, auto ref Arg arg)
    if (isField!(T, property)) {
    mixin assertFieldCompatible!(T, property, Arg);
    
    auto propertySetter = new FieldConfigurer!(T, property, Arg)(arg);
    propertySetter.locator = locator;
    
    return propertySetter;
}

/**
Instantiates an aggregate using it's constructor with no arguments.
**/
class DefaultConstructorBasedFactory(T) : InstanceFactory!T 
    if (
        hasDefaultCtor!T
    ) {
    
    public {
        
        T factory() {
            
            try {
                static if (is(T : Object)) {
                    return new T();
                } else {
                    return T.init;
                }
            } catch (Exception e) {
                throw new InstanceFactoryException("Error occurred during instantiation of " ~ name!T, e);
            }
        }
    }
}
    
/**
Instantiates aggregate using it's constructor with args.

Encapsulates construction of aggregate using a constructor, with args.
Arguments from argument list that are references, are automatically 
replaced with data extracted from locator.

Params:
    T = aggregate type
    Args = type tuple of args that are passed to T's constructor
**/
class ConstructorBasedFactory(T, Args...) : ParameterHolder!Args, InstanceFactory!T
	if (
	    isObjectConstructorCompatible!(T, Args)
	) {
    
    public {
        
        this(ref Args args) {
            this.args(args);
        }
        
        /**
        See InstanceFactory interface
        
        Throws:
            InvalidCastException when extracted data by reference, is not of type expected by argument
            of aggregate's constructor
        **/
        T factory() {
            
            try {
                
                alias ConstructorArgs = Parameters!(Filter!(partialSuffixed!(isArgumentListCompatible, Args), __traits(getOverloads, T, "__ctor"))[0]);
                
                Tuple!ConstructorArgs parameters;
                
                foreach (index, ref parameter; parameters) {
                    parameter = this.args[index].resolve!(typeof(parameter))(this.locator);
                }
                
                static if (is(T : Object)) {
                    return new T(parameters.expand);
                } else {
                    return T(parameters.expand);
                }
            } catch (Exception e) {
                
                throw new InstanceFactoryException("Error occurred during instantiation of " ~ name!T, e);
            }
        }
    }
}
	
/**
Construct aggregate using args.

Constructs aggregate using args, that are passed to function.
The function will attempt to find at least one construct that 
can accept passed argument list. If it fails, compiler will
produce error, with respective problems.
The argument list can contain beside simple values, references
to other data in locator. Arguments that are references to other data
won't be type checked.

Params:
	factory = the factory which will call constructor with passed arguments.
	args = a list of arguments that will be passed to constructor.
	
Returns:
	GenericFactory!T.
**/

auto constructorBasedFactory(T, Args...)(Locator!() locator, auto ref Args args) {
    mixin assertObjectConstructorCompatible!(T, Args);
    auto constructor = new ConstructorBasedFactory!(T, Args)(args);
    
    constructor.locator = locator;
    
    return constructor;
}
	
/**
Instantiates an aggregate using a method from other aggregate (factory method pattern).

Encapsulates construction of aggregate using factory method.
Arguments that are references, will be replaced with data extracted
from locator, and passed to factory's method.
In case when method is not static member, the algorithm will use 
an instantiaton of factory passed to it, or extracted from locator
if a reference is passed.

Params:
    T = factory that is used to instantiate aggregate using it's method
    method = the name of method used to instantiate aggregate
    W = the factory T, or a LocatorReference to the factory.
    Args = type tuple of arguments passed to factory.
**/
class FactoryMethodBasedFactory(T, string method, W, Args...) : ParameterHolder!Args, InstanceFactory!(ReturnType!(getCompatibleOverload!(T, method, Args)))
    if (
        (is(W : LocatorReference) || is(W : T)) &&
        isMethodCompatible!(T, method, Args) &&
        isAggregateType!(ReturnType!(getCompatibleOverload!(T, method, Args)))
    ) {
        
    static if (!__traits(isStaticFunction, getCompatibleOverload!(T, method, Args))) {
        
        private {
            W fact;
        }
        
        public {
            this(ref W fact, ref Args args) {
                this.args(args);
                this.fact = fact;
            }
        }
    } else {
        
        this(ref Args args) {
            this.args(args);
        }
    }
        
    private {
        
        alias Z = ReturnType!(getCompatibleOverload!(T, method, Args));
    }
    
    public {
        /**
        See InstanceFactory interface
        
        Throws:
            InvalidCastException when extracted data by reference, is not of type expected by argument
            factory's method, or when factory is referenced, and the object referenced in locator is not
            of factory's type T.
        **/
        Z factory() {
            
            try {
                
                alias FactoryMethodParameters = Parameters!(Filter!(partialSuffixed!(isArgumentListCompatible, Args), __traits(getOverloads, T, method))[0]);
                
                Tuple!FactoryMethodParameters parameters;
                
                foreach (index, ref parameter; parameters) {
                    parameter = this.args[index].resolve!(typeof(parameter))(this.locator);
                }
                
                static if (!__traits(isStaticFunction, getCompatibleOverload!(T, method, Args))) {
    
                    return __traits(getMember, this.fact.resolve!(T)(this.locator), method)(parameters.expand);
                } else {
    
                    return __traits(getMember, T, method)(parameters.expand);
                }
            } catch (Exception e) {
                
                throw new InstanceFactoryException("Error occurred during instantiation of " ~ name!T ~ " using factory method of " ~ name!T ~ "." ~ method, e);
            }
        }
    }
}
    
/**
Invoke T's method to create data of type X.

Configures aggregate's factory to call method of factoryMethod with args,
in order to create data of type X.
In case when method is not a static member, the function requires to
pass a instance of factoryMethod or a reference to it.
The algorithm will check for args compatiblity with parameters of 
factory method. No type check is done for arguments that are references
at compile time.

Params:
    factory = aggregate's factory that is configured to call factoryMethod methods to spawn aggregate
    factoryMethod = instance of factory method that will be used to instantiate aggregate
    args = a list of arguments passed to factory method
    T = type of factoryMethod
    method = the method that is called from T to instantiate aggregate
    W = either LocatorReference or T
    X = the return type of T.method member
**/
auto factoryMethodBasedFactory(T, string method, W, Args...)(Locator!() locator, auto ref W factoryMethod, auto ref Args args)
    if (
        isNonStaticMethodCompatible!(T, method, Args) &&
        (is(W : T) || is(W : LocatorReference))
    ) {
        
    auto constructor = new FactoryMethodBasedFactory!(T, method, W, Args)(factoryMethod, args);
    
    constructor.locator = locator;
    
    return constructor;
}

/**
ditto
**/
auto factoryMethodBasedFactory(T, string method, Args...)(Locator!() locator, auto ref Args args)
    if (
        isStaticMethodCompatible!(T, method, Args)
    ) {
    auto constructor = new FactoryMethodBasedFactory!(T, method, T, Args)(args);
    
    constructor.locator = locator;
    
    return constructor;
}
    
/**
Instantiates data of type T using a delegate or function.

Encapsulates data's construction logic using a delegate.
The algorithm uses a delegate to create required data, 
with a set of Args that are passed to delegate, and a locator
for dependency fetching. 

Params:
    T = the constructed aggregate
    Args = type tuple of arguments passed to delegate for aggregate's construction. 
**/
class CallbackFactory(T, Dg, Args...) : ParameterHolder!Args, InstanceFactory!T
    if ((is(Dg == T delegate (Locator!(), Args)) || is(Dg == T function (Locator!(), Args)))) {
    
    private {
        Dg dg;
    }
    
    public {
        this(Dg dg, ref Args args) {
            this.dg = dg;
            this.args(args);
        }
        
        /**
        See InstanceFactory interface
        **/
        T factory() {
            try {
                
                return this.dg(this.locator_, args.expand);
            } catch (Exception e) {
                
                throw new InstanceFactoryException("Error occurred during instantiation of " ~ name!T ~ " using callback factory", e);
            }
        }
    }
}
    
/**
Construct aggregate using a delegate.

Constructs aggregate using a delegate, and a list of arguments passed to delegate.

Params:
	factory = the factory which will use delegate to construct aggregate.
	dg = the delegate that is responsible for creating aggregate, given a list of arguments.
	args = the arguments that will be used by delegate to construct aggregate.
	
Returns:
	GenericFactory!T.
**/
auto callbackFactory(T, Args...)(Locator!() locator, T delegate(Locator!(), Args) dg, auto ref Args args) {
    auto constr = new CallbackFactory!(T, T delegate(Locator!(), Args), Args)(dg, args);
    constr.locator = locator;
    return constr;
}
    
/**
ditto
**/
auto callbackFactory(T, Args...)(Locator!() locator, T function(Locator!(), Args) dg, auto ref Args args) {
    auto constr = new CallbackFactory!(T, T function(Locator!(), Args), Args)(dg, args);
    constr.locator = locator;
    return constr;
}

/**
Configures/modifies data of type T with help of a delegate or function.

Encapsulates data configuration logic using a delegate.
The algorithm calls delegate, with a locator, a set of Args,
and configured data, in order to modify the data
somehow.

Note:
    If data is not a reference type it is recommended to pass it by reference
    in order to avoid receiving of a copy and not original one in delegate.
Params:
    T = the aggregate
    Args = type tuple of arguments used by delegate for customization.
**/
class CallbackConfigurer(T, Dg, Args...) : ParameterHolder!Args, PropertyConfigurer!T 
    if (
        is(Dg == void delegate (Locator!(), T, Args)) || 
        is(Dg == void function (Locator!(), T, Args)) ||
        is(Dg == void delegate (Locator!(), ref T, Args)) || 
        is(Dg == void function (Locator!(), ref T, Args))
    ) {
    
    private {
        Dg dg;
    }
    
    /**
    See InstanceFactory interface
    **/
    public {
        this(Dg dg, ref Args args) {
            this.dg = dg;
            this.args(args);
        }
        
        void configure(ref T object) {
            
            try {
            
                return this.dg(this.locator_, object, args.expand);
            } catch (Exception e) {
            	throw new PropertyConfigurerException("Error occurred during callback configuration of " ~ name!T, e);
            }
        }
    }
}
    
/**
Call dg on an aggregate that is in configuration phase.

Call dg on aggregate to perform some modifications, using args as input.

Params:
    factory = factory which will call dg with args.
    dg = delegate that will perform some modifications on aggregate using passed args.
    args = a list of arguments passed to dg.
    
Returns:
    GenericFactory!T
**/
auto callbackConfigurer(T, Args...)(Locator!() locator, void delegate(Locator!(), T, Args) dg, auto ref Args args) {
    auto constr = new CallbackConfigurer!(T, void delegate(Locator!(), T, Args), Args)(dg, args);
    constr.locator = locator;
    return constr;
}
    
/**
ditto
**/
auto callbackConfigurer(T, Args...)(Locator!() locator, void function(Locator!(), T, Args) dg, auto ref Args args) {
    auto constr = new CallbackConfigurer!(T, void function(Locator!(), T, Args), Args)(dg, args);
    constr.locator = locator;
    return constr;
}

/**
ditto
**/
auto callbackConfigurer(T, Args...)(Locator!() locator, void delegate(Locator!(), ref T, Args) dg, auto ref Args args) {
    auto constr = new CallbackConfigurer!(T, void delegate(Locator!(), ref T, Args), Args)(dg, args);
    constr.locator = locator;
    return constr;
}
    
/**
ditto
**/
auto callbackConfigurer(T, Args...)(Locator!() locator, void function(Locator!(), ref T, Args) dg, auto ref Args args) {
    auto constr = new CallbackConfigurer!(T, void function(Locator!(), ref T, Args), Args)(dg, args);
    constr.locator = locator;
    return constr;
}


/**
Instantiates a component using a value as basis.

Instantiates a component using a value as basis.
As a consequence, any reference based type will 
point to same content when it is instantiated 
multiple times. 
**/
class ValueInstanceFactory(T) : InstanceFactory!T {
    private {
        T initial_;
    }
    
    public {
        this(T initial) {
            this.initial = initial;
        }
        
        @property {
        	ValueInstanceFactory!T initial(T initial) @safe nothrow {
        		this.initial_ = initial;
        	
        		return this;
        	}
        	
        	T initial() @safe nothrow {
        		return this.initial_;
        	}
        }
        
        T factory() {
            return this.initial();
        }
    }
}

/**
Instantiates data of type T using another factory, and configures it with help of it's own property configurers.
**/
class ParentAwareGenericFactory(T) : GenericFactory!T {
    
    private {
        Factory!T fact_;
        Locator!() locator_;
        PropertyConfigurer!T[] configurers;
    }
    
    public {
        @property {
        	ParentAwareGenericFactory fact(Factory!T fact) @safe nothrow {
        		this.fact_ = fact;
        	
        		return this;
        	}
        	
        	Factory!T fact() @safe nothrow {
        		return this.fact_;
        	}
        	
        	ParentAwareGenericFactory locator(Locator!() locator) @safe nothrow {
        		this.locator_ = locator;
        	
        		return this;
        	}
        	
        	Locator!() locator() @safe nothrow {
        		return this.locator_;
        	}
        	
        	TypeInfo type() @safe nothrow {
        		return typeid(T);
        	}
        }
        
        T factory() {
            T result = this.fact.factory;
            
            foreach (configurer; this.configurers) {
                configurer.configure(result);
            }
            
            return result;
        }
        
        ParentAwareGenericFactory!T setInstanceFactory(InstanceFactory!T factory) {
            throw new AediException("Setting constructor for an object with parent is not supported yet.");
        }
        
        ParentAwareGenericFactory!T addPropertyConfigurer(PropertyConfigurer!T configurer) {
            this.configurers ~= configurer;
            
            return this;
        }
    }
}

GenericFactory!T genericFactory(T)(Locator!() locator) {
    return new GenericFactoryImpl!T(locator);
}

/**
An check if the argument list passed to ConstructorBasedFactory or MethodConfigurer is compatible with signature of underlying
method or constructor.

Note:
	For now it checks if the lengths are equal. For future it should also check if types are compatible.
**/
template isArgumentListCompatible(alias func, ArgTuple...) 
	if (isSomeFunction!func) {
    bool isArgumentListCompatible() {
        alias FuncParams = Parameters!func;
        alias Required = Filter!(partialSuffixed!(isValueOfType, void), ParameterDefaults!func);
       
        static if ((ArgTuple.length < Required.length) || (ArgTuple.length > FuncParams.length)) {
          
            return false;
        } else {
            
            bool result = true;
            foreach (index, Argument; ArgTuple) {
          
                static if (!is(Argument : LocatorReference) && !isImplicitlyConvertible!(Argument, FuncParams[index])) {
          
                    result = false;
                    break;
                } 
            }
            
            return result;
        }
    }
}
	
mixin template assertFieldCompatible(T, string field, Arg) {
    import aermicioi.util.traits;
    import std.traits;
    import std.meta;
    
    static assert(isField!(T, field), name!T ~ "'s " ~ field ~ " member is not a field");
    static assert(isProtection!(T, field, "public"), name!T ~ "'s " ~ field ~ " is not public and therefore cannot be accessed.");
    static assert(is(Arg : LocatorReference) ? true : isImplicitlyConvertible!(Arg, typeof(getMember!(T, field))), name!T ~"'s " ~ field ~ " type " ~ name!(typeof(getMember!(T, field))) ~ " doesn't match with passed arguments type " ~ name!Arg);
}

enum bool isFieldCompatible(T, string field, Arg) = 
    isField!(T, field) &&
    isProtection!(T, field, "public") &&
    is(Arg : LocatorReference) ? true : isImplicitlyConvertible!(Arg, typeof(getMember!(T, field)));

mixin template assertObjectConstructorCompatible(T, Args...) {
    import aermicioi.util.traits;
    import std.traits;
    import std.meta;
    
    static assert(hasMember!(T, "__ctor"), name!T ~ " doesn't have any constructor to call.");
    static assert(isProtection!(T, "__ctor", "public"), name!T ~ "'s constructor is not public.");
    static assert(isSomeFunction!(__traits(getMember, T, "__ctor")), name!T ~ "'s constructor is not a function, probably a template.");
    static assert(variadicFunctionStyle!(__traits(getMember, T, "__ctor")) == Variadic.no, name!T ~ "'s constructor is a variadic function. Only non-variadic constructors are supported.");
    static assert(Filter!(partialSuffixed!(isArgumentListCompatible, Args), __traits(getOverloads, T, "__ctor")).length == 1, "None, or multiple overloads found for " ~ name!T ~ "'s constructor with passed arguments.");
}

enum bool isObjectConstructorCompatible(T, Args...) = isMethodCompatible!(T, "__ctor", Args);

mixin template assertObjectMethodCompatible(T, string method, Args...) {
    import std.range : only;
    import std.array : array;
    import aermicioi.util.traits;
    import std.traits;
    import std.meta;
    
    static assert(hasMember!(T, method), name!T ~ "'s method " ~ method ~ " not found.");
    static assert(isProtection!(T, method, "public"), name!T ~ "'s method " ~ method ~ " is not public");
    static assert(isSomeFunction!(__traits(getMember, T, method)), name!T ~ "'s member " ~ method ~ " is not a function, probably a field, or a template.");
    static assert(variadicFunctionStyle!(__traits(getMember, T, method)) == Variadic.no, name!T ~ "'s method " ~ method ~ "is variadic function. Only non-variadic methods are supported.");
    static assert(Filter!(partialSuffixed!(isArgumentListCompatible, Args), getOverloads!(T, method)).length == 1, name!T ~ "'s " ~ method ~ " doesn't have overload matching passed arguments (" ~ only(staticMap!(name, Args)).joiner(", ").array ~ "), or has several overloads that match.");
}

enum bool isObjectMethodCompatible(T, string method, Args...) = isMethodCompatible!(T, method, Args);


template isMethodCompatible(T, string method, Args...) {
    enum bool isMethodCompatible = 
            hasMember!(T, method) &&
            isProtection!(T, method, "public") &&
            isSomeFunction!(__traits(getMember, T, method)) &&
            (variadicFunctionStyle!(__traits(getMember, T, method)) == Variadic.no) &&
            (Filter!(partialSuffixed!(isArgumentListCompatible, Args), getOverloads!(T, method)).length == 1);
}

template getCompatibleOverload(T, string method, Args...)
    if (isObjectMethodCompatible!(T, method, Args)) {
    
    alias getCompatibleOverload = Filter!(partialSuffixed!(isArgumentListCompatible, Args), getOverloads!(T, method))[0];
}

alias isStaticMethodCompatible = templateAnd!(
    isMethodCompatible, 
    chain!(
        isStaticFunction, 
        getCompatibleOverload
    )
);

alias isNonStaticMethodCompatible = templateAnd!(
    isMethodCompatible, 
    chain!(
        templateNot!isStaticFunction, 
        getCompatibleOverload
    )
);

alias isNonStaticMethodCompatibleAndReturnTypeOf(X) = templateAnd!(
    isMethodCompatible, 
    chain!(
        templateNot!isStaticFunction, 
        getCompatibleOverload
    ),
    partialSuffixed!(
        chain!(
            partialPrefixed!(
                get,
                0
            ),
            getCompatibleOverload
        ),
        X
    )
);

private {
    template isValueOfType(alias value, Type) {
        enum bool isValueOfType = is(typeof(value) == Type);
    }
    
    template isValueOfType(Value, Type) {
        enum bool isValueOfType = is(Value == Type);
    }
    
    enum bool isStruct(T) = is(T == struct);
    
    alias hasDefaultCtor = 
        partialSuffixed!(
            templateOr!(
                templateNot!hasMember,
                chain!(
                    isStruct,
                    get!0
                ),
                templateAnd!(
                    partialSuffixed!(
                        isProtection,
                        "public"
                    ),
                    chain!(
                        partialPrefixed!(
                            anySatisfy,
                            eq!0
                        ),
                        partialPrefixed!(
                            staticMap,
                            arity
                        ),
                        chain!(
                            partialPrefixed!(
                                Filter,
                                partialSuffixed!(
                                    isProtection,
                                    "public"
                                )
                            ),
                            getOverloads
                        )
                    )
                )
            ),
            "__ctor"
        );
}	
