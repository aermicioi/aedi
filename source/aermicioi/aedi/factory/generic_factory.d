/**

License:
	Boost Software License - Version 1.0 - August 17th, 2003
    
    Permission is hereby granted, free of charge, to any person or organization
    obtaining a copy of the software and accompanying documentation covered by
    this license (the "Software") to use, reproduce, display, distribute,
    execute, and transmit the Software, and to prepare derivative works of the
    Software, and to permit third-parties to whom the Software is furnished to
    do so, all subject to the following:
    
    The copyright notices in the Software and this entire statement, including
    the above license grant, this restriction and the following disclaimer,
    must be included in all copies of the Software, in whole or in part, and
    all derivative works of the Software, unless such copies or derivative
    works are solely in the form of machine-executable object code generated by
    a source language processor.
    
    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
    SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
    FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
    ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
    DEALINGS IN THE SOFTWARE.

Authors:
	Alexandru Ermicioi
**/
module aermicioi.aedi.factory.generic_factory;


import aermicioi.aedi.exception;
import aermicioi.aedi.factory.factory;
import aermicioi.aedi.factory.reference;
import aermicioi.aedi.storage.decorator;
import aermicioi.aedi.storage.locator;
import aermicioi.aedi.storage.locator_aware;
import aermicioi.aedi.storage.wrapper;
import aermicioi.util.traits;


import std.conv : to;
import std.meta;
import std.traits;
import std.typecons;

/**
Interface for objects that are executing delayed/defferred actions.
**/
interface DefferredExecutioner {

    public {

        /**
        Add a new defferred action to be executed
        
        Params: 
            dg = the deffered action to execute
            
        Returns:
            typeof(this)
        **/
        DefferredExecutioner add(void delegate() dg);

        /**
        Add a set of defferred actions to be executed
        
        Params: 
            dgs = list of defferred actions
        
        Returns:
            typeof(this)
        **/
        DefferredExecutioner add(void delegate()[] dgs);

        /**
        Execute defferred actions
        
        Returns:
            typeof(this)
        **/
        DefferredExecutioner execute();
    }
}

/**
Interface for objects that are aware of deffered executioner, and are able to store their defferred actions in it
for later execution, by themselves or other third party.
**/
interface DefferredExecutionerAware {
    public {
        @property {
            /**
            Set executioner
            
            Params: 
                executioner = the executioner used to deffer actions for a later time
            
            Returns:
                typeof(this)
            **/
            typeof(this) executioner(DefferredExecutioner executioner) @safe nothrow pure;
            
            /**
            Get executioner
            
            Returns:
                DefferredExecutioner
            **/
            DefferredExecutioner executioner() @safe nothrow pure;
        }
    }
}

/**
A property configurer, has the purpose to modify data of type T according to some logic encapsulated in it.

**/
interface PropertyConfigurer(T) : LocatorAware!() {
    
    public {
        
        /**
        Accepts a reference to an object that is to be configured by the configurer.
        
        Params:
        	object = An object of type T, that will be configured
        **/
        void configure(ref T object);
    }
}

/**
An instance factory, instantiates data of type T.
**/
interface InstanceFactory(T) : LocatorAware!() {
    
    public {
        
        /**
        Create a new instance of object of type T.
        
        Returns:
            T instantiated component
        **/
        T factory();
    }
}

/**
Interface for objects that are aware of an instance factory
and can use it to instantiate a component.
**/
interface InstanceFactoryAware(T) {
    public {
        
        @property {
        	/**
            Sets the constructor of new object.
            
            Params:
            	factory = a factory of objects of type T.
        	
        	Returns:
    			The InstanceFactoryAware
            **/
            InstanceFactoryAware!T setInstanceFactory(InstanceFactory!T factory);
        }
    }
}

/**
Interface for objects that are aware of a set of property configurers
and can use them to configure some component.
**/
interface PropertyConfigurersAware(T) {
    public {
        /**
        Adds an configurer to the PropertyConfigurersAware.
        
        Params:
        	configurer = a configurer that will be invoked after factory of an object.
        	
    	Returns:
    		The PropertyConfigurersAware instance
        **/
        PropertyConfigurersAware!T addPropertyConfigurer(PropertyConfigurer!T configurer);
    }
}
/**
A generic factory, is a factory that instantiates data of type T using InstanceFactory and a list of PropertyConfigurers.

A generic factory, is a factory that instantiates data of type T using InstanceFactory and a list of PropertyConfigurers.
It can optionally provide a Locator!() object to InstanceFactory and PropertyConfigurer to be used as a source of data. 
**/
interface GenericFactory(T) : Factory!T, InstanceFactoryAware!T, PropertyConfigurersAware!T {
    
    public {
        
        @property {
            
            alias locator = Factory!T.locator;
            
            /**
            Get the GenericFactory locator.
            
            Returns:
            	Locator!() the locator that should be used by underlying constructor or property configurer.
            **/
            Locator!() locator();
        }
    }
}

/**
A concrete implementation of GenericFactory interface.
**/
class GenericFactoryImpl(T) : GenericFactory!T, LocatorAware!(), DefferredExecutionerAware {
    
    private {
        Locator!() locator_;
        
        InstanceFactory!T factory_;
        
        PropertyConfigurer!T[] configurers;

        DefferredExecutioner executioner_;
    }
    
    public {
        
        /**
            Constructor for GenericFactoryImpl
            
            Params:
                locator = the locator used by constructor to fetch dependencies of the created object
        **/
        this(Locator!() locator) {
            this.locator = locator;
            
            static if (hasDefaultCtor!T) {
                
                this.setInstanceFactory(
                    new DefaultConstructorBasedFactory!T
                );
            }
        }
        
        /**
        Create a new instance of object of type T using provided instance factory and property configurers.
        
        Returns:
            T instantiated component
        **/
        T factory() {
            T instance;
            
            if (this.factory_ !is null) {
                instance = this.factory_.factory;
            } else {
                
                throw new AediException("Failed to construct object due to no constructor");
            }

            foreach (key, configurer; this.configurers) {

                try {

                    configurer.configure(instance);
                } catch (AediException exception) {

                    if (this.executioner !is null) {

                        Throwable current = exception;

                        while (current !is null) {
                            CircularReferenceException e = cast(CircularReferenceException) current;

                            if (e !is null) {
                                this.executioner.add(() {
                                    configurer.configure(instance);
                                });

                                break;
                            }

                            current = current.next;
                        }

                        if (current is null) {
                            throw exception;
                        }
                    } else {

                        throw exception;
                    }
                }
            }
            
            return instance;
        }
        
        @property {

            /**
            Set executioner
            
            Params: 
                executioner = executioner used to deffer configurations at later time
            
            Returns:
                typeof(this)
            **/
            typeof(this) executioner(DefferredExecutioner executioner) @safe nothrow pure {
                this.executioner_ = executioner;
            
                return this;
            }
            
            /**
            Get executioner
            
            Returns:
                DefferredExecutioner
            **/
            DefferredExecutioner executioner() @safe nothrow pure {
                return this.executioner_;
            }
            
            /**
            Sets the constructor of new object.
            
            Params:
            	factory = a factory of objects of type T.
        	
        	Returns:
    			The InstanceFactoryAware
            **/
            GenericFactory!T setInstanceFactory(InstanceFactory!T factory) {
                this.factory_ = factory;
                
                return this;
            }
            
            /**
                Set locator
                
                Params: 
                    locator = the locator used to fetch created's object dependencies
                Returns:
                    typeof(this)
            **/
            GenericFactory!T locator(Locator!() locator) {
                this.locator_ = locator;

                if (this.factory_ !is null) {

                    this.factory_.locator = locator;
                }
                
                foreach (configurer; this.configurers) {
                    configurer.locator = locator;
                }

                return this;
            }
            
            /**
                Get locator
                
                Returns:
                    Locator!()
            **/
            Locator!() locator() {
                return this.locator_;
            }
            
            /**
    		Get the type info of object that is created.
    		
    		Returns:
    			TypeInfo object of created object.
    		**/
    		TypeInfo type() {
    		    return typeid(T);
    		}
        }
        
        /**
        Adds an configurer to the PropertyConfigurersAware.
        
        Params:
        	configurer = a configurer that will be invoked after factory of an object.
        	
    	Returns:
    		The PropertyConfigurersAware instance
        **/
        GenericFactory!T addPropertyConfigurer(PropertyConfigurer!T configurer) {
            
            this.configurers ~= configurer;
            
            return this;
        }
    }
    
}

/**
ditto
**/
GenericFactory!T genericFactory(T)(Locator!() locator) {
    return new GenericFactoryImpl!T(locator);
}


/**
Standard implementation of DefferredExecutioner interface.
**/
class DefferredExecutionerImpl : DefferredExecutioner {

    private {
        void delegate()[] deffered;
    }

    public {

        /**
        Add a new defferred action to be executed
        
        Params: 
            dg = the deffered action to execute
            
        Returns:
            typeof(this)
        **/
        DefferredExecutioner add(void delegate() dg) {
            this.deffered ~= dg;

            return this;
        }

        /**
        Add a set of defferred actions to be executed
        
        Params: 
            dgs = list of defferred actions
        
        Returns:
            typeof(this)
        **/
        DefferredExecutioner add(void delegate()[] dgs) {
            this.deffered ~= dgs;

            return this;
        }

        /**
        Execute defferred actions
        
        Returns:
            typeof(this)
        **/
        DefferredExecutioner execute() {
            foreach (dg; this.deffered) {
                dg();
            }

            this.deffered = null;

            return this;
        }
    }
}

/**
Default implementation of locator aware used in generic factory module.
**/
abstract class LocatorHolder : LocatorAware!() {

    private {
        Locator!() locator_;        
    }

    public {
        @property {
            /**
    		Sets the locator that will be used by configurer to fetch object referenced in argument list.
    		
    		Params:
    			locator = the (service) locator that will be used to fetch required objects.
    		
    		Returns:
    			The ParameterHolder instance.
    		**/
            LocatorHolder locator(Locator!() locator)  {
            	this.locator_ = locator;
            
            	return this;
            }
            
            /**
                Get locator
                
                Returns:
                    Locator!()
            **/
            Locator!() locator() @safe nothrow {
            	return this.locator_;
            }
        }
    }
}

/**
ParameterHolder Stores a set of Args for futher usage in it's subclasses.

Params:
    Args = a type tuple of args that ParameterHolder can hold.
**/
abstract class ParameterHolder(Args...) : LocatorHolder {
    
    protected {
        Tuple!Args args_;
    }
    
    public {
        
        static if (Args.length > 0) {

            /**
                Set args
                
                Params: 
                    args = arguments that parameter holder should hold.
                Returns:
                    typeof(this)
            **/ 
            ParameterHolder args(ref Args args) @safe nothrow {
            	this.args_ = tuple(args);
            
            	return this;
            }
        }
        
        /**
            Get args
            
            Returns:
                Tuple!Args arguments stored by argument holder
        **/
        Tuple!Args args() @safe nothrow {
        	return this.args_;
        } 
    
    }
}

/**
Calls aggregate's method with a set of arguments.

Encapsulates a call to aggregate's method, with a set of arguments.
The algorithm that calls aggregate's method, will automatically replace
references from args list with data extracted from container, casted to 
type that is extracted from method's signature.

Params:
    T = the aggregate type
    property = method that will be called
    Args = type tuple of args that method can be called with.
**/
class MethodConfigurer(T, string property, Args...) : ParameterHolder!Args, PropertyConfigurer!T
	if (
	    isMethodCompatible!(T, property, Args)
    ) {
    
    public {
        
        /**
            Constructor for MethodConfigurer!(T, property, Args)
            
            Params: 
                args = list of arguments passed to T's method
        **/
        this(ref Args args) {
            this.args(args);
        }
        
        /**
        See PropertyConfigurer interface
        
        Throws:
            InvalidCastException when extracted data by reference, is not of type expected by argument
            of aggregate's method
        **/
        void configure(ref T obj) {
            
            try {
                
                alias ArgTuple = Parameters!(
                    Filter!(
                        partialSuffixed!(
                            isArgumentListCompatible, 
                            Args
                        ), 
                        getOverloads!(
                            T, 
                            property
                        )
                    )[0]
                );
                
                mixin(q{__traits(getMember, obj, property)(} ~ compileArgumentsTuple!ArgTuple(q{ArgTuple}, q{this.args}, q{this.locator}) ~ q{);});

            } catch (Exception e) {
                throw new PropertyConfigurerException("Error occurred during call of " ~ name!T ~ "." ~ property, e);
            }
        }
    }
}
    
/**
ditto
**/
auto methodConfigurer(string property, T, Args...)(Locator!() locator, auto ref Args args) 
    if (!isField!(T, property)) {
    mixin assertObjectMethodCompatible!(T, property, Args);
    
    auto propertySetter = new MethodConfigurer!(T, property, Args)(args);
    propertySetter.locator = locator;
    
    return propertySetter;
}

/**
Sets aggregate's field to a value.

Encapsulates logic that sets aggregates field to a certain value.
If argument that is contained by configurer is a reference, it will be automatically
replaced with value extracted from locator, and set to aggregate's field.
**/
class FieldConfigurer(T, string property, Arg) : ParameterHolder!Arg, PropertyConfigurer!T
	if (
	    isFieldCompatible!(T, property, Arg)
    ) {
    
    public {
        /**
            Constructor for MethodConfigurer!(T, property, Args)
            
            Params: 
                arg = list of arguments passed to T's method
        **/
        this(ref Arg arg) {
            this.args(arg);
        }
        
        /**
        See PropertyConfigurer interface
        
        Throws:
            InvalidCastException when extracted data by reference, is not of type expected by argument
            of aggregate's field
        **/
        void configure(ref T obj) {
            
            try {
            
                __traits(getMember, obj, property) = args[0].resolve!(
                    typeof(__traits(getMember, obj, property))
                )(
                    this.locator
                );
            } catch (Exception e) {
                
                throw new PropertyConfigurerException("Error occurred during set of " ~ name!T ~ "." ~ property, e);
            }
        }
    }
}
    
/**
ditto
**/
auto fieldConfigurer(string property, T, Arg)(Locator!() locator, auto ref Arg arg)
    if (isField!(T, property)) {
    mixin assertFieldCompatible!(T, property, Arg);
    
    auto propertySetter = new FieldConfigurer!(T, property, Arg)(arg);
    propertySetter.locator = locator;
    
    return propertySetter;
}

/**
Instantiates an aggregate using it's constructor with no arguments.
**/
class DefaultConstructorBasedFactory(T) : LocatorHolder, InstanceFactory!T 
    if (
        hasDefaultCtor!T
    ) {
    
    public {
        /**
        Create a new instance of object of type T.
        
        Returns:
            T instantiated component
        **/
        T factory() {
            
            try {
                static if (is(T : Object)) {
                    return new T();
                } else {
                    return T.init;
                }
            } catch (Exception e) {
                throw new InstanceFactoryException("Error occurred during instantiation of " ~ name!T, e);
            }
        }
    }
}
    
/**
Instantiates aggregate using it's constructor with args.

Encapsulates construction of aggregate using a constructor, with args.
Arguments from argument list that are references, are automatically 
replaced with data extracted from locator.

Params:
    T = aggregate type
    Args = type tuple of args that are passed to T's constructor
**/
class ConstructorBasedFactory(T, Args...) : ParameterHolder!Args, InstanceFactory!T
	if (
	    isObjectConstructorCompatible!(T, Args)
	) {
    
    public {
        /**
            Constructor for ConstructorBasedFactory!(T, Args)
            
            Params: 
                args = arguments used for constructor
        **/
        this(ref Args args) {
            this.args(args);
        }
        
        /**
        See InstanceFactory interface
        
        Throws:
            InvalidCastException when extracted data by reference, is not of type expected by argument
            of aggregate's constructor
        **/
        T factory() {
            
            try {
                
                alias ConstructorArgs = Parameters!(
                    Filter!(
                        partialSuffixed!(
                            isArgumentListCompatible,
                            Args
                        ), 
                        __traits(getOverloads, T, "__ctor")
                    )[0]
                );

                static if (is(T : Object)) {
                    mixin(q{return new T(} ~ compileArgumentsTuple!ConstructorArgs(q{ConstructorArgs}, q{this.args}, q{this.locator}) ~ q{);});
                } else {
                    mixin(q{return T(} ~ compileArgumentsTuple!ConstructorArgs(q{ConstructorArgs}, q{this.args}, q{this.locator}) ~ q{);});
                }
            } catch (Exception e) {
                
                throw new InstanceFactoryException("Error occurred during instantiation of " ~ name!T, e);
            }
        }
    }
}
	
/**
ditto
**/
auto constructorBasedFactory(T, Args...)(Locator!() locator, auto ref Args args) {
    mixin assertObjectConstructorCompatible!(T, Args);
    auto constructor = new ConstructorBasedFactory!(T, Args)(args);
    
    constructor.locator = locator;
    
    return constructor;
}
	
/**
Instantiates an aggregate using a method from other aggregate (factory method pattern).

Encapsulates construction of aggregate using factory method.
Arguments that are references, will be replaced with data extracted
from locator, and passed to factory's method.
In case when method is not static member, the algorithm will use 
an instantiaton of factory passed to it, or extracted from locator
if a reference is passed.

Params:
    T = factory that is used to instantiate aggregate using it's method
    method = the name of method used to instantiate aggregate
    W = the factory T, or a LocatorReference to the factory.
    Args = type tuple of arguments passed to factory.
**/
class FactoryMethodBasedFactory(T, string method, W, Args...) : 
    ParameterHolder!Args, 
    InstanceFactory!(ReturnType!(getCompatibleOverload!(T, method, Args)))
    if (
        (is(W : RuntimeReference) || is(W : T)) &&
        isMethodCompatible!(T, method, Args) &&
        isAggregateType!(ReturnType!(getCompatibleOverload!(T, method, Args)))
    ) {
        
    static if (!__traits(isStaticFunction, getCompatibleOverload!(T, method, Args))) {
        
        private {
            W fact;
        }
        
        public {
            /**
                Constructor for FactoryMethodBasedFactory!(T, method, W, Args)
                
                Params: 
                    fact = factory used to create object
                    args = arguments passed to factory's method
            **/
            this(ref W fact, ref Args args) {
                this.args(args);
                this.fact = fact;
            }
        }
    } else {
        
        /**
            Constructor for FactoryMethodBasedFactory!(T, method, W, Args)
            
            Params: 
                args = arguments passed to factory's static method
        **/
        this(ref Args args) {
            this.args(args);
        }
    }
        
    private {
        
        alias Z = ReturnType!(getCompatibleOverload!(T, method, Args));
    }
    
    public {
        /**
        See InstanceFactory interface
        
        Throws:
            InvalidCastException when extracted data by reference, is not of type expected by argument
            factory's method, or when factory is referenced, and the object referenced in locator is not
            of factory's type T.
        Returns:
            Z created object
        **/
        Z factory() {
            
            try {
                
                alias FactoryMethodParameters = Parameters!(
                    Filter!(
                        partialSuffixed!(
                            isArgumentListCompatible, 
                            Args
                        ), __traits(
                            getOverloads, 
                            T, 
                            method
                        )
                    )[0]
                );
                
                static if (!__traits(isStaticFunction, getCompatibleOverload!(T, method, Args))) {
    
                    mixin(
                        q{return __traits(getMember, this.fact.resolve!(T)(this.locator), method)(} ~ 
                        compileArgumentsTuple!FactoryMethodParameters(q{FactoryMethodParameters}, q{this.args}, q{this.locator}) ~ 
                        q{);}
                        );
                } else {
    
                    mixin(
                        q{return __traits(getMember, T, method)(} ~ 
                        compileArgumentsTuple!FactoryMethodParameters(q{FactoryMethodParameters}, q{this.args}, q{this.locator}) ~ 
                        q{);}
                        );
                }
            } catch (Exception e) {
                
                throw new InstanceFactoryException(
                    "Error occurred during instantiation of " ~ 
                    name!T ~ 
                    " using factory method of " 
                    ~ name!T ~ 
                    "." ~ 
                    method, 
                    e
                );
            }
        }
    }
}
    
/**
ditto
**/
auto factoryMethodBasedFactory
        (T, string method, W, Args...)
        (Locator!() locator, auto ref W factoryMethod, auto ref Args args)
    if (
        isNonStaticMethodCompatible!(T, method, Args) &&
        (is(W : T) || is(W : RuntimeReference))
    ) {
        
    auto constructor = new FactoryMethodBasedFactory!(T, method, W, Args)(factoryMethod, args);
    
    constructor.locator = locator;
    
    return constructor;
}

/**
ditto
**/
auto factoryMethodBasedFactory(T, string method, Args...)(Locator!() locator, auto ref Args args)
    if (
        isStaticMethodCompatible!(T, method, Args)
    ) {
    auto constructor = new FactoryMethodBasedFactory!(T, method, T, Args)(args);
    
    constructor.locator = locator;
    
    return constructor;
}
    
/**
Instantiates data of type T using a delegate or function.

Encapsulates data's construction logic using a delegate.
The algorithm uses a delegate to create required data, 
with a set of Args that are passed to delegate, and a locator
for dependency fetching. 

Params:
    T = the constructed aggregate
    Args = type tuple of arguments passed to delegate for aggregate's construction. 
**/
class CallbackFactory(T, Dg, Args...) : ParameterHolder!Args, InstanceFactory!T
    if ((is(Dg == T delegate (Locator!(), Args)) || is(Dg == T function (Locator!(), Args)))) {
    
    private {
        Dg dg;
    }
    
    public {
        /**
            Constructor for CallbackFactory!(T, Dg, Args)
            
            Params: 
                dg = delegate used to create object
                args = arguments passed to delegate
        **/
        this(Dg dg, ref Args args) {
            this.dg = dg;
            this.args(args);
        }
        
        /**
        See InstanceFactory interface
        **/
        T factory() {
            try {
                
                return this.dg(this.locator_, args.expand);
            } catch (Exception e) {
                
                throw new InstanceFactoryException(
                    "Error occurred during instantiation of " ~ 
                    name!T ~ 
                    " using callback factory", 
                    e
                );
            }
        }
    }
}
    
/**
ditto
**/
auto callbackFactory(T, Args...)(Locator!() locator, T delegate(Locator!(), Args) dg, auto ref Args args) {
    auto constr = new CallbackFactory!(T, T delegate(Locator!(), Args), Args)(dg, args);
    constr.locator = locator;
    return constr;
}
    
/**
ditto
**/
auto callbackFactory(T, Args...)(Locator!() locator, T function(Locator!(), Args) dg, auto ref Args args) {
    auto constr = new CallbackFactory!(T, T function(Locator!(), Args), Args)(dg, args);
    constr.locator = locator;
    return constr;
}

/**
Configures/modifies data of type T with help of a delegate or function.

Encapsulates data configuration logic using a delegate.
The algorithm calls delegate, with a locator, a set of Args,
and configured data, in order to modify the data
somehow.

Note:
    If data is not a reference type it is recommended to pass it by reference
    in order to avoid receiving of a copy and not original one in delegate.
Params:
    T = the aggregate
    Args = type tuple of arguments used by delegate for customization.
**/
class CallbackConfigurer(T, Dg, Args...) : ParameterHolder!Args, PropertyConfigurer!T 
    if (
        is(Dg == void delegate (Locator!(), T, Args)) || 
        is(Dg == void function (Locator!(), T, Args)) ||
        is(Dg == void delegate (Locator!(), ref T, Args)) || 
        is(Dg == void function (Locator!(), ref T, Args))
    ) {
    
    private {
        Dg dg;
    }
    
    public {
        /**
            Constructor for CallbackConfigurer!(T, Dg, Args)
            
            Params: 
                dg = delegate used to configure the created object
                args = arguments passed to delegate
        **/
        this(Dg dg, ref Args args) {
            this.dg = dg;
            this.args(args);
        }
        
        /**
        Accepts a reference to an object that is to be configured by the configurer.
        
        Params:
        	object = An object of type T, that will be configured
        **/
        void configure(ref T object) {
            
            try {
            
                return this.dg(this.locator_, object, args.expand);
            } catch (Exception e) {
            	throw new PropertyConfigurerException("Error occurred during callback configuration of " ~ name!T, e);
            }
        }
    }
}
    
/**
ditto
**/
auto callbackConfigurer(T, Args...)(Locator!() locator, void delegate(Locator!(), T, Args) dg, auto ref Args args) {
    auto constr = new CallbackConfigurer!(T, void delegate(Locator!(), T, Args), Args)(dg, args);
    constr.locator = locator;
    return constr;
}
    
/**
ditto
**/
auto callbackConfigurer(T, Args...)(Locator!() locator, void function(Locator!(), T, Args) dg, auto ref Args args) {
    auto constr = new CallbackConfigurer!(T, void function(Locator!(), T, Args), Args)(dg, args);
    constr.locator = locator;
    return constr;
}

/**
ditto
**/
auto callbackConfigurer(T, Args...)(Locator!() locator, void delegate(Locator!(), ref T, Args) dg, auto ref Args args) {
    auto constr = new CallbackConfigurer!(T, void delegate(Locator!(), ref T, Args), Args)(dg, args);
    constr.locator = locator;
    return constr;
}
    
/**
ditto
**/
auto callbackConfigurer(T, Args...)(Locator!() locator, void function(Locator!(), ref T, Args) dg, auto ref Args args) {
    auto constr = new CallbackConfigurer!(T, void function(Locator!(), ref T, Args), Args)(dg, args);
    constr.locator = locator;
    return constr;
}


/**
Instantiates a component using a value as basis.

Instantiates a component using a value as basis.
As a consequence, any reference based type will 
point to same content when it is instantiated 
multiple times. 
**/
class ValueInstanceFactory(T) : LocatorHolder, InstanceFactory!T {
    private {
        T initial_;
    }
    
    public {
        /**
            Constructor for ValueInstanceFactory!T
            
            Params: 
                initial = argument that is to be passed as created object
        **/
        this(T initial) {
            this.initial = initial;
        }
        
        @property {

            /**
                Set initial
                
                Params: 
                    initial = value which will be passed as created component
                Returns:
                    typeof(this)
            **/
        	ValueInstanceFactory!T initial(T initial) @safe nothrow {
        		this.initial_ = initial;
        	
        		return this;
        	}
        	
            /**
                Get initial
                
                Returns:
                    T
            **/
        	T initial() @safe nothrow {
        		return this.initial_;
        	}
        }
        
        /**
        Create a new instance of object of type T.
        
        Returns:
            T instantiated component
        **/
        T factory() {
            return this.initial();
        }
    }
}

/**
InstanceFactory that delegates the task of instantiating a component
to some third party factory.
**/
class DelegatingInstanceFactory(T, X : T) : LocatorHolder, InstanceFactory!T, MutableDecorator!(Factory!X) {
    
    private {
        Factory!X decorated_;
    }
    
    public {
        
        /**
            Default constructor for DelegatingInstanceFactory!(T, X)
        **/
        this() {
            
        }
        
        /**
            Constructor for DelegatingInstanceFactory!(T, X)
            
            Params: 
                factory = the factory to which this instance will delegate the task of creating a component
        **/
        this(Factory!X factory) {
            this.decorated = factory;
        }
        
        @property {
            /**
            Set the decorated object for decorator.
            
            Params:
                decorated = decorated data
            
            Returns:
            	this
            **/
        	DelegatingInstanceFactory!(T, X) decorated(Factory!X decorated) @safe nothrow {
        		this.decorated_ = decorated;
        	
        		return this;
        	}
        	
        	/**
            Get the decorated object.
            
            Returns:
            	T decorated object
            **/
        	Factory!X decorated() @safe nothrow {
        		return this.decorated_;
        	}
        }
        
        /**
        Create a new instance of object of type T.
        
        Returns:
            T instantiated component
        **/
        T factory() {
            return this.decorated.factory();
        }
    }
}

/**
An check if the argument list passed to ConstructorBasedFactory or MethodConfigurer is compatible with signature of underlying
method or constructor.

Note:
	For now it checks if the lengths are equal. For future it should also check if types are compatible.
**/
template isArgumentListCompatible(alias func, ArgTuple...) 
	if (isSomeFunction!func) {
    bool isArgumentListCompatible() {
        alias FuncParams = Parameters!func;
        alias Required = Filter!(partialSuffixed!(isValueOfType, void), ParameterDefaults!func);
       
        static if ((ArgTuple.length < Required.length) || (ArgTuple.length > FuncParams.length)) {
          
            return false;
        } else {
            
            bool result = true;
            foreach (index, Argument; ArgTuple) {
          
                static if (!is(Argument : RuntimeReference) && !isImplicitlyConvertible!(Argument, FuncParams[index])) {
          
                    result = false;
                    break;
                } 
            }
            
            return result;
        }
    }
}
	
mixin template assertFieldCompatible(T, string field, Arg) {
    import aermicioi.util.traits;
    import std.traits;
    import std.meta;
    
    static assert(isField!(T, field), name!T ~ "'s " ~ field ~ " member is not a field");
    static assert(isProtection!(T, field, "public"), name!T ~ "'s " ~ field ~ " is not public and therefore cannot be accessed.");
    static assert(is(Arg : RuntimeReference) ? true : isImplicitlyConvertible!(Arg, typeof(getMember!(T, field))), name!T ~"'s " ~ field ~ " type " ~ name!(typeof(getMember!(T, field))) ~ " doesn't match with passed arguments type " ~ name!Arg);
}

enum bool isFieldCompatible(T, string field, Arg) = 
    isField!(T, field) &&
    isProtection!(T, field, "public") &&
    is(Arg : RuntimeReference) ? true : isImplicitlyConvertible!(Arg, typeof(getMember!(T, field)));

mixin template assertObjectConstructorCompatible(T, Args...) {
    import aermicioi.util.traits;
    import std.traits;
    import std.meta;
    
    static assert(hasMember!(T, "__ctor"), name!T ~ " doesn't have any constructor to call.");
    static assert(isProtection!(T, "__ctor", "public"), name!T ~ "'s constructor is not public.");
    static assert(isSomeFunction!(__traits(getMember, T, "__ctor")), name!T ~ "'s constructor is not a function, probably a template.");
    static assert(variadicFunctionStyle!(__traits(getMember, T, "__ctor")) == Variadic.no, name!T ~ "'s constructor is a variadic function. Only non-variadic constructors are supported.");
    static assert(Filter!(partialSuffixed!(isArgumentListCompatible, Args), __traits(getOverloads, T, "__ctor")).length == 1, "None, or multiple overloads found for " ~ name!T ~ "'s constructor with passed arguments.");
}

enum bool isObjectConstructorCompatible(T, Args...) = isMethodCompatible!(T, "__ctor", Args);

mixin template assertObjectMethodCompatible(T, string method, Args...) {
    import std.range : only;
    import std.array : array;
    import aermicioi.util.traits;
    import std.traits;
    import std.meta;
    
    static assert(hasMember!(T, method), name!T ~ "'s method " ~ method ~ " not found.");
    static assert(isProtection!(T, method, "public"), name!T ~ "'s method " ~ method ~ " is not public");
    static assert(isSomeFunction!(__traits(getMember, T, method)), name!T ~ "'s member " ~ method ~ " is not a function, probably a field, or a template.");
    static assert(variadicFunctionStyle!(__traits(getMember, T, method)) == Variadic.no, name!T ~ "'s method " ~ method ~ "is variadic function. Only non-variadic methods are supported.");
    static assert(Filter!(partialSuffixed!(isArgumentListCompatible, Args), getOverloads!(T, method)).length == 1, name!T ~ "'s " ~ method ~ " doesn't have overload matching passed arguments (" ~ only(staticMap!(name, Args)).joiner(", ").array ~ "), or has several overloads that match.");
}

enum bool isObjectMethodCompatible(T, string method, Args...) = isMethodCompatible!(T, method, Args);


template isMethodCompatible(T, string method, Args...) {
    enum bool isMethodCompatible = 
            hasMember!(T, method) &&
            isProtection!(T, method, "public") &&
            isSomeFunction!(__traits(getMember, T, method)) &&
            (variadicFunctionStyle!(__traits(getMember, T, method)) == Variadic.no) &&
            (Filter!(partialSuffixed!(isArgumentListCompatible, Args), getOverloads!(T, method)).length == 1);
}

template getCompatibleOverload(T, string method, Args...)
    if (isObjectMethodCompatible!(T, method, Args)) {
    
    alias getCompatibleOverload = Filter!(partialSuffixed!(isArgumentListCompatible, Args), getOverloads!(T, method))[0];
}

alias isStaticMethodCompatible = templateAnd!(
    isMethodCompatible, 
    chain!(
        isStaticFunction, 
        getCompatibleOverload
    )
);

alias isNonStaticMethodCompatible = templateAnd!(
    isMethodCompatible, 
    chain!(
        templateNot!isStaticFunction, 
        getCompatibleOverload
    )
);

alias isNonStaticMethodCompatibleAndReturnTypeOf(X) = templateAnd!(
    isMethodCompatible, 
    chain!(
        templateNot!isStaticFunction, 
        getCompatibleOverload
    ),
    partialSuffixed!(
        chain!(
            partialPrefixed!(
                get,
                0
            ),
            getCompatibleOverload
        ),
        X
    )
);

private {
    template isValueOfType(alias value, Type) {
        enum bool isValueOfType = is(typeof(value) == Type);
    }
    
    template isValueOfType(Value, Type) {
        enum bool isValueOfType = is(Value == Type);
    }
    
    enum bool isStruct(T) = is(T == struct);
    
    alias hasDefaultCtor = 
        partialSuffixed!(
            templateOr!(
                templateNot!hasMember,
                chain!(
                    isStruct,
                    get!0
                ),
                templateAnd!(
                    partialSuffixed!(
                        isProtection,
                        "public"
                    ),
                    chain!(
                        partialPrefixed!(
                            anySatisfy,
                            eq!0
                        ),
                        partialPrefixed!(
                            staticMap,
                            arity
                        ),
                        chain!(
                            partialPrefixed!(
                                Filter,
                                partialSuffixed!(
                                    isProtection,
                                    "public"
                                )
                            ),
                            getOverloads
                        )
                    )
                )
            ),
            "__ctor"
        );
}	

private {
    string compileArgumentsTuple(Tuple...)(string types, string array, string locator) {
        import std.conv : to;
        import std.array : join;
        string[] stmt;

        foreach (index, Type; Tuple) {
            stmt ~= array ~ "[" ~ index.to!string ~ "].resolve!(" ~ types ~ "[" ~ index.to!string ~ "])(" ~ locator ~ ")";
        }

        return stmt.join(", ");
    }
}