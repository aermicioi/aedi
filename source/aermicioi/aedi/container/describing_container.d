/**
License:
	Boost Software License - Version 1.0 - August 17th, 2003

	Permission is hereby granted, free of charge, to any person or organization
	obtaining a copy of the software and accompanying documentation covered by
	this license (the "Software") to use, reproduce, display, distribute,
	execute, and transmit the Software, and to prepare derivative works of the
	Software, and to permit third-parties to whom the Software is furnished to
	do so, all subject to the following:

	The copyright notices in the Software and this entire statement, including
	the above license grant, this restriction and the following disclaimer,
	must be included in all copies of the Software, in whole or in part, and
	all derivative works of the Software, unless such copies or derivative
	works are solely in the form of machine-executable object code generated by
	a source language processor.

	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
	SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
	FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
	ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
	DEALINGS IN THE SOFTWARE.

Authors:
	aermicioi
**/
module aermicioi.aedi.container.describing_container;

import aermicioi.aedi.container.container;
import aermicioi.aedi.container.decorating_mixin;
import aermicioi.aedi.storage.object_storage;
import aermicioi.aedi.storage.decorator;
import aermicioi.aedi.storage.alias_aware;
import aermicioi.aedi.storage.storage;
import aermicioi.aedi.factory.factory;
import aermicioi.aedi.exception.not_found_exception;
import aermicioi.aedi.util.traits;
import std.meta;
import std.traits;

import std.range.interfaces;

/**
Description of a component.
**/
@safe struct Description(IdentityType) {

    /**
    Identity of component
    **/
    const IdentityType identity;

    /**
    Title of component
    **/
    string title;

    /**
    Exhaustive description of component
    **/
    string description;

    /**
    Assign a description to this description.

    Params:
        description = description to be assigned.
    **/
    void opAssign(ref Description description)
    in (this.identity == description.identity) {
        this.title = description.title;
        this.description = description.description;
    }

    /**
    ditto
    **/
    void opAssign(Description description)
    in (this.identity == description.identity) {
        this = description;
    }
}

/**
Provides a set of descriptions used for help information.
**/
@safe interface DescriptionsProvider(IdentityType) {

    /**
    Provide a list of descriptions for usage.

    Returns:
        A list of descriptions.
    **/
    const(Description!IdentityType)[] provide() const @safe;
}

/**
Interface for component that is able to provide description for passed components.
**/
@safe interface Describer(ComponentType = Object, IdentityType = string) {
    import aermicioi.aedi.util.typecons : Optional, optional;

    public {

        /**
        Describe a component based on it's identity and itself.

        Params:
            identity = identity of component being described
            component = component that is described
        Returns:
            A description or empty if it is not describable by this describer
        **/
        Optional!(const(Description!IdentityType)) describe(const ref IdentityType identity, const ref ComponentType component) @safe const;

        /**
        ditto
        **/
        final Optional!(const(Description!IdentityType)) describe(const IdentityType identity, const ComponentType component) @safe const {
            return this.describe(identity, component);
        }
    }
}

/**
Describer that stores a list of descriptions based on identity, based on which it is describing passed components.
**/
@safe class IdentityDescriber(ComponentType = Object, IdentityType = string) : Describer!(ComponentType, IdentityType), DescriptionsProvider!IdentityType {
    import aermicioi.aedi.util.typecons : Optional, optional;

    private {
        Description!IdentityType[] descriptions;
    }

    public {

        /**
        Register a description in describer.

        Params:
            description = description registered in describer.
        Returns:
            typeof(this)
        **/
        typeof(this) register(Description!IdentityType description) @safe nothrow pure {
            import std.algorithm.searching : countUntil;

            ptrdiff_t index = descriptions.countUntil!(d => d.identity == description.identity);

            if (index > -1) {
                descriptions[index] = description;

                return this;
            }

            descriptions ~= description;

            return this;
        }

        /**
        Register a description in describer.

        Params:
            identity = identity of component for which description is registered
            title = title of description
            description = description itself
        Returns:
            typeof(this)
        **/
        typeof(this) register(IdentityType identity, string title, string description) @safe nothrow pure {
            return this.register(Description!IdentityType(identity, title, description));
        }

        /**
        Remove a description from decriber

        Params:
            identity = identity of component for which to remove description
        Returns:
            typeof(this)
        **/
        typeof(this) remove(IdentityType identity) {
            import std.algorithm.mutation : remove;
            this.descriptions = this.descriptions.remove!(d => d.identity == identity);

            return this;
        }

        /**
        Describe a component based on it's identity and itself.

        Params:
            identity = identity of component being described
            component = component that is described
        Returns:
            A description or empty if it is not describable by this describer
        **/
        Optional!(const(Description!IdentityType)) describe(const ref IdentityType identity, const ref ComponentType component) @safe const {
            import std.algorithm.searching : countUntil;

            ptrdiff_t index = this.descriptions.countUntil!(d => d.identity == identity);

            if (index > -1) {
                return this.descriptions[index].optional;
            }

            return Optional!(const(Description!IdentityType))();
        }

        /**
        ditto
        **/
        alias describe = Describer!(ComponentType, IdentityType).describe;

        /**
        Provide a list of descriptions for usage.

        Returns:
            A list of descriptions.
        **/
        const(Description!IdentityType)[] provide() const @safe {
            return this.descriptions;
        }
    }
}

/**
Describer that creates descriptions on the fly based on passed identity and component.
**/
@safe class TypeDescriber(ComponentType = Object, IdentityType = string) : Describer!(ComponentType, IdentityType) {
    import aermicioi.aedi.util.typecons : Optional, optional;

    private {
        string title;
        string description;
        string delegate(const ref IdentityType) @safe pure identityFormatter;
        string delegate(const ref ComponentType) @safe pure componentFormatter;
    }

    public {

        /**
        Constructor with custom title and description template

        This describer will replace ${identity} with formatted identity and
        ${component} with formatted component in title and description using
        identityFormatter and componentFormatter for formatting.

        Params:
            title = title template used to generate description title
            description = description template used to generate description itself
            identityFormatter = formatter that produces a readable string out of passed component identity
            componentFormatter = formatter that produces a readable string out of passed component
        **/
        this(
            string title,
            string description,
            string delegate(const ref IdentityType identity) @safe pure identityFormatter,
            string delegate(const ref ComponentType component) @safe pure componentFormatter
        ) {
            this.title = title;
            this.description = description;
            this.identityFormatter = identityFormatter;
            this.componentFormatter = componentFormatter;
        }

        /**
        ditto
        **/
        this(
            string title,
            string description
        ) {
            import std.conv : text;
            this(
                title,
                description,
                (const ref IdentityType identity) => text(identity),
                (const ref ComponentType component) => typeid(ComponentType).toString
            );
        }

        /**
        ditto
        **/
        this() {
            this(
                "${identity}",
                "${identity} typeof ${component}"
            );
        }

        /**
        Describe a component based on it's identity and itself using generic identity and type formatter in title and description templates.

        Params:
            identity = identity of component being described
            component = component that is described
        Returns:
            A description or empty if it is not describable by this describer
        **/
        Optional!(const(Description!IdentityType)) describe(const ref IdentityType identity, const ref ComponentType component) const @safe {
            import std.algorithm.iteration : substitute;
            import std.array : array;
            import std.utf : byChar;

            return (cast(const) Description!IdentityType(
                identity,
                title.substitute("${identity}", identityFormatter(identity), "${component}", componentFormatter(component)).byChar.array.idup,
                description.substitute("${identity}", identityFormatter(identity), "${component}", componentFormatter(component)).byChar.array.idup,
            )).optional;
        }

        /**
        ditto
        **/
        alias describe = Describer!(ComponentType, IdentityType).describe;
    }
}

/**
A describer that provides same description for any component
**/
@safe class StaticDescriber(ComponentType = Object, IdentityType = string) : Describer!(ComponentType, IdentityType) {
    import aermicioi.aedi.util.typecons : Optional, optional;
    private {
        const Description!IdentityType description;
    }

    public {
        /**
        Constructor accepting a constructed description

        Params:
            description = description to use.
        **/
        this(const Description!IdentityType description) {
            this.description = description;
        }

        /**
        Constructor accepting contents of a description

        Params:
            identity = custom identity in case if none is passed in describing function
            title = title used in description
            description = description used to provide
        **/
        this(const IdentityType identity, string title, string description) {
            this(Description!IdentityType(identity, title, description));
        }

        /**
        ditto
        **/
        this(string title, string description) {
            this(IdentityType.init, title, description);
        }

        /**
        Give same description for any passed component.

        Params:
            identity = identity of component being described
            component = component that is described
        Returns:
            A description or empty if it is not describable by this describer
        **/
        Optional!(const(Description!IdentityType)) describe(const ref IdentityType identity, const ref ComponentType component) const @safe {
            if (identity != IdentityType.init) {

                return (cast(const) Description!IdentityType(identity, this.description.title, this.description.description)).optional;
            }

            return this.description.optional;
        }

        /**
        ditto
        **/
        alias describe = Describer!(ComponentType, IdentityType).describe;
    }
}

/**
A describer that provides empty descriptions (i.e. no descriptions at all)
**/
@safe class NullDescriber(ComponentType = Object, IdentityType = string) : Describer!(ComponentType, IdentityType) {
    import aermicioi.aedi.util.typecons : Optional, optional;
    public {
        /**
        Give no description at all.

        Params:
            identity = identity of component being described
            component = component that is described
        Returns:
            A description or empty if it is not describable by this describer
        **/
        Optional!(const(Description!IdentityType)) describe(const ref IdentityType identity, const ref ComponentType component) const @safe {
            return Optional!(const(Description!IdentityType))();
        }

        /**
        ditto
        **/
        alias describe = Describer!(ComponentType, IdentityType).describe;
    }
}

/**
Decorating container that enhances existing ones with a set
of descriptions for itself and underlying components managed by it.
This decorated will inherit following interfaces only and only if the
T also implements them:
  $(OL
      $(LI Storage!(ObjectFactory, string))
      $(LI FactoryLocator!ObjectFactory)
      $(LI AliasAware!string)
  )
Decorated container must implement following interfaces:
    $(OL
        $(LI Container)
        $(LI MutableDecorator!T)
        $(LI Describer!(Object, string))
        $(LI Decorator!Container)
    )

Params:
    T = The decorated that switchable decorated will decorate.
**/
template DescribingContainer(T)
{
    import std.conv : text;
    import aermicioi.aedi.util.typecons : Optional, optional;

    /**
    Set which the switchable container will decorate for T. By default
    Locator!() and Subscribable!ContainerInstantiationEventType is included.
    **/
    alias InheritanceSet = NoDuplicates!(Filter!(
        templateOr!(
            partialSuffixed!(
                isDerived,
                Storage!(ObjectFactory, string)
            ),
            partialSuffixed!(
                isDerived,
                AliasAware!string
            ),
            partialSuffixed!(
                isDerived,
                FactoryLocator!ObjectFactory
            )
        ),
        InterfacesTuple!T),
        Container,
        Describer!(Object, string),
        Decorator!Container,
    );

    @safe class DescribingContainer : InheritanceSet
    {
        private {
            Describer!() fallback;
            Describer!() main;
            Describer!() container;
        }

        public
        {
            this(
                T decorated,
                Describer!() main = new IdentityDescriber!(),
                Describer!() container = new StaticDescriber!()("Component container", "A container of components"),
                Describer!() fallback = new TypeDescriber!()("${identity}", text("${identity} part of ", typeid(T), " of ${component}")),
            ) in (main !is null)
            {
                this.decorated = decorated;
                this.fallback = fallback;
                this.main = main;
                this.container = container;
            }

            alias describe = Describer!(Object, string).describe;
            Optional!(const(Description!string)) describe(const ref string identity, const ref Object component) const @safe {
                if (component is decorated) {
                    return container.describe(null, this.decorated);
                }

                foreach (decorator; component.decorators!Container) {
                    if (this is decorator) {
                        return container.describe(null, this.decorated);
                    }
                }

                auto result = main.describe(identity, component);

                if (result.isNull) {
                    return fallback.describe(identity, component);
                }

                return result;
            }

            mixin MutableDecoratorMixin!T;
            mixin ContainerMixin!T;

            /**
            Get object created by a factory identified by key

            Params:
                key = identity of factory
            Returns:
            Object
            **/
            Object get(string key)
            {
                if (key == typeid(DescriptionsProvider!string).toString) {
                    foreach (candidate; [main, container, fallback]) {
                        DescriptionsProvider!string subject = (() @trusted => cast(DescriptionsProvider!string) candidate)();

                        if (subject !is null) {
                            Object returnable = (() @trusted => cast(Object) subject)();

                            if (returnable is null) {
                                import aermicioi.aedi.storage.wrapper : WrapperImpl;
                                returnable = new WrapperImpl!(DescriptionsProvider!string)(subject);
                            }

                            return returnable;
                        }
                    }
                }

                if (key == typeid(Describer!()).toString) {
                    return this;
                }

                foreach (candidate; [ main, container, fallback ]) {
                    Object tested = (() @trusted => cast(Object) candidate)();

                    if ((tested !is null) && (tested.classinfo.toString == key)) {
                        return tested;
                    }
                }

                return this.decorated.get(key);
            }

            /**
            Check if an object factory for it exists in container.

            Params:
                key = identity of factory
            Returns:
                bool
            **/
            bool has(in string key) inout
            {
                if (key == typeid(DescriptionsProvider!string).toString) {
                    foreach (candidate; [main, container, fallback]) {
                        DescriptionsProvider!string subject = (() @trusted => cast(DescriptionsProvider!string) candidate)();

                        if (subject !is null) {
                            return true;
                        }
                    }
                }

                if (key == typeid(Describer!()).toString) {
                    return true;
                }


                foreach (candidate; [ main, container, fallback ]) {
                    Object tested = (() @trusted => cast(Object) candidate)();

                    if ((tested !is null) && (tested.classinfo.toString == key)) {
                        return true;
                    }
                }

                return this.decorated.has(key);
            }

            static if (is(T : Storage!(ObjectFactory, string)))
            {
                mixin StorageMixin!(typeof(this)) StorageScope;
            }

            static if (is(T : AliasAware!string))
            {
                mixin AliasAwareMixin!(typeof(this));
            }

            static if (is(T : FactoryLocator!ObjectFactory))
            {
                mixin FactoryLocatorMixin!(typeof(this));
            }
        }
    }
}
