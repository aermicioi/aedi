/**
Provides annotation based configuration and registration for components.

License:
	Boost Software License - Version 1.0 - August 17th, 2003

	Permission is hereby granted, free of charge, to any person or organization
	obtaining a copy of the software and accompanying documentation covered by
	this license (the "Software") to use, reproduce, display, distribute,
	execute, and transmit the Software, and to prepare derivative works of the
	Software, and to permit third-parties to whom the Software is furnished to
	do so, all subject to the following:

	The copyright notices in the Software and this entire statement, including
	the above license grant, this restriction and the following disclaimer,
	must be included in all copies of the Software, in whole or in part, and
	all derivative works of the Software, unless such copies or derivative
	works are solely in the form of machine-executable object code generated by
	a source language processor.

	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
	SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
	FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
	ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
	DEALINGS IN THE SOFTWARE.

Authors:
	aermicioi
**/
module aermicioi.aedi.configurer.annotation.component_scan;

import aermicioi.aedi.configurer.annotation.annotation;
import aermicioi.aedi.storage.locator;
import aermicioi.aedi.storage.storage;
import aermicioi.aedi.storage.wrapper;
import aermicioi.aedi.container.container;
import aermicioi.aedi.factory.factory;
import aermicioi.aedi.factory.reference;
import aermicioi.aedi.factory.generic_factory;
import aermicioi.aedi.factory.proxy_factory;
import aermicioi.aedi.exception;
import aermicioi.util.traits;
import aermicioi.aedi.factory.wrapping_factory : WrappingFactory;

import std.traits;
import std.meta;
import std.typecons;
import std.conv : to;
import std.algorithm;

struct Tested {
    static {
        GenericFactory!X createFactory(X)(Locator!()) {return null;};
        void configure(X)(GenericFactory!X, Locator!()) {};
        void configureMethod(string member, X)(GenericFactory!X, Locator!());
        void configureField(string member, X)(GenericFactory!X, Locator!());
    }
}

enum bool isFactoryPolicy(T, X = Tested) = is(T == struct) && is(typeof(&T.createFactory!X) : Z function(Locator!()), Z : Factory!X);
enum bool isConfiguratorPolicy(T, X : GenericFactory!Z = GenericFactory!Tested, Z) =
    is(T == struct) &&
    is(typeof(&T.configure!(X)) : void function(M, Locator!()), M : X);

struct GenericFactoryPolicy {

    private alias getComponents(alias T) = Filter!(
            isComponentAnnotation,
            allUDAs!T
        );

    static GenericFactory!T createFactory(T)(Locator!() locator) {
        alias Component = getComponents!T;

        static if (Component.length > 0) {
            debug pragma(msg, "Creating factory for component ", T);
            return new GenericFactoryImpl!T(locator);
        } else {

            return null;
        }
    };
}

struct ChainedConfiguratorPolicy(ConfiguratorPolicies...)
    if (allSatisfy!(isConfiguratorPolicy, ConfiguratorPolicies)) {

    static auto configure(T : GenericFactory!Z, Z)(T instantiator, Locator!() locator) {

        foreach (policy; ConfiguratorPolicies) {
            policy.configure(instantiator, locator);
        }
    }
}

struct AllocatorConfiguratorPolicy {

    private alias getAllocators(alias T) = Filter!(
            isAllocatorAnnotation,
            allUDAs!T
        );

    static auto configure(T : GenericFactory!Z, Z)(T instantiator, Locator!() locator) {

        static foreach (Allocator; getAllocators!Z) {
            debug pragma(msg, "Found custom allocator for ", Z, " provisioning with ", toType!(Allocator.allocator));
            instantiator.allocator = Allocator.iallocator;
        }
    }
}

struct CallbackFactoryConfiguratorPolicy {
    private alias getCallbackFactories(alias T) = Filter!(
            isCallbackFactoryAnnotation,
            allUDAs!T
        );

    static auto configure(T : GenericFactory!Z, Z)(T instantiator, Locator!() locator) {
        import std.experimental.allocator;

        foreach (CallbackFactory; tuple(getCallbackFactories!Z).expand) {
            debug pragma(msg,
                "Found callback factory for ",
                Z,
                " provisioning with ",
                typeof(CallbackFactory.dg),
                "(",
                typeof(CallbackFactory.args.expand),
                ")"
            );
            instantiator.setInstanceFactory(callbackFactory(CallbackFactory.dg, CallbackFactory.args.expand));
        }
    }
}

struct ValueFactoryConfiguratorPolicy {
    private alias getValueFactories(alias T) = Filter!(
            isValueAnnotation,
            allUDAs!T
        );

    static auto configure(T : GenericFactory!Z, Z)(T instantiator, Locator!() locator) {
        import std.experimental.allocator;

        foreach (ValueAnnotation; tuple(getValueFactories!Z).expand) {
            debug pragma(msg,
                "Found value factory for ",
                Z,
                " provisioning with ",
                typeof(ValueAnnotation.value)
            );
            instantiator.setInstanceFactory(new ValueInstanceFactory!Z(ValueAnnotation.value));
        }
    }
}

struct GenericConfigurerConfiguratorPolicy {
    private alias getGenerics(alias T, X) = Filter!(
                chain!(
                    ApplyRight!(isConfiguratorPolicy, X),
                    toType
                ),
                allUDAs!T
            );

    static auto configure(T : GenericFactory!Z, Z)(T instantiator, Locator!() locator) {
        foreach (Generic; tuple(getGenerics!(Z, T)).expand) {
            debug pragma(msg, "Found annotation implementing configurer annotation contract ", typeof(Generic));
            Generic.configure!(T)(instantiator, locator);
        }
    }
}

struct ConfiguredFieldTester {

    int field;
}

struct ConfiguredMethodTester {

    void method(int x) {}
}

enum bool isFieldConfiguratorPolicy(T, string member = "field", X : GenericFactory!Z = GenericFactory!ConfiguredFieldTester, Z) =
    is(T == struct) &&
    is(typeof(&T.configureField!(member, X)) : void function(X, Locator!()));

enum bool isMethodConfiguratorPolicy(T, string member = "method", X : GenericFactory!Z = GenericFactory!ConfiguredMethodTester, Z) =
    is(T == struct) &&
    is(typeof(&T.configureMethod!(member, X)) : void function(X, Locator!()));

struct MethodScanningConfiguratorPolicy(MethodConfiguratorPolicies...)
    if (allSatisfy!(isMethodConfiguratorPolicy, MethodConfiguratorPolicies)) {

    static auto configure(T : GenericFactory!Z, Z)(T instantiator, Locator!() locator) {
        foreach (member; __traits(allMembers, Z)) {
            static if ((getProtection!(Z, member) == "public") && isSomeFunction!(__traits(getMember, Z, member))) {
                foreach (methodConfigurer; MethodConfiguratorPolicies) {
                    methodConfigurer.configureMethod!member(instantiator, locator);
                }
            }
        }
    }
}

struct FieldScanningConfiguratorPolicy(FieldConfiguratorPolicies...)
    if (allSatisfy!(isFieldConfiguratorPolicy, FieldConfiguratorPolicies)) {

    static auto configure(T : GenericFactory!Z, Z)(T instantiator, Locator!() locator) {
        foreach (member; __traits(allMembers, Z)) {
            static if (isField!(Z, member) && (getProtection!(Z, member) == "public")) {
                foreach (fieldConfigurer; FieldConfiguratorPolicies) {
                    fieldConfigurer.configureField!member(instantiator, locator);
                }
            }
        }
    }
}

struct ConstructorMethodConfiguratorPolicy {

    static auto configureMethod(string member, T : GenericFactory!Z, Z)(T instantiator, Locator!() locator) {

        static if (member == "__ctor") {
            foreach (overload; __traits(getOverloads, Z, member)) {


                alias Configurers = Filter!(
                    isConstructorAnnotation,
                    allUDAs!(overload)
                );

                foreach (Configurer; tuple(staticMap!(toValue, Configurers))) {
                    debug pragma(msg, "Found elaborate constructor for ", Z, " provisioning with ", toType!Configurer);
                    instantiator.setInstanceFactory(
                        constructorBasedFactory!Z(Configurer.args.expand)
                    );
                }
            }
        }
    }
}

struct AutowiredConstructorMethodConfiguratorPolicy {
    static auto configureMethod(string member, T : GenericFactory!Z, Z)(T instantiator, Locator!() locator) {

        static if (member == "__ctor") {
            foreach (overload; __traits(getOverloads, Z, member)) {

                alias Configurers = Filter!(
                    isAutowiredAnnotation,
                    allUDAs!(overload)
                );

                foreach (Configurer; tuple(staticMap!(toValue, Configurers))) {
                    debug pragma(msg, "Autowiring constructor of ", Z, " with arguments ", Parameters!(overload));
                    instantiator.setInstanceFactory(
                        constructorBasedFactory!Z(staticMap!(toLref, Parameters!(overload)))
                    );
                }
            }
        }
    }
}

struct SetterFieldConfiguratorPolicy {

    static auto configureField(string member, T : GenericFactory!Z, Z)(T instantiator, Locator!() locator) {

        alias Configurers = Filter!(
            isSetterAnnotation,
            allUDAs!(__traits(getMember, Z, member))
        );

        foreach (Configurer; tuple(staticMap!(toValue, Configurers))) {
            debug pragma(msg, "Setting field ", member, " of ", Z, " to ", staticMap!(toType, Configurer.args.expand));
            instantiator.addPropertyConfigurer(fieldConfigurer!(member, Z)(Configurer.args.expand));
        }
    }
}

struct CallbackFieldConfiguratorPolicy {

    static auto configureField(string member, T : GenericFactory!Z, Z)(T instantiator, Locator!() locator) {

        alias Callbacks = Filter!(
            isCallbackConfigurerAnnotation,
            allUDAs!(__traits(getMember, Z, member))
        );

        foreach (Callback; tuple(staticMap!(toValue, Callbacks))) {
            debug pragma(msg, "Calling callback on field ", member, " of ", Z, " to ", staticMap!(toType, Callback.args.expand));
            instantiator.addPropertyConfigurer(callbackConfigurer(Callback.dg, Callback.args.expand));
        }
    }
}

struct AutowiredFieldConfiguratorPolicy {

    static auto configureField(string member, T : GenericFactory!Z, Z)(T instantiator, Locator!() locator) {

        alias Callbacks = Filter!(
            isAutowiredAnnotation,
            allUDAs!(__traits(getMember, Z, member))
        );

        foreach (Callback; tuple(staticMap!(toValue, Callbacks))) {
            debug pragma(msg, "Autowiring field ", member, " of ", Z, " to ", typeof(getMember!(Z, member)));
            instantiator.addPropertyConfigurer(fieldConfigurer!(member, Z)(toLref!(typeof(getMember!(Z, member)))));
        }
    }
}

struct SetterMethodConfiguratorPolicy {

    static auto configureMethod(string member, T : GenericFactory!Z, Z)(T instantiator, Locator!() locator) {

        foreach (overload; __traits(getOverloads, Z, member)) {

            alias Configurers = Filter!(
                isSetterAnnotation,
                allUDAs!(overload)
            );

            foreach (Configurer; tuple(staticMap!(toValue, Configurers))) {
                debug pragma(msg, "Calling method ", member, " of ", Z, " with ", staticMap!(toType, Configurer.args.expand));
                instantiator.addPropertyConfigurer(methodConfigurer!(member, Z)(Configurer.args.expand));
            }
        }
    }
}

struct CallbackMethodConfiguratorPolicy {

    static auto configureMethod(string member, T : GenericFactory!Z, Z)(T instantiator, Locator!() locator) {

        foreach (overload; __traits(getOverloads, Z, member)) {

            alias Configurers = Filter!(
                isCallbackConfigurerAnnotation,
                allUDAs!(overload)
            );

            foreach (Configurer; tuple(staticMap!(toValue, Configurers))) {
                debug pragma(msg, "Calling callback on method ", member, " of ", Z, " with ", staticMap!(toType, Configurer.args.expand));
                instantiator.addPropertyConfigurer(callbackConfigurer(Configurer.dg, Configurer.args.expand));
            }
        }
    }
}

struct AutowiredMethodConfiguratorPolicy {

    static auto configureMethod(string member, T : GenericFactory!Z, Z)(T instantiator, Locator!() locator) {
        static if (member != "__ctor") {
            foreach (overload; __traits(getOverloads, Z, member)) {

                alias Configurers = Filter!(
                    isAutowiredAnnotation,
                    allUDAs!(overload)
                );

                foreach (Configurer; tuple(staticMap!(toValue, Configurers))) {

                    debug pragma(msg, "Calling method ", member, " of ", Z, " with autowired ", Parameters!overload);
                    instantiator.addPropertyConfigurer(methodConfigurer!(member, Z)(staticMap!(toLref, Parameters!overload)));
                }
            }
        }
    }
}

enum bool isTransformer(T, X = Object) = is(T == struct) && is(typeof(&T.transform!X) : void function (Locator!(), Storage!(ObjectFactory, string)));
enum bool isTransformer(T, X, string member) = is(T == struct) && is(typeof(&T.transform!X) : void function (Locator!(), Storage!(ObjectFactory, string)));

struct TypeTransformer(FactoryPolicy, ConfigurerPolicy)
    if (isFactoryPolicy!FactoryPolicy && isConfiguratorPolicy!ConfigurerPolicy) {

    static auto transform(T)(Locator!() locator)
        if (is(T)) {
        auto instantiator = FactoryPolicy.createFactory!T(locator);

        if (instantiator is null) {
            return instantiator;
        }

        ConfigurerPolicy.configure(instantiator, locator);

        return instantiator;
    }
}

struct ObjectFactoryTransformer(TransformerPolicy) {

    static auto transform(T)(Locator!() locator)
        if (is(T)) {

        auto instantiator = TransformerPolicy.transform!T(locator);

        if (instantiator is null) {
            return cast(WrappingFactory!(typeof(instantiator))) null;
        }

        return new WrappingFactory!(typeof(instantiator))(instantiator);
    }
}

struct ChainedContainerAdder(ContainerAdderPolicies...) {
    import aermicioi.util.traits;

    enum bool isSupported(alias T) = anySatisfied!(T, staticMap!(ApplyRight!(getMember, "isSupported"), ContainerAdderPolicies));

    static auto scan(alias T)(Locator!() locator, Storage!(ObjectFactory, string) storage)
        if (isSupported!T) {
        foreach (ContainerAdderPolicy; ContainerAdderPolicies) {

            static if (ContainerAdderPolicy.isSupported!T) {
                ContainerAdderPolicy.scan!T(locator, storage);
            }
        }
    }
}

struct TypeContainerAdder(TypeTransformerPolicy) {
    enum bool isSupported(alias T) = is(T);

    static auto scan(T)(Locator!() locator, Storage!(ObjectFactory, string) storage)
        if (isSupported!T) {

        string identity = fullyQualifiedName!T;
        alias Qualifiers = Filter!(
            isQualifierAnnotation,
            allUDAs!T
        );

        foreach (Qualifier; Qualifiers) {
            identity = Qualifier.id;
        }

        auto transformed = TypeTransformerPolicy.transform!T(locator);

        if (transformed is null) {
            return;
        }
        storage.set(transformed, identity);
    }
}

struct InnerTypeContainerAdder(ContainerAdderPolicy) {
    enum bool isSupported(alias T) = is(T);

    static auto scan(T)(Locator!() locator, Storage!(ObjectFactory, string) storage)
        if(isSupported!T) {

        foreach (member; __traits(allMembers, T)) {
            static if (isPublic!(T, member) && is(Alias!(__traits(getMember, T, member)))) {

                ContainerAdderPolicy.scan!(getMember!(T, member))(locator, storage);
                scan!(getMember!(T, member))(locator, storage);
            }
        }
    }
}

struct ModuleContainerAdder(ContainerAdderPolicy) {
    enum bool isSupported(alias T) = T.stringof.startsWith("module ");

    static auto scan(alias T)(Locator!() locator, Storage!(ObjectFactory, string) storage)
        if (isSupported!T) {

        foreach (member; __traits(allMembers, T)) {
            static if (isPublic!(T, member) && is(Alias!(__traits(getMember, T, member)))) {

                ContainerAdderPolicy.scan!(getMember!(T, member))(locator, storage);
            }
        }
    }
}

struct FactoryMethodContainerAdder(TypeTransformer) {
    enum bool isSupported(alias T) = is(T);

    static auto scan(alias T)(Locator!() locator, Storage!(ObjectFactory, string) storage)
        if (isSupported!T) {

        foreach (member; __traits(allMembers, T)) {
            static if (isPublic!(T, member) && isSomeFunction!(__traits(getMember, T, member))) {

                foreach (overload; __traits(getOverloads, T, member)) {

                    alias FactoryMethods = Filter!(
                        isComponentAnnotation,
                        allUDAs!overload
                    );

                    foreach (FactoryMethod; FactoryMethods) {
                        debug pragma(msg, "Found factory method ", member, " on component ", T);
                        auto factory = TypeTransformer.transform!(ReturnType!overload)(locator);

                        if (factory !is null) {
                            static if (__traits(isStaticFunction, overload)) {
                                auto instanceFactory = factoryMethodBasedFactory!(T, member)(staticMap!(toLref, Parameters!overload));
                            } else {
                                auto instanceFactory = factoryMethodBasedFactory!(T, member)(staticMap!(toLref, AliasSeq!(T, Parameters!overload)));
                            }

                            import aermicioi.aedi.storage.decorator : Decorator;

                            static if (is(typeof(factory) : Decorator!X, X : GenericFactory!Z, Z)) {
                                factory.decorated.setInstanceFactory = instanceFactory;
                            } else static if (is(typeof(factory) : GenericFactory!Z, Z) && !is(Z == Object)) {
                                factory.setInstanceFactory = instanceFactory;
                            }

                            storage.set(factory, fullyQualifiedName!(ReturnType!overload));
                        }
                    }
                }
            }
        }
    }
}

/**
Register an object into storage using annotations provided in it.

An object will be registered in storage only in case when it is annotated with @component annotation. In case when no @component
annotation is found, object is not registered in storage.

Params:
    T = type of object to be registered
    storage = the storage where to register the object
    locator = the locator used to find object dependencies
    id = identity by which object will be stored in storage
**/
// deprecated
auto componentScan(T)(Storage!(ObjectFactory, string) storage, Locator!() locator, string id) {
    auto factory = componentScanImpl!T(locator);

    alias SubComponents = staticMap!(
        partialPrefixed!(
            getMember,
            T
        ),
        Filter!(
            templateAnd!(
                partialPrefixed!(
                    partialSuffixed!(
                        isProtection,
                        "public"
                    ),
                    T
                ),
                chain!(
                    isType,
                    partialPrefixed!(
                        getMember,
                        T
                    )
                ),
                chain!(
                    isClass,
                    partialPrefixed!(
                        getMember,
                        T
                    )
                )
            ),
            __traits(allMembers, T)
        )
    );

    static if (SubComponents.length > 0) {
        storage.componentScan!SubComponents(locator);
    }

    if (factory !is null) {
        storage.set(new WrappingFactory!(Factory!T)(factory), id);
    }

    return storage;
}

/**
Register an object into storage by it's type FQN using annotations provided in it.

An object will be registered in storage only in case when it is annotated with @component annotation. In case when no @component
annotation is found, object is not registered in storage.

Params:
    T = type of object to be registered
    storage = the storage where to register the object
**/
// deprecated
auto componentScan(T)(Storage!(ObjectFactory, string) storage, Locator!() locator) {

    alias qualifiers = Filter!(isQualifier, allUDAs!T);

    static if (qualifiers.length > 0) {
        return storage.componentScan!T(locator, qualifiers[0].id);
    } else {
        return storage.componentScan!T(locator, name!T);
    }
}

/**
ditto
**/
// deprecated
auto componentScan(T)(ConfigurableContainer storage) {

    return storage.componentScan!T(storage);
}

/**
Register an object into storage by I's interface FQN that it implements using annotations provided in it.

An object will be registered in storage only in case when it is annotated with @component annotation. In case when no @component
annotation is found, object is not registered in storage.

Params:
    I = the inteface that object implements.
    T = type of object to be registered
    storage = the storage where to register the object
**/
// deprecated
auto componentScan(I, T)(Storage!(ObjectFactory, string) storage, Locator!() locator)
    if (is(I == interface) && is(T == class) && is(T : I)) {

    alias qualifiers = Filter!(
        isQualifier,
        allUDAs!I
    );

    static if (qualifiers.length > 0) {
        return storage.componentScan!T(locator, qualifier[0].id);
    } else {
        return storage.componentScan!T(locator, name!I);
    }
}

/**
ditto
**/
// deprecated
auto componentScan(I, T)(ConfigurableContainer storage)
    if (is(I == interface) && is(T == class) && is(T : I)) {

    return storage.componentScan!(I, T)(storage);
}

/**
Register a set of objects by it's type, or implemented interface into a storage.

When registering an object by it's interface, next to interface it is required to specify the original type of object.
Note: An object will be registered in storage only in case when it is annotated with @component annotation. In case when no @component
annotation is found, object is not registered in storage.

Params:
    I = the inteface that object implements.
    T = type of object to be registered
    storage = the storage where to register the object
**/
// deprecated
auto componentScan(T, V...)(Storage!(ObjectFactory, string) storage, Locator!() locator) {
    storage.componentScan!T(locator);
    return storage.componentScan!V(locator);
}

/**
ditto
**/
// deprecated
auto componentScan(T, V...)(ConfigurableContainer storage) {

    return storage.componentScan!(T, V)(storage);
}

/**
ditto
**/
// deprecated
auto componentScan(I, T, V...)(Storage!(ObjectFactory, string) storage, Locator!() locator)
    if (is(I == interface) && is(T == class) && is(T : I)) {
    storage.componentScan!(I, T)(locator);

    return storage.componentScan!(V)(locator);
}

/**
ditto
**/
// deprecated
auto componentScan(I, T, V...)(ConfigurableContainer storage)
    if (is(I == interface) && is(T == class) && is(T : I)) {

    return storage.componentScan!(I, T, V)(storage);
}

/**
Scan a module and register all public objects that are annotated with @component annotation.

Note: An object will be registered in storage only in case when it is annotated with @component annotation. In case when no @component
annotation is found, object is not registered in storage.

Params:
    Module = module to scan for components.
    storage = the storage where to register the object
    locator = the locator used to fetch registered object's dependencies.
**/
// deprecated
auto componentScan(alias Module)(Storage!(ObjectFactory, string) storage, Locator!() locator)
    if (startsWith(Module.stringof, "module ")) {

    alias components = staticMap!(
        partialPrefixed!(
            getMember,
            Module
        ),
        Filter!(
            templateAnd!(
                partialSuffixed!(
                    partialPrefixed!(
                        isProtection,
                        Module
                    ),
                    "public"
                ),
                chain!(
                    isType,
                    partialPrefixed!(
                        getMember,
                        Module
                    )
                ),
                chain!(
                    isClass,
                    partialPrefixed!(
                        getMember,
                        Module
                    )
                )
            ),
            __traits(allMembers, Module)
        )
    );

    storage.componentScan!components(locator);

    return storage;
}

/**
ditto
**/
// deprecated
auto componentScan(alias M)(ConfigurableContainer storage)
    if (startsWith(M.stringof, "module")) {

    return storage.componentScan!(M)(storage);
}

/**
Scan a set of modules and register all public objects that are annotated with @component annotation.

Due to limitations of D language currently it is impossible to recursively scan all public imports of a module to register all
depencies of a package. Each particular module should be specified in order to register dependencies.
Note: An object will be registered in storage only in case when it is annotated with @component annotation. In case when no @component
annotation is found, object is not registered in storage.

Params:
    M = current module to scan.
    V = rest set of modules waiting for scan.
    storage = the storage where to register the object
    locator = the locator used to fetch registered object's dependencies.
**/
// deprecated
auto componentScan(alias M, V...)(Storage!(ObjectFactory, string) storage, Locator!() locator)
    if (startsWith(M.stringof, "module")) {
    storage.componentScan!M(locator);
    return storage.componentScan!V(locator);
}

/**
ditto
**/
// deprecated
auto componentScan(alias M, V...)(ConfigurableContainer storage)
    if (startsWith(M.stringof, "module")) {

    return storage.componentScan!(M, V)(storage);
}

/**
Register an object into a storage contained in storageLocator and identified by @container annotation using annotations provided in it.

An object will be registered in storage only in case when it is annotated with @component annotation. In case when no @component
annotation is found, object is not registered in storage.

Params:
    T = type of object to be registered
    storageLocator = the locator from which to fetch storage for object
    locator = locator used to find dependencies for object
    id = identity by which object will be stored in storage
**/
// deprecated
auto componentScan(T, R : Locator!())(R storageLocator, Locator!() locator, string id)
    if (!is(R : Storage!(ObjectFactory, string))) {

    alias containers = Filter!(
        isContained,
        allUDAs!T
    );

    static if (containers.length > 0) {
        string storageId = containers[0].id;
    } else {
        string storageId = "singleton";
    }

    auto storage = storageLocator.locate!(Storage!(ObjectFactory, string))(storageId);

    if (storage !is null) {

        storage.componentScan!T(locator, id);
    } else {

        throw new NotFoundException("Could not find storage to save factory for object of identity " ~ id);
    }

    return storageLocator;
}

/**
ditto
**/
// deprecated
auto componentScan(T, R : Locator!())(R locator, string id)
    if (!is(R : Storage!(ObjectFactory, string))) {
    return locator.componentScan!T(locator, id);
}

/**
ditto
**/
// deprecated
auto componentScan(T, R : Locator!())(R storageLocator, Locator!() locator)
    if (!is(R : Storage!(ObjectFactory, string))) {

    alias qualifiers = Filter!(
        isQualifier,
        allUDAs!T
    );

    static if (qualifiers.length > 0) {
        return storageLocator.componentScan!T(locator, qualifiers[0].id);
    } else {
        return storageLocator.componentScan!T(locator, name!T);
    }
}

/**
ditto
**/
// deprecated
auto componentScan(T, R : Locator!())(R locator)
    if (!is(R : Storage!(ObjectFactory, string))) {
    return locator.componentScan!T(locator);
}

/**
ditto
**/
template componentScan(T, V...)
    if((V.length > 0)) {

    /**
    ditto
    **/
    // deprecated
auto componentScan(R : Locator!())(R storageLocator, Locator!() locator)
        if (!is(R : Storage!(ObjectFactory, string))) {
        .componentScan!T(storageLocator, locator);

        return .componentScan!V(storageLocator, locator);
    }

    /**
    ditto
    **/
    // deprecated
auto componentScan(R : Locator!())(R locator)
        if (!is(R : Storage!(ObjectFactory, string))) {
        .componentScan!T(locator, locator);

        return .componentScan!V(locator, locator);
    }
}

/**
Register an object into a storage contained in storageLocator and identified by @container annotation using annotations provided in it.

An object will be registered in storage only in case when it is annotated with @component annotation. In case when no @component
annotation is found, object is not registered in storage.

Params:
    I = interface implemented by object, by which to register it.
    T = type of object to be registered
    storageLocator = locator used to find storage for object
    locator = locator used to find dependencies for object
**/
// deprecated
auto componentScan(I, T, R : Locator!())(R storageLocator, Locator!() locator)
    if (is (I == interface) && is (T == class) && is (T : I) && !is(R : Storage!(ObjectFactory, string))) {
    alias qualifiers = Filter!(
        isQualifier,
        allUDAs!I
    );

    static if (qualifiers.length > 0) {
        return storageLocator.componentScan!T(locator, qualifiers[0].id);
    } else {
        return storageLocator.componentScan!T(locator, name!I);
    }
}

/**
ditto
**/
// deprecated
auto componentScan(I, T, R : Locator!())(R locator)
    if (is (I == interface) && is (T == class) && is (T : I) && !is(R : Storage!(ObjectFactory, string))) {

    return locator.componentScan!(I, T)(locator);
}

/**
ditto
**/
template componentScan(I, T, V...)
    if (is (I == interface) && is (T == class) && is (T : I) && (V.length > 0)) {

    /**
    ditto
    **/
    // deprecated
auto componentScan(R : Locator!())(R storageLocator, Locator!() locator)
        if (!is(R : Storage!(ObjectFactory, string))) {

        .componentScan!(I, T)(storageLocator, locator);

        return .componentScan!(V)(storageLocator, locator);
    }

    /**
    ditto
    **/
    // deprecated
auto componentScan(R : Locator!())(R locator)
        if (!is(R : Storage!(ObjectFactory, string))) {

        .componentScan!(I, T)(locator);

        return .componentScan!(V)(locator);
    }
}

/**
Register module's objects into a storage contained in storageLocator and identified by @container annotation using annotations provided in it.

An object will be registered in storage only in case when it is annotated with @component annotation. In case when no @component
annotation is found, object is not registered in storage.

Params:
    M = module to scan for instantiable objects.
    storageLocator = locator used to find storage for objects
    locator = locator used to find object dependencies
**/
// deprecated
auto componentScan(alias M, R : Locator!())(R storageLocator, Locator!() locator)
    if (M.stringof.startsWith("module ") && !is(R : Storage!(ObjectFactory, string)))  {

    alias components = getPossibleComponents!M;

    storageLocator.componentScan!components(locator);

    return storageLocator;
}

/**
ditto
**/
// deprecated
auto componentScan(alias M, R : Locator!())(R locator)
    if (M.stringof.startsWith("module ") && !is(R : Storage!(ObjectFactory, string)))  {

    locator.componentScan!M(locator);

    return locator;
}

/**
ditto
**/
template componentScan(alias M, V...)
    if (M.stringof.startsWith("module ") && (V.length > 0)) {

    /**
    ditto
    **/
    // deprecated
auto componentScan(R : Locator!())(R locatorStorage, Locator!() locator)
        if (!is(R : Storage!(ObjectFactory, string))) {

        .componentScan!M(locatorStorage, locator);
        return .componentScan!V(locatorStorage, locator);
    }

    /**
    ditto
    **/
    // deprecated
auto componentScan(R : Locator!())(R locator)
        if (!is(R : Storage!(ObjectFactory, string))) {

        .componentScan!M(locator);
        return .componentScan!V(locator);
    }
}

alias TypedComponentTransformer =
    TypeTransformer!(
        GenericFactoryPolicy,
        ChainedConfiguratorPolicy!(
            FieldScanningConfiguratorPolicy!(
                SetterFieldConfiguratorPolicy,
                CallbackFieldConfiguratorPolicy,
                AutowiredFieldConfiguratorPolicy
            ),
            MethodScanningConfiguratorPolicy!(
                ConstructorMethodConfiguratorPolicy,
                AutowiredConstructorMethodConfiguratorPolicy,
                SetterMethodConfiguratorPolicy,
                CallbackMethodConfiguratorPolicy,
                AutowiredMethodConfiguratorPolicy
            ),
            AllocatorConfiguratorPolicy,
            CallbackFactoryConfiguratorPolicy,
            ValueFactoryConfiguratorPolicy,
            GenericConfigurerConfiguratorPolicy
        )
    );

alias ObjectWrapperTransformerPolicy =
    ObjectFactoryTransformer!(
        TypedComponentTransformer
    );

alias DefaultContainerAdderPolicy(TransformerPolicy = ObjectWrapperTransformerPolicy) =
    ChainedContainerAdder!(
        TypeContainerAdder!TransformerPolicy,
        InnerTypeContainerAdder!(TypeContainerAdder!TransformerPolicy),
        FactoryMethodContainerAdder!TransformerPolicy,
        ModuleContainerAdder!(
            ChainedContainerAdder!(
                TypeContainerAdder!TransformerPolicy,
                InnerTypeContainerAdder!(TypeContainerAdder!TransformerPolicy),
                FactoryMethodContainerAdder!TransformerPolicy,
            )
        ),
    );

mixin template Scanner(ContainerAdderPolicy) {
    void scan(alias T)(Storage!(ObjectFactory, string) storage, Locator!() locator) {
        debug pragma(msg, "Scanning ", T, " for possible components");

        ContainerAdderPolicy.scan!T(locator, storage);
    }

    void scan(alias T)(string storage, Locator!() locator) {

        scan!T(locator.locate!(Storage!(ObjectFactory, string))(storage), locator);
    }

    void scan(alias T, St : Storage!(ObjectFactory, string) = Storage!(ObjectFactory, string))(Locator!() locator) {

        scan!T(locator.locate!St, locator);
    }

    void scan(alias T, X...)(Storage!(ObjectFactory, string) storage, Locator!() locator) {

        scan!T(storage, locator);

        static if (X.length > 0) {

            scan!X(storage, locator);
        }
    }

    void scan(alias T, X...)(string storage, Locator!() locator) {

        scan!(T, X)(locator.locate!(Storage!(ObjectFactory, string))(storage), locator);
    }

    void scan(alias T, X...)(Locator!() locator) {
        scan!T(locator);

        static if (X.length > 0) {

            scan!X(locator);
        }
    }

    void scan(alias T, St : Storage!(ObjectFactory, string), X...)(Locator!() locator) {

        scan!(T, St)(locator);

        static if (X.length > 0) {

            scan!X(locator);
        }
    }
}

mixin Scanner!(DefaultContainerAdderPolicy!ObjectWrapperTransformerPolicy);

// deprecated
auto componentScanImpl(T)(Locator!() locator) {

    return TypedComponentTransformer.transform!T(locator);
}

private template isQualifier(alias T) {
    alias isQualifier = isQualifier!(typeof(T));
}

private template isQualifier(T) {
    enum bool isQualifier = is(T == QualifierAnnotation);
}

private template isContained(alias T) {
    alias isContained = isContained!(typeof(T));
}

private template isContained(T) {
    enum bool isContained = is(T == ContainedAnnotation);
}

private template isValue(T) {
    enum bool isValue = is (typeof(T));
}

private template isReturnTypeEq(alias symbol, Type)
    if (isSomeFunction!symbol) {
    enum bool isReturnTypeEq = is(ReturnType!symbol : Type);
}

private template isNamedTemplate(alias T, string name) {
    enum bool isNamedTemplate = isTemplate!T && (identifier!T == name);
}

private template isEqByFQDN(alias first, alias second) {
    enum bool isEqByFQDN = fullyQualifiedName!first == fullyQualifiedName!second;
}

private template instantiatonToTemplate(alias T, alias Template = T) {
    static if (isTemplateInstantiationOf!(T, Template)) {
        alias instantiatonToTemplate = Template;
    } else static if (isTemplate!T) {
        alias instantiatonToTemplate = T;
    }
}

private enum bool isTemplateInstantiationOf(T, alias Template) = is(T : Template!(Z), Z...);
private enum bool isTemplateInstantiationOf(alias T, alias Template) = is(typeof(T) : Template!(Z), Z...);

private template identifierEq(alias T, string identity) {
    enum bool identifierEq = identifier!T == identity;
}

private template allUDAs(alias symbol) {
    alias allUDAs = AliasSeq!(__traits(getAttributes, symbol));
}

private template toValue(T) {
    enum auto toValue = T();
}

private template toValue(alias T) {
    alias toValue = T;
}

private template isType(alias T) {
    static if (__traits(compiles, () { T z = T.init; })) {

        enum bool isType = true;
    } else {

        enum bool isType = false;
    }
}

private template isClass(alias T) {
    enum bool isClass = is(typeof(T) == class);
}

private template isClass(T) {
    enum bool isClass = is(T == class);
}

private template isStruct(alias T) {
    enum bool isStruct = is(typeof(T) == struct);
}

private template isStruct(T) {
    enum bool isStruct = is(T == struct);
}

private template getPublicAggregateMembers(alias Symbol) {
    alias getPublicAggregateMembers = Filter!(
        templateAnd!(
            partialSuffixed!(
                partialPrefixed!(
                    isProtection,
                    Symbol
                ),
                "public"
            ),
            chain!(
                hasMembers,
                partialPrefixed!(
                    getMember,
                    Symbol
                )
            )
        ),
        __traits(allMembers, Symbol)
    );
}

private template getPossibleComponents(alias Symbol) {
    alias getPossibleComponents = staticMap!(
        partialPrefixed!(
            getMember,
            Symbol
        ),
        Filter!(
            templateAnd!(
                partialSuffixed!(
                    partialPrefixed!(
                        isProtection,
                        Symbol
                    ),
                    "public"
                ),
                chain!(
                    isType,
                    partialPrefixed!(
                        getMember,
                        Symbol
                    )
                ),
                chain!(
                    templateOr!(
                        isClass,
                        isStruct
                    ),
                    partialPrefixed!(
                        getMember,
                        Symbol
                    )
                )
            ),
            __traits(allMembers, Symbol)
        )
    );
}