/**
License:
	Boost Software License - Version 1.0 - August 17th, 2003

	Permission is hereby granted, free of charge, to any person or organization
	obtaining a copy of the software and accompanying documentation covered by
	this license (the "Software") to use, reproduce, display, distribute,
	execute, and transmit the Software, and to prepare derivative works of the
	Software, and to permit third-parties to whom the Software is furnished to
	do so, all subject to the following:
	
	The copyright notices in the Software and this entire statement, including
	the above license grant, this restriction and the following disclaimer,
	must be included in all copies of the Software, in whole or in part, and
	all derivative works of the Software, unless such copies or derivative
	works are solely in the form of machine-executable object code generated by
	a source language processor.
	
	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
	SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
	FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
	ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
	DEALINGS IN THE SOFTWARE.

Authors:
	aermicioi
**/
module aermicioi.aedi.configurer.annotation.component_scan;

import aermicioi.aedi.configurer.annotation.annotation;
import aermicioi.aedi.storage.locator;
import aermicioi.aedi.storage.storage;
import aermicioi.aedi.storage.wrapper;
import aermicioi.aedi.container.container;
import aermicioi.aedi.factory.factory;
import aermicioi.aedi.factory.reference;
import aermicioi.aedi.factory.generic_factory;
import aermicioi.aedi.factory.proxy_factory;
import aermicioi.aedi.exception;
import aermicioi.util.traits;
import aermicioi.aedi.factory.decorating_factory : WrappingFactory;

import std.traits;
import std.meta;
import std.typecons;
import std.conv : to;
import std.algorithm;

/**
Register an object into storage using annotations provided in it.

An object will be registered in storage only in case when it is annotated with @component annotation. In case when no @component
annotation is found, object is not registered in storage.

Params:
    T = type of object to be registered
    storage = the storage where to register the object
    locator = the locator used to find object dependencies
    id = identity by which object will be stored in storage
**/
auto componentScan(T)(Storage!(ObjectFactory, string) storage, Locator!() locator, string id) {
    auto factory = componentScanImpl!T(locator);
    
    alias SubComponents = staticMap!(
        partialPrefixed!(
            getMember,
            T
        ),
        Filter!(
            templateAnd!(
                partialPrefixed!(
                    partialSuffixed!(
                        isProtection,
                        "public"
                    ),
                    T
                ),
                chain!(
                    isType,
                    partialPrefixed!(
                        getMember,
                        T
                    )
                ),
                chain!(
                    isClass,
                    partialPrefixed!(
                        getMember,
                        T
                    )
                )
            ),
            __traits(allMembers, T)
        )
    );
    
    static if (SubComponents.length > 0) {
        storage.componentScan!SubComponents(locator);
    }
    
    if (factory !is null) {
        storage.set(new WrappingFactory!(Factory!T)(factory), id);
    }
    
    return storage;
}

/**
Register an object into storage by it's type FQN using annotations provided in it.

An object will be registered in storage only in case when it is annotated with @component annotation. In case when no @component
annotation is found, object is not registered in storage.

Params:
    T = type of object to be registered
    storage = the storage where to register the object
**/
auto componentScan(T)(Storage!(ObjectFactory, string) storage, Locator!() locator) {
        
    alias qualifiers = Filter!(isQualifier, allUDAs!T);

    static if (qualifiers.length > 0) {
        return storage.componentScan!T(locator, qualifiers[0].id);
    } else {
        return storage.componentScan!T(locator, name!T);
    }
}

/**
ditto
**/
auto componentScan(T)(ConfigurableContainer storage) {
    
    return storage.componentScan!T(storage);
}

/**
Register an object into storage by I's interface FQN that it implements using annotations provided in it.

An object will be registered in storage only in case when it is annotated with @component annotation. In case when no @component
annotation is found, object is not registered in storage.

Params:
    I = the inteface that object implements.
    T = type of object to be registered
    storage = the storage where to register the object
**/
auto componentScan(I, T)(Storage!(ObjectFactory, string) storage, Locator!() locator)
    if (is(I == interface) && is(T == class) && is(T : I)) {
    
    alias qualifiers = Filter!(
        isQualifier,
        allUDAs!I
    );
    
    static if (qualifiers.length > 0) {
        return storage.componentScan!T(locator, qualifier[0].id);
    } else {
        return storage.componentScan!T(locator, name!I);
    }
}

/**
ditto
**/
auto componentScan(I, T)(ConfigurableContainer storage)
    if (is(I == interface) && is(T == class) && is(T : I)) {
    
    return storage.componentScan!(I, T)(storage);
}

/**
Register a set of objects by it's type, or implemented interface into a storage.

When registering an object by it's interface, next to interface it is required to specify the original type of object.
Note: An object will be registered in storage only in case when it is annotated with @component annotation. In case when no @component
annotation is found, object is not registered in storage.

Params:
    I = the inteface that object implements.
    T = type of object to be registered
    storage = the storage where to register the object
**/
auto componentScan(T, V...)(Storage!(ObjectFactory, string) storage, Locator!() locator) {
    storage.componentScan!T(locator);
    
    return storage.componentScan!V(locator);
}

/**
ditto
**/
auto componentScan(T, V...)(ConfigurableContainer storage) {
    
    return storage.componentScan!(T, V)(storage);
}
    
/**
ditto
**/
auto componentScan(I, T, V...)(Storage!(ObjectFactory, string) storage, Locator!() locator)
    if (is(I == interface) && is(T == class) && is(T : I)) {
    storage.componentScan!(I, T)(locator);

    return storage.componentScan!(V)(locator);
}

/**
ditto
**/
auto componentScan(I, T, V...)(ConfigurableContainer storage)
    if (is(I == interface) && is(T == class) && is(T : I)) {
    
    return storage.componentScan!(I, T, V)(storage);
}

/**
Scan a module and register all public objects that are annotated with @component annotation.

Note: An object will be registered in storage only in case when it is annotated with @component annotation. In case when no @component
annotation is found, object is not registered in storage.

Params:
    Module = module to scan for components.
    storage = the storage where to register the object
    locator = the locator used to fetch registered object's dependencies.
**/
auto componentScan(alias Module)(Storage!(ObjectFactory, string) storage, Locator!() locator) 
    if (startsWith(Module.stringof, "module ")) {
    
    alias components = staticMap!(
        partialPrefixed!(
            getMember,
            Module
        ),
        Filter!(
            templateAnd!(
                partialSuffixed!(
                    partialPrefixed!(
                        isProtection,
                        Module
                    ),
                    "public"
                ),
                chain!(
                    isType,
                    partialPrefixed!(
                        getMember,
                        Module
                    )
                ),
                chain!(
                    isClass,
                    partialPrefixed!(
                        getMember,
                        Module
                    )
                )
            ),
            __traits(allMembers, Module)
        )
    );
    
    storage.componentScan!components(locator);
    
    return storage;
}

/**
ditto
**/
auto componentScan(alias M)(ConfigurableContainer storage)
    if (startsWith(M.stringof, "module")) {
    
    return storage.componentScan!(M)(storage);
}

/**
Scan a set of modules and register all public objects that are annotated with @component annotation.

Due to limitations of D language currently it is impossible to recursively scan all public imports of a module to register all 
depencies of a package. Each particular module should be specified in order to register dependencies.
Note: An object will be registered in storage only in case when it is annotated with @component annotation. In case when no @component
annotation is found, object is not registered in storage.

Params:
    M = current module to scan.
    V = rest set of modules waiting for scan.
    storage = the storage where to register the object
    locator = the locator used to fetch registered object's dependencies.
**/
auto componentScan(alias M, V...)(Storage!(ObjectFactory, string) storage, Locator!() locator)
    if (startsWith(M.stringof, "module")) {
    storage.componentScan!M(locator);
    return storage.componentScan!V(locator);
}

/**
ditto
**/
auto componentScan(alias M, V...)(ConfigurableContainer storage)
    if (startsWith(M.stringof, "module")) {
    
    return storage.componentScan!(M, V)(storage);
}

/**
Register an object into a storage contained in storageLocator and identified by @container annotation using annotations provided in it.

An object will be registered in storage only in case when it is annotated with @component annotation. In case when no @component
annotation is found, object is not registered in storage.

Params:
    T = type of object to be registered
    storageLocator = the locator from which to fetch storage for object
    locator = locator used to find dependencies for object
    id = identity by which object will be stored in storage
**/
auto componentScan(T, R : Locator!())(R storageLocator, Locator!() locator, string id) 
    if (!is(R : Storage!(ObjectFactory, string))) {
    
    alias containers = Filter!(
        isContained,
        allUDAs!T
    );
    
    static if (containers.length > 0) {
        string storageId = containers[0].id;
    } else {
        string storageId = "singleton";
    }
    
    auto storage = storageLocator.locate!(Storage!(ObjectFactory, string))(storageId);
    
    if (storage !is null) {
        
        storage.componentScan!T(locator, id);
    } else {
        
        throw new NotFoundException("Could not find storage to save factory for object of identity " ~ id);
    }
    
    return storageLocator;
}

/**
ditto
**/
auto componentScan(T, R : Locator!())(R locator, string id)
    if (!is(R : Storage!(ObjectFactory, string))) {
    return locator.componentScan!T(locator, id);
}

/**
ditto
**/
auto componentScan(T, R : Locator!())(R storageLocator, Locator!() locator)
    if (!is(R : Storage!(ObjectFactory, string))) {
    
    alias qualifiers = Filter!(
        isQualifier,
        allUDAs!T
    );
    
    static if (qualifiers.length > 0) {
        return storageLocator.componentScan!T(locator, qualifiers[0].id);
    } else {
        return storageLocator.componentScan!T(locator, name!T);
    }
}

/**
ditto
**/
auto componentScan(T, R : Locator!())(R locator)
    if (!is(R : Storage!(ObjectFactory, string))) {
    return locator.componentScan!T(locator);
}

/**
ditto
**/
template componentScan(T, V...)
    if((V.length > 0)) {
        
    /**
    ditto
    **/
    auto componentScan(R : Locator!())(R storageLocator, Locator!() locator) 
        if (!is(R : Storage!(ObjectFactory, string))) {
        .componentScan!T(storageLocator, locator);
        
        return .componentScan!V(storageLocator, locator);
    }
    
    /**
    ditto
    **/
    auto componentScan(R : Locator!())(R locator) 
        if (!is(R : Storage!(ObjectFactory, string))) {
        .componentScan!T(locator, locator);
        
        return .componentScan!V(locator, locator);
    }
}

/**
Register an object into a storage contained in storageLocator and identified by @container annotation using annotations provided in it.

An object will be registered in storage only in case when it is annotated with @component annotation. In case when no @component
annotation is found, object is not registered in storage.

Params:
    I = interface implemented by object, by which to register it.
    T = type of object to be registered
    storageLocator = locator used to find storage for object
    locator = locator used to find dependencies for object
**/
auto componentScan(I, T, R : Locator!())(R storageLocator, Locator!() locator)
    if (is (I == interface) && is (T == class) && is (T : I) && !is(R : Storage!(ObjectFactory, string))) {
    alias qualifiers = Filter!(
        isQualifier,
        allUDAs!I
    );
    
    static if (qualifiers.length > 0) {
        return storageLocator.componentScan!T(locator, qualifiers[0].id);
    } else {
        return storageLocator.componentScan!T(locator, name!I);
    }
}

/**
ditto
**/
auto componentScan(I, T, R : Locator!())(R locator)
    if (is (I == interface) && is (T == class) && is (T : I) && !is(R : Storage!(ObjectFactory, string))) {
    
    return locator.componentScan!(I, T)(locator);
}

/**
ditto
**/
template componentScan(I, T, V...) 
    if (is (I == interface) && is (T == class) && is (T : I) && (V.length > 0)) {
        
    /**
    ditto
    **/
    auto componentScan(R : Locator!())(R storageLocator, Locator!() locator)
        if (!is(R : Storage!(ObjectFactory, string))) {

        .componentScan!(I, T)(storageLocator, locator);
        
        return .componentScan!(V)(storageLocator, locator);
    }

    /**
    ditto
    **/
    auto componentScan(R : Locator!())(R locator)
        if (!is(R : Storage!(ObjectFactory, string))) {
        
        .componentScan!(I, T)(locator);
        
        return .componentScan!(V)(locator);
    }
}

/**
Register module's objects into a storage contained in storageLocator and identified by @container annotation using annotations provided in it.

An object will be registered in storage only in case when it is annotated with @component annotation. In case when no @component
annotation is found, object is not registered in storage.

Params:
    M = module to scan for instantiable objects.
    storageLocator = locator used to find storage for objects
    locator = locator used to find object dependencies
**/
auto componentScan(alias M, R : Locator!())(R storageLocator, Locator!() locator) 
    if (M.stringof.startsWith("module ") && !is(R : Storage!(ObjectFactory, string)))  {
    
    alias components = getPossibleComponents!M;
    
    storageLocator.componentScan!components(locator);
    
    return storageLocator;
}

/**
ditto
**/
auto componentScan(alias M, R : Locator!())(R locator) 
    if (M.stringof.startsWith("module ") && !is(R : Storage!(ObjectFactory, string)))  {
    
    locator.componentScan!M(locator);
    
    return locator;
}

/**
ditto
**/
template componentScan(alias M, V...) 
    if (M.stringof.startsWith("module ") && (V.length > 0)) {
        
    /**
    ditto
    **/
    auto componentScan(R : Locator!())(R locatorStorage, Locator!() locator)
        if (!is(R : Storage!(ObjectFactory, string))) {
        
        .componentScan!M(locatorStorage, locator);
        return .componentScan!V(locatorStorage, locator);
    }
        
    /**
    ditto
    **/
    auto componentScan(R : Locator!())(R locator)
        if (!is(R : Storage!(ObjectFactory, string))) {
        
        .componentScan!M(locator);
        return .componentScan!V(locator);
    }
}

/**
Checks if a structure has factory method for GenericFactory.

This static interface is used by annotation system to identify annotations that mark an object as instantiable by container.
The @component annotation is such a structure that implements this static interface and therefore it is possible to use it to 
mark components instantiable. A "@component" annotation must have a factory method that returns a GenericFactory instance that
further will be used to configure an instantiable object. In such a way it is possbile to define other custom annotations that
return GenericFactory implementations that add/or behave differrently comparing to default implementation of GenericFactory.

Examples:
--------------------
    struct Component {
        GenericFactory!T factory(T)(Locator!() locator) {
            return new GenericFactoryImpl!(T)(locator);
        }
    }
--------------------
Params:
    T = the structure to be tested for interface compatibility
    Z = the type of object that T has to instantiate
    
Returns:
    true in case of structure implementing static interface, false otherwise.
**/
template canFactoryGenericFactory(alias T, Z) 
    if (!isTemplate!T) {
    alias canFactoryGenericFactory = canFactoryGenericFactory!(typeof(T), Z);
}

/**
ditto
**/
template canFactoryGenericFactory(T, Z)
    if (isAggregateType!T) {

    static if (hasMember!(T, "factory")) {
        alias factory = getMember!(T, "factory");
        
        alias checker = templateOr!(
            chain!(
                partialPrefixed!(
                    isDerived,
                    ReturnType!(factory!Z)
                ),
                chain!(
                    GenericFactory,
                    Wrapper
                )
            ),
            chain!(
                partialPrefixed!(
                    isDerived,
                    ReturnType!(factory!Z)
                ),
                GenericFactory
            )
        );
        enum bool canFactoryGenericFactory = checker!Z;
    } else {
        
        enum bool canFactoryGenericFactory = false;
    }
}

/**
Checks if a structure has factoryContainer method for InstanceFactory.

This static interface is used to find annotations that can provide a InstanceFactory for GenericFactory to be used by it to instantiate
the object. The @constructor annotation implements this annotation and therefore it is possible to use it to mark a constructor to be used
for object construction. Any annotation implementing this interface can be used by annotation system to configure objects.

Examples:
--------------------
    struct SetterAnnotation(Args...) {
        Tuple!Args args;
        
        this(Args args) {
            this.args = args;
        }
        
        InstanceFactory!T factoryContainer(T, string property)(Locator!() locator) {
            auto constructor = new ConstructorBasedFactory!(T, Args)(args.expand);
            constructor.locator = locator;
            
            return constructor;
            
        }
    }
--------------------
Params:
    T = the structure to be tested for interface compatibility
    Z = the type of object that T has to instantiate
    
Returns:
    true in case of structure implementing static interface, false otherwise.
**/
template canFactoryInstanceFactory(alias T, Z, string property = "__ctor") {
    alias canFactoryInstanceFactory = canFactoryInstanceFactory!(typeof(T), Z, property);
}

/**
ditto
**/
template canFactoryInstanceFactory(T, Z, string property = "__ctor") {
    static if (hasMember!(T, "factoryContainer")) {
        alias factory = getMember!(T, "factoryContainer");
        
        alias checker = templateOr!(
            chain!(
                partialPrefixed!(
                    isDerived,
                    ReturnType!(factory!(Z, property))
                ),
                chain!(
                    InstanceFactory,
                    Wrapper
                )
            ),
            chain!(
                partialPrefixed!(
                    isDerived,
                    ReturnType!(factory!(Z, property))
                ),
                InstanceFactory
            )
        );
        enum bool canFactoryInstanceFactory = checker!Z;
    } else {
        
        enum bool canFactoryInstanceFactory = false;
    }
}

/**
Checks if a structure has factoryConfigurer method for PropertyConfigurer.

This static interface is used to find annotations that can provide a PropertyConfigurer for GenericFactory to be used by it to configure
the object. The @setter annotation implements this annotation and therefore it is possible to use it to mark a setter to be used
for object construction. Any annotation implementing this interface can be used by annotation system to configure objects.

Examples:
--------------------
    struct Setter(Args...) {
        Tuple!Args args;
        
        this(Args args) {
            this.args = args;
        }
        
        PropertyConfigurer!T factoryConfigurer(T, string method)(Locator!() locator) {
            auto method = new MethodConfigurer!(T, method, Args)(args.expand);
            method.locator = locator;
            
            return method;
        }
    }
--------------------
Params:
    T = the structure to be tested for interface compatibility
    Z = the type of object that T has to call T's property method
    property = the method of Z that T has to call
Returns:
    true in case of structure implementing static interface, false otherwise.
**/
template canFactoryPropertyConfigurer(alias T, Z, string property = "") {
    alias canFactoryPropertyConfigurer = canFactoryPropertyConfigurer!(typeof(T), Z, property);
}

/**
ditto
**/
template canFactoryPropertyConfigurer(T, Z, string property = "") {
    static if (hasMember!(T, "factoryConfigurer")) {
        alias factory = getMember!(T, "factoryConfigurer");

        alias checker = templateOr!(
            chain!(
                partialPrefixed!(
                    isDerived,
                    ReturnType!(factory!(Z, property))
                ),
                chain!(
                    PropertyConfigurer,
                    Wrapper
                )
            ),
            chain!(
                partialPrefixed!(
                    isDerived,
                    ReturnType!(factory!(Z, property))
                ),
                PropertyConfigurer
            )
        );
        enum bool canFactoryPropertyConfigurer = checker!Z;
    } else {
        
        enum bool canFactoryPropertyConfigurer = false;
    }
}

public auto componentScanImpl(T)(Locator!() locator) {
    debug {
        pragma(msg, "Scanning ", fullyQualifiedName!T);
    }
    
    alias Components = Filter!(
        partialSuffixed!(
            canFactoryGenericFactory,
            T
        ),
        allUDAs!T
    );
    
    static if (Components.length > 0) {
        auto factory = toValue!(Components[0]).factory!T(locator);
        
        debug {
            pragma(msg, "Found component");
        }
        
        alias constructorUdas = Filter!(
            partialSuffixed!(
                canFactoryInstanceFactory,
                T
            ),
            allUDAs!T
        );
        
        alias configurerUdas = Filter!(
            partialSuffixed!(
                canFactoryPropertyConfigurer,
                T
            ),
            allUDAs!T
        );
        
        foreach (configurer; tuple(staticMap!(toValue, configurerUdas))) {
            debug {
                pragma(msg, "Found configurer ", name!configurer, " on ", name!T, " declaration");
            }
            
            factory.addPropertyConfigurer(configurer.factoryConfigurer!(T, "")(locator));
        }
        
        static if (constructorUdas.length > 0) {
            debug {
                pragma(msg, "Found constructor right on ", name!T);
            }
            
            factory.setInstanceFactory(toValue!(constructorUdas[0]).factoryContainer!(T, name!T)(locator));
        } else {
            alias instantiatorHolders = Filter!(
                templateAnd!(
                    partialSuffixed!(
                        partialPrefixed!(
                            isProtection,
                            T
                        ),
                        "public"
                    ),
                    eq!"__ctor",
                    chain!(
                        isSomeFunction,
                        partialPrefixed!(
                            getMember,
                            T
                        )
                    )
                ),
                __traits(allMembers, T)
            );
            
            foreach (instantiatorHolder; instantiatorHolders) {
                foreach (overload; __traits(getOverloads, T, instantiatorHolder)) {
                    alias udas = Filter!(
                        partialSuffixed!(
                            canFactoryInstanceFactory,
                            T
                        ),
                        allUDAs!overload
                    );
                    
                    static if (udas.length > 0) {
                        debug {
                            pragma(msg, "Found custom constructor for ", name!T, " on ", instantiatorHolder, " with arguments ", Parameters!overload);
                        }
                        
                        factory.setInstanceFactory(toValue!(udas[0]).factoryContainer!(T, instantiatorHolder)(locator));
                    }
                }
            }
        }
        
        alias configurerHolders = Filter!(
            templateAnd!(
                partialSuffixed!(
                    partialPrefixed!(
                        isProtection,
                        T
                    ),
                    "public"
                ),
                templateNot!(eq!"__ctor")
            ),
            __traits(allMembers, T)
        );
        
        foreach (member; configurerHolders) {
            
            static if (isSomeFunction!(getMember!(T, member))) {
                foreach (overload; __traits(getOverloads, T, member)) {
                    alias udas = Filter!(
                        partialSuffixed!(
                            canFactoryPropertyConfigurer,
                            T,
                            member
                        ),
                        allUDAs!overload
                    );
                    
                    foreach (uda; tuple(staticMap!(toValue, udas))) {
                        debug {
                            pragma(msg, "Found configurer ", name!uda, " for ", name!T, "'s method ", member);
                        }
                        
                        factory.addPropertyConfigurer(uda.factoryConfigurer!(T, member)(locator));
                    }
                }
            } else static if (isField!(T, member)) {
                
                alias udas = Filter!(
                    partialSuffixed!(
                        canFactoryPropertyConfigurer,
                        T,
                        member
                    ),
                    allUDAs!(getMember!(T, member))
                );
                
                foreach (uda; tuple(staticMap!(toValue, udas))) {
                    debug {
                        pragma(msg, "Found configurer ", name!uda, " for ", name!T, "'s field ", member);
                    }
                    
                    factory.addPropertyConfigurer(uda.factoryConfigurer!(T, member)(locator));
                }
            }
        }

        return factory;
    } else {
        debug {
            pragma(msg, "Not a component");
        }
        
        return null;
    }
}

private template isQualifier(alias T) {
    alias isQualifier = isQualifier!(typeof(T));
}

private template isQualifier(T) {
    enum bool isQualifier = is(T == QualifierAnnotation);
}

private template isContained(alias T) {
    alias isContained = isContained!(typeof(T));
}

private template isContained(T) {
    enum bool isContained = is(T == ContainedAnnotation);
}

private template isValue(T) {
    enum bool isValue = is (typeof(T));
}

private template isReturnTypeEq(alias symbol, Type)
    if (isSomeFunction!symbol) {
    enum bool isReturnTypeEq = is(ReturnType!symbol : Type);
}

private template isNamedTemplate(alias T, string name) {
    enum bool isNamedTemplate = isTemplate!T && (identifier!T == name);
}

private template isEqByFQDN(alias first, alias second) {
    enum bool isEqByFQDN = fullyQualifiedName!first == fullyQualifiedName!second;
}

private template instantiatonToTemplate(alias T, alias Template = T) {
    static if (isTemplateInstantiationOf!(T, Template)) {
        alias instantiatonToTemplate = Template;
    } else static if (isTemplate!T) {
        alias instantiatonToTemplate = T;
    }
}

private enum bool isTemplateInstantiationOf(T, alias Template) = is(T : Template!(Z), Z...);
private enum bool isTemplateInstantiationOf(alias T, alias Template) = is(typeof(T) : Template!(Z), Z...);

private template identifierEq(alias T, string identity) {
    enum bool identifierEq = identifier!T == identity;
}

private template allUDAs(alias symbol) {
    alias allUDAs = AliasSeq!(__traits(getAttributes, symbol));
}

private template toValue(T) {
    enum auto toValue = T();
}

private template toValue(alias T) {
    alias toValue = T;
}

private template isType(alias T) {
    static if (__traits(compiles, () { T z = T.init; })) {
        
        enum bool isType = true;
    } else {
    
        enum bool isType = false;
    }
}

private template isClass(alias T) {
    enum bool isClass = is(typeof(T) == class);
}

private template isClass(T) {
    enum bool isClass = is(T == class);
}

private template isStruct(alias T) {
    enum bool isStruct = is(typeof(T) == struct);
}

private template isStruct(T) {
    enum bool isStruct = is(T == struct);
}

private template getPublicAggregateMembers(alias Symbol) {
    alias getPublicAggregateMembers = Filter!(
        templateAnd!(
            partialSuffixed!(
                partialPrefixed!(
                    isProtection,
                    Symbol
                ),
                "public"
            ),
            chain!(
                hasMembers,
                partialPrefixed!(
                    getMember,
                    Symbol
                )
            )
        ),
        __traits(allMembers, Symbol)
    );
}

private template getPossibleComponents(alias Symbol) {
    alias getPossibleComponents = staticMap!(
        partialPrefixed!(
            getMember,
            Symbol
        ),
        Filter!(
            templateAnd!(
                partialSuffixed!(
                    partialPrefixed!(
                        isProtection,
                        Symbol
                    ),
                    "public"
                ),
                chain!(
                    isType,
                    partialPrefixed!(
                        getMember,
                        Symbol
                    )
                ),
                chain!(
                    templateOr!(
                        isClass,
                        isStruct
                    ),
                    partialPrefixed!(
                        getMember,
                        Symbol
                    )
                )
            ),
            __traits(allMembers, Symbol)
        )
    );
}