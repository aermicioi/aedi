/**
Provides annotation based configuration and registration for components.

License:
	Boost Software License - Version 1.0 - August 17th, 2003

	Permission is hereby granted, free of charge, to any person or organization
	obtaining a copy of the software and accompanying documentation covered by
	this license (the "Software") to use, reproduce, display, distribute,
	execute, and transmit the Software, and to prepare derivative works of the
	Software, and to permit third-parties to whom the Software is furnished to
	do so, all subject to the following:

	The copyright notices in the Software and this entire statement, including
	the above license grant, this restriction and the following disclaimer,
	must be included in all copies of the Software, in whole or in part, and
	all derivative works of the Software, unless such copies or derivative
	works are solely in the form of machine-executable object code generated by
	a source language processor.

	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
	SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
	FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
	ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
	DEALINGS IN THE SOFTWARE.

Authors:
	aermicioi
**/
module aermicioi.aedi.configurer.annotation.component_scan;

import aermicioi.aedi.configurer.annotation.annotation;
import aermicioi.aedi.storage.locator;
import aermicioi.aedi.storage.storage;
import aermicioi.aedi.storage.wrapper;
import aermicioi.aedi.container.container;
import aermicioi.aedi.factory.factory;
import aermicioi.aedi.factory.reference;
import aermicioi.aedi.factory.generic_factory;
import aermicioi.aedi.factory.proxy_factory;
import aermicioi.aedi.exception;
import aermicioi.aedi.util.traits;
import aermicioi.aedi.factory.wrapping_factory : WrappingFactory;

import std.traits;
import std.meta;
import std.typecons;
import std.conv : to;
import std.algorithm;

/**
Check if a type T is a factory policy.

Check if a type T is a factory policy.
A factory policy is a policy that based on type X, can
create a factory for type X.
**/
enum bool isFactoryPolicy(T, X = Object) = is(T == struct) && is(typeof(&T.createFactory!X) : Z function(Locator!()), Z : Factory!X);

/**
Check if a type T is a configurator policy.

Check if a type T is a configurator policy.
A configurator policy is a policy that given a type
X can create InstanceFactory, InstanceDestructor, or PropertyConfigurer
instances and add them to a factory that implements GenericFactory!X interface, as well
as modify other properties exposed by GenericFactory!X interface.
**/
enum bool isConfiguratorPolicy(T, X : GenericFactory!Z = GenericFactory!Object, Z) =
    is(T == struct) &&
    is(typeof(&T.configure!(X)) : void function(M, Locator!()), M : X);

/**
Create a GenericFactory!T if T is annotated with @component annotation.
**/
@safe struct GenericFactoryPolicy {

    private alias getComponents(alias T) = Filter!(
            isComponentAnnotation,
            allUDAs!T
        );

    /**
    Create a GenericFactory!T if T is annotated with @component annotation.

    Params:
        locator = locator used by factory to fetch it's dependencies

    Returns:
        GenericFactory!T
    **/
    static GenericFactory!T createFactory(T)(Locator!() locator) {
        alias Component = getComponents!T;

        static if (Component.length > 0) {
            debug(annotationScanDebug) pragma(msg, "Creating factory for component ", T);
            return new GenericFactoryImpl!T(locator);
        } else {

            return null;
        }
    }
}

/**
A factory policy that uses annotations implementing factory policy interface on component to instantiate the component.
**/
@safe struct GenericFactoryAnnotationPolicy {

    private alias getGenericFactoryPolicies(T, X) = Filter!(
        chain!(
            ApplyRight!(isFactoryPolicy, X),
            toType
        ),
        allUDAs!T
    );

    /**
    Create a component factory for T using annotations on it that implement factory policy interface.

    Params:
        locator = locator of components used by component factory

    Returns:
        A component factory
    **/
    static GenericFactory!T createFactory(T)(Locator!() locator) {

        alias FactoryPolicies = getGenericFactoryPolicies!(T, T);

        foreach (FactoryPolicy; tuple(FactoryPolicies)) {
            auto factory = FactoryPolicy.createFactory!T(locator);

            if (factory !is null) {
                return factory;
            }
        }

        return null;
    }
}

/**
A factory policy that applies in order a set of factory policies to create component factory.
**/
@safe struct FallbackFactoryPolicy(FactoryPolicies...)
    if (allSatisfy!(isFactoryPolicy, FactoryPolicies)) {

    /**
    Create component factory using one of supplied factory policies

    Params:
        locator = locator of components used by component factory

    Returns:
        A component factory, from the first factory policy that returned an instance
    **/
    static GenericFactory!T createFactory(T)(Locator!() locator) {

        foreach (FactoryPolicy; FactoryPolicies) {
            auto factory = FactoryPolicy.createFactory!T(locator);

            if (factory !is null) {
                return factory;
            }
        }

        return null;
    }
}

/**
Chain a set of configurator policies.
**/
@safe struct ChainedConfiguratorPolicy(ConfiguratorPolicies...)
    if (allSatisfy!(isConfiguratorPolicy, ConfiguratorPolicies)) {

    /**
    Run ConfiguratorPolicies on instantiator in sequential manner

    Params:
        instantiator = factory which is configured by ConfiguratorPolicies
        locator = locator used by factory

    **/
    static void configure(T : GenericFactory!Z, Z)(T instantiator, Locator!() locator) {

        foreach (policy; ConfiguratorPolicies) {
            policy.configure(instantiator, locator);
        }
    }
}

/**
Set allocator used by factory to instantiate component T.
**/
@safe struct AllocatorConfiguratorPolicy {

    private alias getAllocators(alias T) = Filter!(
            isAllocatorAnnotation,
            allUDAs!T
        );

    /**
    Set allocator from @allocator annotation into GenericFactory!Z.

    Params:
        instantiator = factory which is set allocator from @allocator annotation
        locator = locator used by factory
    **/
    static void configure(T : GenericFactory!Z, Z)(T instantiator, Locator!() locator) {

        static foreach (Allocator; getAllocators!Z) {
            debug(annotationScanDebug) pragma(msg, "Found custom allocator for ", Z, " provisioning with ", typeof(Allocator.allocator));
            instantiator.allocator = Allocator.iallocator;
        }
    }
}

/**
Set callback instance factory from @callbac annotation into GenericFactory!Z
**/
@safe struct CallbackFactoryConfiguratorPolicy {
    private alias getCallbackFactories(alias T) = Filter!(
            isCallbackFactoryAnnotation,
            allUDAs!T
        );

    /**
    Set callback instance factory from @callback annotation into GenericFactory!Z.

    Params:
        instantiator = factory which is set callback instance factory from @callback annotation
        locator = locator used by factory
    **/
    static void configure(T : GenericFactory!Z, Z)(T instantiator, Locator!() locator) {

        foreach (CallbackFactory; tuple(getCallbackFactories!Z)) {
            debug(annotationScanDebug) pragma(msg,
                "Found callback factory for ",
                Z,
                " provisioning with ",
                typeof(CallbackFactory.dg),
                "(",
                typeof(CallbackFactory.args),
                ")"
            );
            instantiator.setInstanceFactory(callbackFactory(CallbackFactory.dg, CallbackFactory.args));
        }
    }
}

/**
Set value factory that takes component from @value annotation and provides it as a new component.
**/
@safe struct ValueFactoryConfiguratorPolicy {
    private alias getValueFactories(alias T) = Filter!(
            isValueAnnotation,
            allUDAs!T
        );

    /**
    Set value factory that takes component from @value annotation and provides it as a new component.

    Params:
        instantiator = factory which is set value instance factory from @value annotation
        locator = locator used by factory
    **/
    static void configure(T : GenericFactory!Z, Z)(T instantiator, Locator!() locator) {
        foreach (ValueAnnotation; tuple(getValueFactories!Z)) {
            debug(annotationScanDebug) pragma(msg,
                "Found value factory for ",
                Z,
                " provisioning with ",
                typeof(ValueAnnotation.value)
            );
            instantiator.setInstanceFactory(new ValueInstanceFactory!Z(ValueAnnotation.value));
        }
    }
}

/**
A policy that uses annotations that implement isConfigurerPolicy interface to configure the component factory
**/
@safe struct GenericConfigurerConfiguratorPolicy {
    private alias getGenerics(alias T, X) = Filter!(
                chain!(
                    ApplyRight!(isConfiguratorPolicy, X),
                    toType
                ),
                allUDAs!T
            );

    /**
    Scans for annotations implementing isConfigurerPolicy interface and uses them to configure component factory.

    Params:
        instantiator = factory upon which isConfigurerPolicy annotations are applied
        locator = locator used by factory
    **/
    static void configure(T : GenericFactory!Z, Z)(T instantiator, Locator!() locator) {
        foreach (Generic; tuple(getGenerics!(Z, T))) {
            debug(annotationScanDebug) pragma(msg, "Found annotation implementing configurer annotation contract ", typeof(Generic), " applying to ", Z, " factory");
            Generic.configure!(T)(instantiator, locator);
        }
    }
}

/**
A policy that configures factory to use callback to destroy created components.
**/
@safe struct CallbackDestructorConfigurerPolicy {
    private alias getCallbackDestructors(alias T, X) = Filter!(
        chain!(
            ApplyRight!(isCallbackDestructor, X),
            toType
        ),
        allUDAs!T
    );

    /**
    Configure instantiator to use callback for destruction of components

    Params:
        instantiator = component factory
        locator = container for component's dependencies
        Z = type of component created
    **/
    static void configure(T : GenericFactory!Z, Z)(T instantiator, Locator!() locator) {

        foreach (CallbackDestructor; tuple!(getCallbackDestructors!(Z, T))) {
            debug(annotationsScanDebug) pragma(msg, "Found callback destructor for " ~ fullyQualifiedName!Z);
            instantiator.setInstanceDestructor(callbackDestructor(CallbackDestructor.dg, CallbackDestructor.args));
        }
    }
}

/**
A dummy structure that is providing a simple field for isFieldConfiguratorPolicy interface for testing purposes of configurator templates.
**/
struct ConfiguredFieldTester {

    /**
    Dummy field
    **/
    int field;
}

/**
A dummy structure that is providing a simple method for isMethodConfiguratorPolicy interface for testing purposes of configurator templates.
**/
struct ConfiguredMethodTester {

    /**
    Dummy method
    **/
    void method(int x) {}
}

/**
Check if T is a field configurator policy that operates upon fields of a component.

Params:
    T = the type that is tested for field configurator policy interface
    member = member field of constructed component by GenericFactory!Z
    X = a factory for a component, on which policy can operate
Returns:
    true if it is compliant, false otherwise
**/
enum bool isFieldConfiguratorPolicy(T, string member = "field", X : GenericFactory!Z = GenericFactory!ConfiguredFieldTester, Z) =
    is(T == struct) &&
    is(typeof(&T.configureField!(member, X)) : void function(X, Locator!()));

/**
Check if T is a field configurator policy that operates upon methods of a component.

Params:
    T = the type that is tested for field configurator policy interface
    member = member field of constructed component by GenericFactory!Z
    X = a factory for a component, on which policy can operate

Returns:
    true if it is compliant, false otherwise
**/
enum bool isMethodConfiguratorPolicy(T, string member = "method", X : GenericFactory!Z = GenericFactory!ConfiguredMethodTester, Z) =
    is(T == struct) &&
    is(typeof(&T.configureMethod!(member, X)) : void function(X, Locator!()));

/**
Configurator policy that applies method configurator policies on all public methods of a component
**/
@safe struct MethodScanningConfiguratorPolicy(MethodConfiguratorPolicies...)
    if (allSatisfy!(isMethodConfiguratorPolicy, MethodConfiguratorPolicies)) {

    /**
    Apply a set of method configurator policies on all public methods of component Z

    Params:
        Z = component which will have it's methods scanned, including overloads.
        instantiator = Z component factory
        locator = locator used by method configurator policies
    **/
    static void configure(T : GenericFactory!Z, Z)(T instantiator, Locator!() locator) {
        foreach (member; __traits(allMembers, Z)) {
            static if ((getProtection!(Z, member) == "public") && isSomeFunction!(__traits(getMember, Z, member))) {
                foreach (methodConfigurer; MethodConfiguratorPolicies) {
                    methodConfigurer.configureMethod!member(instantiator, locator);
                }
            }
        }
    }
}

/**
Configurator policy that applies field configurator policies on all public methods of a component
**/
@safe struct FieldScanningConfiguratorPolicy(FieldConfiguratorPolicies...)
    if (allSatisfy!(isFieldConfiguratorPolicy, FieldConfiguratorPolicies)) {

    /**
    Apply a set of field configurator policies on all public fields of component Z

    Params:
        Z = component which will have it's methods scanned, including overloads.
        instantiator = Z component factory
        locator = locator used by method configurator policies
    **/
    static void configure(T : GenericFactory!Z, Z)(T instantiator, Locator!() locator) {
        foreach (member; __traits(allMembers, Z)) {
            static if (isField!(Z, member) && (getProtection!(Z, member) == "public")) {
                foreach (fieldConfigurer; FieldConfiguratorPolicies) {
                    fieldConfigurer.configureField!member(instantiator, locator);
                }
            }
        }
    }
}

/**
Method configurator policy that scans only constructors for @constructor annotation, for using them to instantiate component Z
**/
@safe struct ConstructorMethodConfiguratorPolicy {

    /**
    Checks if scanned method is a constructor and has @constructor annotation, and sets it to be used to construct component if so.

    Params:
        Z = component type
        member = member that should be scanned, only constructors are taken into account
        instantiator = Z component factory, which policy will set constructor to be used to construct component if possible
        locator = locator used to supply dependencies into constructor of component
    **/
    static void configureMethod(string member, T : GenericFactory!Z, Z)(T instantiator, Locator!() locator) {

        static if (member == "__ctor") {
            foreach (overload; __traits(getOverloads, Z, member)) {


                alias Configurers = Filter!(
                    isConstructorAnnotation,
                    allUDAs!(overload)
                );

                foreach (Configurer; tuple(staticMap!(toValue, Configurers))) {
                    debug(annotationScanDebug) pragma(msg, "Found elaborate constructor for ", Z, " provisioning with ", toType!Configurer);
                    instantiator.setInstanceFactory(
                        constructorBasedFactory!Z(Configurer.args)
                    );
                }
            }
        }
    }
}

/**
Method policy that scans constructors for @autowired annotation to use them to construct component with dependencies identified by qualifier, name or their type.
**/
@safe struct AutowiredConstructorMethodConfiguratorPolicy {

    /**
    Configures instantiator to use @autowired constructor method, to construct the component.

    Params:
        Z = component type
        member = method that is scanned. Only constructors are taken into account
        instantiator = component constructor
        locator = locator for component dependencies
    **/
    static void configureMethod(string member, T : GenericFactory!Z, Z)(T instantiator, Locator!() locator) {

        static if (member == "__ctor") {
            foreach (overload; __traits(getOverloads, Z, member)) {

                alias Configurers = Filter!(
                    isAutowiredAnnotation,
                    allUDAs!(overload)
                );

                foreach (Configurer; tuple(staticMap!(toValue, Configurers))) {
                    debug(annotationScanDebug) pragma(msg, "Autowiring constructor of ", Z, " with arguments ", Parameters!(overload));

                    instantiator.setInstanceFactory(
                        constructorBasedFactory!Z(makeAutowireReferences!overload.expand)
                    );
                }
            }
        }
    }
}

/**
Field configurator policy that will set a field annotated @setter annotation to value contained in it.
**/
@safe struct SetterFieldConfiguratorPolicy {

    /**
    Configures instantiator to inject into field a predefined value or a dependency from @setter annotation

    Params:
        Z = component type
        member = field member of component
        instantiator = component factory
        locator = locator for component dependencies
    **/
    static void configureField(string member, T : GenericFactory!Z, Z)(T instantiator, Locator!() locator) {

        alias Configurers = Filter!(
            isSetterAnnotation,
            allUDAs!(__traits(getMember, Z, member))
        );

        foreach (Configurer; tuple(staticMap!(toValue, Configurers))) {
            debug(annotationScanDebug) pragma(msg, "Setting field ", member, " of ", Z, " to ", staticMap!(toType, Configurer.args));
            instantiator.addPropertyConfigurer(fieldConfigurer!(member, Z)(Configurer.args));
        }
    }
}

/**
Field configurator policy that will set a field to value returned by a callback in @callback annotation
**/
@safe struct CallbackFieldConfiguratorPolicy {

    /**
    Configure instantiator to inject return value of callback from @callback annotation into field

    Params:
        member = field that will be injected
        Z = component type
        instantiator = component factory
        locator = locator for component dependencies
    **/
    static void configureField(string member, T : GenericFactory!Z, Z)(T instantiator, Locator!() locator) {

        alias Callbacks = Filter!(
            isCallbackConfigurerAnnotation,
            allUDAs!(__traits(getMember, Z, member))
        );

        foreach (Callback; tuple(staticMap!(toValue, Callbacks))) {
            debug(annotationScanDebug) pragma(msg, "Calling callback on field ", member, " of ", Z, " to ", staticMap!(toType, Callback.args));
            instantiator.addPropertyConfigurer(callbackConfigurer!Z(Callback.dg, Callback.args));
        }
    }
}

/**
Field configurator policy that will try to inject a dependency that matches fields type for fields that are annotated with @autowired annotation
**/
@safe struct AutowiredFieldConfiguratorPolicy {

    /**
    Configure instantiator to inject into field a component identified by field's type if field has @autowired annotation.

    Params:
        member = field that will be injected
        Z = component type
        instantiator = component factory
        locator = locator for component dependencies
    **/
    static void configureField(string member, T : GenericFactory!Z, Z)(T instantiator, Locator!() locator) {
        alias field = AliasSeq!(__traits(getMember, Z, member));

        alias Callbacks = Filter!(
            isAutowiredAnnotation,
            allUDAs!(field)
        );

        foreach (Callback; tuple(staticMap!(toValue, Callbacks))) {
            debug(annotationScanDebug) pragma(msg, "Autowiring field ", member, " of ", Z, " to ", typeof(getMember!(Z, member)));

            RuntimeReference reference = __traits(identifier, field).lref.alternate(lref!(typeof(field)));

            alias qualifiers = Filter!(
                isQualifierAnnotation,
                allUDAs!(field)
            );

            static foreach (qualifier; qualifiers) {
                reference = qualifier.id.lref.alternate(reference);
            }

            instantiator.addPropertyConfigurer(fieldConfigurer!(member, Z)(reference));
        }
    }
}

/**
Method configurator policy that will call a method with resolved arguments from @setter annotation.
**/
@safe struct SetterMethodConfiguratorPolicy {

    /**
    Configure instantiator to call @setter annotated method with arguments from annotation

    Params:
        Z = component type
        member = method that would be called by factory
        instantiator = component factory
        locator = locator for component dependencies
    **/
    static void configureMethod(string member, T : GenericFactory!Z, Z)(T instantiator, Locator!() locator) {

        foreach (overload; __traits(getOverloads, Z, member)) {

            alias Configurers = Filter!(
                isSetterAnnotation,
                allUDAs!(overload)
            );

            foreach (Configurer; tuple(staticMap!(toValue, Configurers))) {
                debug(annotationScanDebug) pragma(msg, "Calling method ", member, " of ", Z, " with ", staticMap!(toType, Configurer.args));
                instantiator.addPropertyConfigurer(methodConfigurer!(member, Z)(Configurer.args));
            }
        }
    }
}

/**
Method configurator policy that will call callback from @callback annotated methods.
**/
@safe struct CallbackMethodConfiguratorPolicy {

    /**
    Configre instantiator to call callback from @callback annotation with arguments that are stored in annotation

    Params:
        Z = component type
        member = method which is annotated with @callback. It is supposed that callback will use it somehow in logic.
        instantiator = component factory
        locator = locator for component dependencies
    **/
    static void configureMethod(string member, T : GenericFactory!Z, Z)(T instantiator, Locator!() locator) {

        foreach (overload; __traits(getOverloads, Z, member)) {

            alias Configurers = Filter!(
                isCallbackConfigurerAnnotation,
                allUDAs!(overload)
            );

            foreach (Configurer; tuple(staticMap!(toValue, Configurers))) {
                debug(annotationScanDebug) pragma(msg, "Calling callback on method ", member, " of ", Z, " with ", staticMap!(toType, Configurer.args));
                instantiator.addPropertyConfigurer(callbackConfigurer!Z(Configurer.dg, Configurer.args));
            }
        }
    }
}

/**
Method configurator policy that will call method annotated with @autowire with arguments extracted from locator identified by qualifier, name or their type.
**/
@safe struct AutowiredMethodConfiguratorPolicy {

    /**
    Configure instantiator to call a method annotated with @autowired with arguments extracted from locator

    Params:
        Z = component type
        member = method that is annotated with @autowired annotation
        instantiator = component factory
        locator = locator for component dependencies
    **/
    static void configureMethod(string member, T : GenericFactory!Z, Z)(T instantiator, Locator!() locator) {
        static if (member != "__ctor") {
            foreach (overload; __traits(getOverloads, Z, member)) {

                alias Configurers = Filter!(
                    isAutowiredAnnotation,
                    allUDAs!(overload)
                );

                foreach (Configurer; tuple(staticMap!(toValue, Configurers))) {

                    debug(annotationScanDebug) pragma(msg, "Calling method ", member, " of ", Z, " with autowired ", Parameters!overload);

                    instantiator.addPropertyConfigurer(methodConfigurer!(member, Z)(makeAutowireReferences!overload.expand));
                }
            }
        }
    }
}

/**
Check if a policy implements transformer interface.

A transformer is a policy that takes a type, and optionally a member of it, and transform it
into a component factory using annotations from component, or member.

Params:
    T = type to be tested for interface implementation
    X = a test object that is used to test templated methods of policy
Returns:
    true if it implements Transformer interface, false otherwise
**/
enum bool isTransformer(T, X = Object) = is(T == struct) && is(typeof(&T.transform!X) : void function (Locator!(), Storage!(ObjectFactory, string)));

/**
A transformer that creates out of a type a GenericFactory for passed type
**/
@safe struct TypeTransformer(FactoryPolicy, ConfigurerPolicy)
    if (isFactoryPolicy!FactoryPolicy && isConfiguratorPolicy!ConfigurerPolicy) {

    /**
    Transform type T into a GenericFactory!T

    Params:
        T = type which is transformed into it's factory
        locator = locator for T's dependencies
    Returns:
        instance of GenericFactory!T, or null if T is not transformable into a factory
    **/
    static auto transform(T)(Locator!() locator)
        if (is(T)) {
        auto instantiator = FactoryPolicy.createFactory!T(locator);

        if (instantiator is null) {
            return instantiator;
        }

        ConfigurerPolicy.configure(instantiator, locator);

        return instantiator;
    }
}

/**
Transformer that wraps results of another transformer in WrappingFactory
**/
@safe struct ObjectFactoryTransformer(TransformerPolicy) {

    /**
    Wrap up results of another transformer into WrappingFactory

    Params:
        T = type of component that is transformed

    Returns:
        null if T is not transformable, or instance of WrappingFactory that wraps result of TransformerPolicy
    **/
    static auto transform(T)(Locator!() locator)
        if (is(T)) {

        auto instantiator = TransformerPolicy.transform!T(locator);

        if (instantiator is null) {
            return cast(WrappingFactory!(typeof(instantiator))) null;
        }

        return new WrappingFactory!(typeof(instantiator))(instantiator);
    }
}

/**
Check if T implements ContainerAdder interface.

A ContainerAdder is component that is responsible to scan
a symbol for it's members, transform them using passed Transformers,
and add them to storage.

Params:
    T = component that is tested for ContainerAdder interface.
    X = a dummy symbol used to test templated methods of component

Note:
    Due to possibility to store any kind of symbol in X (not only types),
    the use of this checker is limited in use for generic testing.
    Ex. ContainerAdder for modules and types are technically different interfaces
    and will fail the checker when are tested both with same X argument
    (module is not a type), though they are conceptually the same.
Returns:
    true if it implements ContainerAdder interface, false otherwise
**/
enum bool isContainerAdder(T, alias X = Object) =
    is(T == struct) &&
    is(typeof(&T.scan!X) : V function (X, Y), X : Locator!(), Y : Storage!(Factory!Object, string), V);

/**
Check if T implements component storing interface.

The responsibility of component storing policy is to
store component's factory into appropiate storage,
by apropiate identity, using information about type T.

Params:
    T = type that is tested for interface compliance
    X = component type against which T's templates are tested to comply to interface
Returns:
    true if it implements the interface, false otherwise
**/
enum bool isComponentStoringPolicy(T, X = Object) =
    is(T == struct) &&
    is(
        typeof(&T.store!X) : void function (F, Locator!(), S),
        F : Factory!Z,
        Z,
        S : Storage!(Factory!Z, string)
    );


/**
A default implementation of component storing policy that looks for @qualifier and @contained annotations to store component factory.
**/
@safe struct ComponentStoringPolicyImpl {

    /**
    Store component factory into storage.

    Store component factory into storage. The storage where component is stored
    on presence of @contained annotation on T, will be extracted from locator, otherwise
    storage passed as argument is used. The identity of component by default is
    it's type FQN, but is overriden by @qualifier annotation.

    Params:
        factory = component factory to be stored
        locator = locator that is used to fetch storage in case of @contained annotation
        storage = storage were component is stored when no @contained annotation is provided
    **/
    static void store(T)(Factory!Object factory, Locator!() locator, Storage!(Factory!Object, string) storage) {

        string identity = fullyQualifiedName!T;
        alias Qualifiers = Filter!(
            isQualifierAnnotation,
            allUDAs!T
        );

        foreach (Qualifier; Qualifiers) {
            debug(annotationScanDebug) pragma(msg, "Found custom identity for ", fullyQualifiedName!T, " ", Qualifier.id);
            identity = Qualifier.id;
        }

        alias ContainedAnnotations = Filter!(
            isContainedAnnotation,
            allUDAs!T
        );

        foreach (ContainedAnnotation; ContainedAnnotations) {
            debug(annotationScanDebug) pragma(msg, "Found custom storage to be used to store component ", fullyQualifiedName!T, " ", ContainedAnnotation.id);
            storage = locator.locate!(Storage!(Factory!Object, string))(ContainedAnnotation.id);
        }

        storage.set(factory, identity);
    }
}

/**
ContainerAdder that chains a set of ContainerAdders on a symbol.
**/
@safe struct ChainedContainerAdder(ContainerAdderPolicies...) {
    import aermicioi.aedi.util.traits : getMember;

    /**
    Check if at least one ContainerAdder supports passed symbol

    Params:
        T = symbol that at least one ContainerAdder, must know how to scan
    Returns:
        true if at least one ContainerAdder knows how to scan symbol, false otherwise
    **/
    enum bool isSupported(alias T) = anySatisfied!(T, staticMap!(ApplyRight!(getMember, "isSupported"), ContainerAdderPolicies));

    /**
    Apply all ContainerAdders that know how to scan T symbol

    Params:
        T = symbol to be scanned
        locator = locator of components, used by transformer that is applied on members of scanned T symbol
        storage = the storage that will store component factories from transformed members of T symbol
    **/
    static void scan(alias T)(Locator!() locator, Storage!(ObjectFactory, string) storage)
        if (isSupported!T) {
        foreach (ContainerAdderPolicy; ContainerAdderPolicies) {

            static if (ContainerAdderPolicy.isSupported!T) {
                ContainerAdderPolicy.scan!T(locator, storage);
            }
        }
    }
}

/**
Applies a transformer on passed symbol if it is a type.
**/
@safe struct TypeContainerAdder(TypeTransformerPolicy, ComponentStoringPolicy = ComponentStoringPolicyImpl)
    if (isComponentStoringPolicy!ComponentStoringPolicy) {

    /**
    Check if symbol T is a type definition.

    Params:
        T = symbol to be tested
    Returns:
        true if it is a type, false otherwise
    **/
    enum bool isSupported(alias T) = is(T);

    /**
    Transform T component into a factory using TypeTransformerPolicy

    Params:
        T = component type
        locator = component locator used by transformed component factory
        storage = storage wich will contain component factory transformed out of T
    **/
    static void scan(T)(Locator!() locator, Storage!(ObjectFactory, string) storage)
        if (isSupported!T) {

        auto transformed = TypeTransformerPolicy.transform!T(locator);

        if (transformed is null) {
            return;
        }

        ComponentStoringPolicy.store!T(transformed, locator, storage);
    }
}

/**
ContainerAdder that scans a type for inner static types, to transform and store into a storage.
**/
@safe struct InnerTypeContainerAdder(ContainerAdderPolicy) {

    /**
    Check if T symbol is a type

    Params:
        T = symbol to be tested

    Returns:
        true if it is a type, false otherwise
    **/
    enum bool isSupported(alias T) = is(T);

    /**
    Scan type T for inner static types, to transform them and store in storage

    Params:
        T = type that will be scanned for inner static types
        locator = locator of components used by transformed component factories
        storage = storage which will contain transformed component factories
    **/
    static void scan(T)(Locator!() locator, Storage!(ObjectFactory, string) storage)
        if(isSupported!T) {

        foreach (member; __traits(allMembers, T)) {
            static if (isPublic!(T, member) && is(Alias!(__traits(getMember, T, member)))) {

                ContainerAdderPolicy.scan!(getMember!(T, member))(locator, storage);
                scan!(getMember!(T, member))(locator, storage);
            }
        }
    }
}

/**
ContainerAdder that will scan a module for it's members, to transform into component factories and add them into a storage
**/
@safe struct ModuleContainerAdder(ContainerAdderPolicy) {

    /**
    Check if T symbol is a module.

    Params:
        T = symbol to be tested

    Returns:
        true if it is a module, false otherwise
    **/
    enum bool isSupported(alias T) = is(typeof({mixin("import " ~ fullyQualifiedName!T ~ ";");}));

    /**
    Scan module T, transform it's members into component factories, and store them into storage.

    Params:
        T = module that is scanned
        locator = locator of components used by transformed component factories
        storage = storage which will contain component factories
    **/
    static void scan(alias T)(Locator!() locator, Storage!(ObjectFactory, string) storage)
        if (isSupported!T) {

        foreach (member; __traits(allMembers, T)) {
            static if (isPublic!(T, member) && is(Alias!(__traits(getMember, T, member)))) {

                ContainerAdderPolicy.scan!(getMember!(T, member))(locator, storage);
            }
        }
    }
}

/**
ContainerAdder that will scan a type for it's methods, and use them to create component factories out of their return type
**/
@safe struct FactoryMethodContainerAdder(ComponentStoringPolicy = ComponentStoringPolicyImpl)
    if (isComponentStoringPolicy!ComponentStoringPolicy) {

    /**
    Check if symbol T is a type

    Params:
        T = symbol to be tested

    Returns:
        true if it is a type, false otherwise
    **/
    enum bool isSupported(alias T) = is(T);

    /**
    Scan T's methods, for methods annotated with @component annotation, transform them into component factories
    that will use them to create components of returned type.

    Params:
        T = type to be scanned
        locator = locator of components used by component factories
        storage = storage which will contain component factories
    **/
    static void scan(alias T)(Locator!() locator, Storage!(ObjectFactory, string) storage)
        if (isSupported!T) {

        foreach (member; __traits(allMembers, T)) {
            static if (isPublic!(T, member) && isSomeFunction!(__traits(getMember, T, member))) {

                foreach (overload; __traits(getOverloads, T, member)) {

                    alias FactoryMethods = Filter!(
                        isComponentAnnotation,
                        allUDAs!overload
                    );

                    foreach (FactoryMethod; FactoryMethods) {
                        debug(annotationScanDebug) pragma(msg, "Found factory method ", member, " on component ", T);
                        auto factory = new WrappingFactory!(GenericFactoryImpl!(ReturnType!overload))(
                            new GenericFactoryImpl!(ReturnType!overload)(locator)
                        );

                        if (factory !is null) {
                            static if (__traits(isStaticFunction, overload)) {
                                auto instanceFactory = factoryMethodBasedFactory!(T, member)(makeAutowireReferences!overload.expand);
                            } else {
                                auto instanceFactory = factoryMethodBasedFactory!(T, member)(lref!T, makeAutowireReferences!overload.expand);
                            }

                            import aermicioi.aedi.storage.decorator : Decorator;

                            static if (is(typeof(factory) : Decorator!X, X : GenericFactory!Z, Z)) {
                                factory.decorated.setInstanceFactory = instanceFactory;
                            } else static if (is(typeof(factory) : GenericFactory!Z, Z) && !is(Z == Object)) {
                                factory.setInstanceFactory = instanceFactory;
                            }

                            ComponentStoringPolicy.store!(ReturnType!overload)(factory, locator, storage);
                        }
                    }
                }
            }
        }
    }
}

/**
Implementation of field scanning configurator policy, with built in field configurators.
**/
alias FieldScanningConfiguratorPolicyImpl = FieldScanningConfiguratorPolicy!(
        SetterFieldConfiguratorPolicy,
        CallbackFieldConfiguratorPolicy,
        AutowiredFieldConfiguratorPolicy
    );

/**
Implementation of method scanning configurator policy, with built in method configurators.
**/
alias MethodScanningConfiguratorPolicyImpl = MethodScanningConfiguratorPolicy!(
        ConstructorMethodConfiguratorPolicy,
        AutowiredConstructorMethodConfiguratorPolicy,
        SetterMethodConfiguratorPolicy,
        CallbackMethodConfiguratorPolicy,
        AutowiredMethodConfiguratorPolicy
    );

/**
Implementation of configurator policy, with built in configurators
**/
alias ConfiguratorPolicyImpl = ChainedConfiguratorPolicy!(
            FieldScanningConfiguratorPolicyImpl,
            MethodScanningConfiguratorPolicyImpl,
            AllocatorConfiguratorPolicy,
            CallbackFactoryConfiguratorPolicy,
            ValueFactoryConfiguratorPolicy,
            GenericConfigurerConfiguratorPolicy
        );

/**
Implementation of factory policy, with built in factory creators
**/
alias FactoryPolicyImpl = FallbackFactoryPolicy!(
    GenericFactoryPolicy,
    GenericFactoryAnnotationPolicy
);

/**
Implementation of type to type factory transformer, with built in funcionality
**/
alias TypeTransformerImpl = TypeTransformer!(
        FactoryPolicyImpl,
        ConfiguratorPolicyImpl
    );

/**
Implementation of object wrapping factory wrapping TypeTransformerImpl
**/
alias ObjectFactoryTransformerImpl =
    ObjectFactoryTransformer!(
        TypeTransformerImpl
    );

/**
Implementation of module container adder, featuring built in scanners
**/
alias ModuleContainerAdderImpl(TransformerPolicy = ObjectFactoryTransformerImpl) = ModuleContainerAdder!(
        ChainedContainerAdder!(
            TypeContainerAdder!TransformerPolicy,
            InnerTypeContainerAdder!(TypeContainerAdder!TransformerPolicy),
            FactoryMethodContainerAdder!(),
        )
    );

/**
Customizable implementation of container adder, with built in functionality
**/
alias ContainerAdderImpl(TransformerPolicy = ObjectFactoryTransformerImpl) = ChainedContainerAdder!(
        TypeContainerAdder!TransformerPolicy,
        InnerTypeContainerAdder!(TypeContainerAdder!TransformerPolicy),
        FactoryMethodContainerAdder!(),
        ModuleContainerAdderImpl!TransformerPolicy
    );

/**
Template for defining scanning functions instantiated with particular container adder policy.

The functions defined in this template mixin are the entry point for running scans over symbols that
are desired to be added into a container. The template will instantiate $(D_INLINECODE scan) family of functions
that will use passed container adder policy to scan symbols passed to them. It is advised to define your own
set of scanning methods in case when additional scanning and transformation logic is expected.
**/
@safe mixin template Scanner(ContainerAdderPolicy) {

    /**
    Scan symbol T for possible components using ContainerAdderPolicy

    Params:
        storage = storage that will contain component factories
        locator = locator of components used to by component factories
    **/
    void scan(alias T)(Storage!(ObjectFactory, string) storage, Locator!() locator) {
        debug(annotationScanDebug) pragma(msg, "Scanning ", fullyQualifiedName!T, " for possible components");

        ContainerAdderPolicy.scan!T(locator, storage);
    }

    /**
    ditto
    **/
    void scan(alias T, X...)(Storage!(ObjectFactory, string) storage, Locator!() locator) {

        scan!T(storage, locator);

        static if (X.length > 0) {

            scan!X(storage, locator);
        }
    }

    /**
    Scan symbol T for possible components using ContainerAdderPolicy

    Params:
        storage = identity by which to search storage in locator, that will be used to store components
        locator = locator of components used to by component factories
    **/
    void scan(alias T)(string storage, Locator!() locator) {

        scan!T(locator.locate!(Storage!(ObjectFactory, string))(storage), locator);
    }

    /**
    ditto
    **/
    void scan(alias T, X...)(string storage, Locator!() locator) {

        scan!(T, X)(locator.locate!(Storage!(ObjectFactory, string))(storage), locator);
    }

    /**
    Scan symbol T for possible components using ContainerAdderPolicy

    Params:
        container = container where to store and from which to locate dependencies for components
    **/
    void scan(alias T)(ConfigurableContainer container) {

        scan!T(container, container);
    }


    void scan(alias T, St : Storage!(ObjectFactory, string) = Storage!(ObjectFactory, string))(Locator!() locator) {

        scan!T(locator.locate!St, locator);
    }

    /**
    ditto
    **/
    void scan(alias T, St : Storage!(ObjectFactory, string), X...)(Locator!() locator) {

        scan!(T, St)(locator);

        static if (X.length > 0) {

            scan!X(locator);
        }
    }

    /**
    ditto
    **/
    void scan(alias T, X...)(Locator!() locator) {
        scan!T(locator);

        static if (X.length > 0) {

            scan!X(locator);
        }
    }
}

/**
Default implementation of $(D_INLINECODE scan) family of functions featuring all scanning features provided by library.
**/
mixin Scanner!(ContainerAdderImpl!());

private template allUDAs(alias symbol) {
    alias allUDAs = AliasSeq!(__traits(getAttributes, symbol));
}

private template toValue(T) {
    enum auto toValue = T();
}

private template toValue(alias T) {
    alias toValue = T;
}

private auto makeAutowireReferences(alias overload)() {

    Repeat!(Parameters!overload.length, RuntimeReference) arguments;

    static foreach (index, argument; arguments) {{
        argument = ParameterIdentifierTuple!overload[index].lref.alternate(
            lref!(Parameters!overload[index])
        );

        static if (is(FunctionTypeOf!overload params == __parameters)) {

            static foreach (qualifier; Filter!(
                isQualifierAnnotation,
                __traits(getAttributes, params[index .. index + 1])
            )) {
                argument = qualifier.id.lref.alternate(argument);
            }
        }
    }}

    return tuple(arguments);
}