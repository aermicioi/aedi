/**
Provides annotation based configuration and registration for components.

License:
	Boost Software License - Version 1.0 - August 17th, 2003

	Permission is hereby granted, free of charge, to any person or organization
	obtaining a copy of the software and accompanying documentation covered by
	this license (the "Software") to use, reproduce, display, distribute,
	execute, and transmit the Software, and to prepare derivative works of the
	Software, and to permit third-parties to whom the Software is furnished to
	do so, all subject to the following:

	The copyright notices in the Software and this entire statement, including
	the above license grant, this restriction and the following disclaimer,
	must be included in all copies of the Software, in whole or in part, and
	all derivative works of the Software, unless such copies or derivative
	works are solely in the form of machine-executable object code generated by
	a source language processor.

	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
	SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
	FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
	ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
	DEALINGS IN THE SOFTWARE.

Authors:
	aermicioi
**/
module aermicioi.aedi.configurer.annotation.component_scan;

import aermicioi.aedi.configurer.annotation.annotation;
import aermicioi.aedi.storage.locator;
import aermicioi.aedi.storage.storage;
import aermicioi.aedi.storage.alias_aware : AliasAware;
import aermicioi.aedi.storage.wrapper;
import aermicioi.aedi.container.container;
import aermicioi.aedi.factory.factory;
import aermicioi.aedi.factory.reference;
import aermicioi.aedi.factory.generic_factory;
import aermicioi.aedi.factory.proxy_factory;
import aermicioi.aedi.exception;
import aermicioi.aedi.util.traits;
import aermicioi.aedi.factory.wrapping_factory : WrappingFactory;

import std.traits;
import std.meta;
import std.conv : to;
import std.algorithm;
import std.experimental.logger;

/**
Check if a type T is a factory policy.

Check if a type T is a factory policy.
A factory policy is a policy that based on type X, can
create a factory for type X.
**/
enum bool isFactoryPolicy(T, X = Object) = is(T == struct) && is(typeof(&T.createFactory!X) : Z function(Locator!()), Z : Factory!X);

/**
Check if a type T is a configurator policy.

Check if a type T is a configurator policy.
A configurator policy is a policy that given a type
X can create InstanceFactory, InstanceDestructor, or PropertyConfigurer
instances and add them to a factory that implements GenericFactory!X interface, as well
as modify other properties exposed by GenericFactory!X interface.
**/
enum bool isConfiguratorPolicy(T, X : GenericFactory!Z = GenericFactory!Object, Z) =
    is(T == struct) &&
    is(typeof(&T.configure!(X)) : void function(M, Locator!()), M : X);

/**
Create a GenericFactory!T if T is annotated with @component annotation.
**/
@safe struct GenericFactoryPolicy {
    /**
    Create a GenericFactory!T if T is annotated with @component annotation.

    Params:
        locator = locator used by factory to fetch it's dependencies

    Returns:
        GenericFactory!T
    **/
    static GenericFactory!T createFactory(T)(Locator!() locator) {
        GenericFactory!T factory;

        alias Components = allUDAs!T;
        static foreach (index; 0 .. Components.length) {
            static if (isComponentAnnotation!(Components[index])) {
                debug(annotationScanDebug) trace(typeid(T), " is marked with @component annotation, creating a component factory for it.");
                factory = new GenericFactoryImpl!T(locator);
            }
        }

        return factory;
    }
}

/**
A factory policy that uses annotations implementing factory policy interface on component to instantiate the component.
**/
@safe struct GenericFactoryAnnotationPolicy {

    /**
    Create a component factory for T using annotations on it that implement factory policy interface.

    Params:
        locator = locator of components used by component factory

    Returns:
        A component factory
    **/
    static GenericFactory!T createFactory(T)(Locator!() locator) {

        GenericFactory!T factory;

        alias FactoryPolicies = allUDAs!T;

        static foreach (index; 0 .. FactoryPolicies.length) {
            static if (isFactoryPolicy!(toType!(FactoryPolicies[index]), T)) {
                factory = FactoryPolicies[index].createFactory!T(locator);
            }
        }

        return factory;
    }
}

/**
A factory policy that applies in order a set of factory policies to create component factory.
**/
@safe struct FallbackFactoryPolicy(FactoryPolicies...)
    if (allSatisfy!(isFactoryPolicy, FactoryPolicies)) {

    /**
    Create component factory using one of supplied factory policies

    Params:
        locator = locator of components used by component factory

    Returns:
        A component factory, from the first factory policy that returned an instance
    **/
    static GenericFactory!T createFactory(T)(Locator!() locator) {

        static foreach (FactoryPolicy; FactoryPolicies) {{
            GenericFactory!T factory = FactoryPolicy.createFactory!T(locator);

            if (factory !is null) {
                return factory;
            }
        }}

        return null;
    }
}

/**
Chain a set of configurator policies.
**/
@safe struct ChainedConfiguratorPolicy(ConfiguratorPolicies...)
    if (allSatisfy!(isConfiguratorPolicy, ConfiguratorPolicies)) {

    /**
    Run ConfiguratorPolicies on instantiator in sequential manner

    Params:
        instantiator = factory which is configured by ConfiguratorPolicies
        locator = locator used by factory

    **/
    static void configure(T : GenericFactory!Z, Z)(T instantiator, Locator!() locator) {

        foreach (policy; ConfiguratorPolicies) {
            policy.configure(instantiator, locator);
        }
    }
}

/**
Set allocator used by factory to instantiate component T.
**/
@safe struct AllocatorConfiguratorPolicy {

    /**
    Set allocator from @allocator annotation into GenericFactory!Z.

    Params:
        instantiator = factory which is set allocator from @allocator annotation
        locator = locator used by factory
    **/
    static void configure(T : GenericFactory!Z, Z)(T instantiator, Locator!() locator) {

        alias Allocators = allUDAs!Z;
        static foreach (index; 0 .. Allocators.length) {
            static if (isAllocatorAnnotation!(Allocators[index])) {
                debug(annotationScanDebug) trace(typeid(Z), " is marked with @allocator annotation, supplying component factory with custom allocator ", Allocators[index].allocator);
                instantiator.allocator = Allocators[index].iallocator;
            }
        }
    }
}

/**
Set callback instance factory from @callbac annotation into GenericFactory!Z
**/
@safe struct CallbackFactoryConfiguratorPolicy {
    private alias getCallbackFactories(alias T) = Filter!(
            isCallbackFactoryAnnotation,
            allUDAs!T
        );

    /**
    Set callback instance factory from @callback annotation into GenericFactory!Z.

    Params:
        instantiator = factory which is set callback instance factory from @callback annotation
        locator = locator used by factory
    **/
    static void configure(T : GenericFactory!Z, Z)(T instantiator, Locator!() locator) {
        alias CallbackFactories = allUDAs!Z;

        static foreach (index; 0 .. CallbackFactories.length) {
            static if (isCallbackFactoryAnnotation!(CallbackFactories[index])) {
                debug(annotationScanDebug) trace(
                    typeid(Z),
                    " is annotated with @callback annotation, supplying component factory with construction callable of ",
                    typeid(CallbackFactories[index].dg),
                    " and provided args ",
                    CallbackFactories[index].args
                );
                instantiator.setInstanceFactory(callbackFactory(CallbackFactories[index].dg, CallbackFactories[index].args));
            }
        }
    }
}

/**
Set value factory that takes component from @value annotation and provides it as a new component.
**/
@safe struct ValueFactoryConfiguratorPolicy {

    /**
    Set value factory that takes component from @value annotation and provides it as a new component.

    Params:
        instantiator = factory which is set value instance factory from @value annotation
        locator = locator used by factory
    **/
    static void configure(T : GenericFactory!Z, Z)(T instantiator, Locator!() locator) {
        alias ValueAnnotations = allUDAs!Z;
        static foreach (index; 0 .. ValueAnnotations.length) {
            static if (isValueAnnotation!(ValueAnnotations[index])) {

                debug(annotationScanDebug) trace(typeid(Z), " is annotated with @value annotation, using ", ValueAnnotations[index].value, " as prebuilt component");
                instantiator.setInstanceFactory(new ValueInstanceFactory!Z(ValueAnnotations[index].value));
            }
        }
    }
}

/**
A policy that uses annotations that implement isConfigurerPolicy interface to configure the component factory
**/
@safe struct GenericConfigurerConfiguratorPolicy {
    /**
    Scans for annotations implementing isConfigurerPolicy interface and uses them to configure component factory.

    Params:
        instantiator = factory upon which isConfigurerPolicy annotations are applied
        locator = locator used by factory
    **/
    static void configure(T : GenericFactory!Z, Z)(T instantiator, Locator!() locator) {
        alias GenericConfigurerConfigurators = allUDAs!Z;
        static foreach (index; 0 .. GenericConfigurerConfigurators.length) {
            static if (isConfiguratorPolicy!(toType!(GenericConfigurerConfigurators[index]), T)) {

                debug(annotationScanDebug) trace(
                    typeid(Z),
                    " is annotated with configuration policy ",
                    typeid(GenericConfigurerConfigurators[index]),
                    " invoking configure method on it using ",
                    instantiator,
                    " and ",
                    locator
                );
                GenericConfigurerConfigurators[index].configure!(T)(instantiator, locator);
            }
        }
    }
}

/**
A policy that configures factory to use callback to destroy created components.
**/
@safe struct CallbackDestructorConfigurerPolicy {
    /**
    Configure instantiator to use callback for destruction of components

    Params:
        instantiator = component factory
        locator = container for component's dependencies
        Z = type of component created
    **/
    static void configure(T : GenericFactory!Z, Z)(T instantiator, Locator!() locator) {
        auto CallbackDestructors = allUDAs!Z;
        foreach (index; 0 .. CallbackDestructors.length) {
            static if (isCallbackDestructor!(CallbackDestructors[index], T)) {

                debug(annotationsScanDebug) trace(
                    typeid(Z), " is annotated with @callbackDestructor callable of ", CallbackDestructors[index].dg, " with arguments of ", CallbackDestructors[index].args
                );
                instantiator.setInstanceDestructor(callbackDestructor(CallbackDestructors[index].dg, CallbackDestructors[index].args));
            }
        }
    }
}

/**
A dummy structure that is providing a simple field for isFieldConfiguratorPolicy interface for testing purposes of configurator templates.
**/
struct ConfiguredFieldTester {

    /**
    Dummy field
    **/
    int field;
}

/**
A dummy structure that is providing a simple method for isMethodConfiguratorPolicy interface for testing purposes of configurator templates.
**/
struct ConfiguredMethodTester {

    /**
    Dummy method
    **/
    void method(int x) {}
}

/**
Check if T is a field configurator policy that operates upon fields of a component.

Params:
    T = the type that is tested for field configurator policy interface
    member = member field of constructed component by GenericFactory!Z
    X = a factory for a component, on which policy can operate
Returns:
    true if it is compliant, false otherwise
**/
enum bool isFieldConfiguratorPolicy(T, string member = "field", X : GenericFactory!Z = GenericFactory!ConfiguredFieldTester, Z) =
    is(T == struct) &&
    is(typeof(&T.configureField!(member, X)) : void function(X, Locator!()));

/**
Check if T is a field configurator policy that operates upon methods of a component.

Params:
    T = the type that is tested for field configurator policy interface
    member = member field of constructed component by GenericFactory!Z
    X = a factory for a component, on which policy can operate

Returns:
    true if it is compliant, false otherwise
**/
enum bool isMethodConfiguratorPolicy(T, string member = "method", X : GenericFactory!Z = GenericFactory!ConfiguredMethodTester, Z) =
    is(T == struct) &&
    is(typeof(&T.configureMethod!(member, X)) : void function(X, Locator!()));

/**
Configurator policy that applies method configurator policies on all public methods of a component
**/
@safe struct MethodScanningConfiguratorPolicy(MethodConfiguratorPolicies...)
    if (allSatisfy!(isMethodConfiguratorPolicy, MethodConfiguratorPolicies)) {

    /**
    Apply a set of method configurator policies on all public methods of component Z

    Params:
        Z = component which will have it's methods scanned, including overloads.
        instantiator = Z component factory
        locator = locator used by method configurator policies
    **/
    static void configure(T : GenericFactory!Z, Z)(T instantiator, Locator!() locator) {
        foreach (member; __traits(allMembers, Z)) {
            static if ((getProtection!(Z, member) == "public") && isSomeFunction!(__traits(getMember, Z, member))) {
                foreach (methodConfigurer; MethodConfiguratorPolicies) {
                    methodConfigurer.configureMethod!member(instantiator, locator);
                }
            }
        }
    }
}

/**
Configurator policy that applies field configurator policies on all public methods of a component
**/
@safe struct FieldScanningConfiguratorPolicy(FieldConfiguratorPolicies...)
    if (allSatisfy!(isFieldConfiguratorPolicy, FieldConfiguratorPolicies)) {

    /**
    Apply a set of field configurator policies on all public fields of component Z

    Params:
        Z = component which will have it's methods scanned, including overloads.
        instantiator = Z component factory
        locator = locator used by method configurator policies
    **/
    static void configure(T : GenericFactory!Z, Z)(T instantiator, Locator!() locator) {
        foreach (member; __traits(allMembers, Z)) {
            static if ((getProtection!(Z, member) == "public") && isField!(Z, member)) {
                foreach (fieldConfigurer; FieldConfiguratorPolicies) {
                    fieldConfigurer.configureField!member(instantiator, locator);
                }
            }
        }
    }
}

/**
Method configurator policy that scans only constructors for @constructor annotation, for using them to instantiate component Z
**/
@safe struct ConstructorMethodConfiguratorPolicy {

    /**
    Checks if scanned method is a constructor and has @constructor annotation, and sets it to be used to construct component if so.

    Params:
        Z = component type
        member = member that should be scanned, only constructors are taken into account
        instantiator = Z component factory, which policy will set constructor to be used to construct component if possible
        locator = locator used to supply dependencies into constructor of component
    **/
    static void configureMethod(string member, T : GenericFactory!Z, Z)(T instantiator, Locator!() locator) {

        static if (member == "__ctor") {
            static foreach (overload; __traits(getOverloads, Z, member)) {{


                alias Configurers = allUDAs!overload;

                static foreach (index; 0 .. Configurers.length) {
                    static if (isConstructorAnnotation!(Configurers[index])) {

                        debug(annotationScanDebug) trace(
                            typeid(Z), " constructor", typeid(Parameters!overload),
                            " is annotated with @constructor annotation, using it as means to construct component using supplied arguments of ", Configurers[index].args
                        );
                        instantiator.setInstanceFactory(
                            constructorBasedFactory!Z(Configurers[index].args)
                        );
                    }
                }
            }}
        }
    }
}

/**
Method policy that scans constructors for @autowired annotation to use them to construct component with dependencies identified by qualifier, name or their type.
**/
@safe struct AutowiredConstructorMethodConfiguratorPolicy {

    /**
    Configures instantiator to use @autowired constructor method, to construct the component.

    Params:
        Z = component type
        member = method that is scanned. Only constructors are taken into account
        instantiator = component constructor
        locator = locator for component dependencies
    **/
    static void configureMethod(string member, T : GenericFactory!Z, Z)(T instantiator, Locator!() locator) {

        static if (member == "__ctor") {
            foreach (overload; __traits(getOverloads, Z, member)) {{

                alias Configurers = allUDAs!overload;

                static foreach (index; 0 .. Configurers.length) {
                    static if (isAutowiredAnnotation!(Configurers[index])) {
                        auto references = makeFunctionParameterReferences!overload.expand;
                        debug(annotationScanDebug) trace(
                            typeid(Z), " constructor", typeid(Parameters!(overload)),
                            " is annotated with @autowired annotation, constructing component using this constructor with arguments of ", references
                        );

                        instantiator.setInstanceFactory(
                            constructorBasedFactory!Z(references)
                        );
                    }
                }
            }}
        }
    }
}

/**
Field configurator policy that will set a field annotated @setter annotation to value contained in it.
**/
@safe struct SetterFieldConfiguratorPolicy {

    /**
    Configures instantiator to inject into field a predefined value or a dependency from @setter annotation

    Params:
        Z = component type
        member = field member of component
        instantiator = component factory
        locator = locator for component dependencies
    **/
    static void configureField(string member, T : GenericFactory!Z, Z)(T instantiator, Locator!() locator) {

        alias Configurers = allUDAs!(__traits(getMember, Z, member));

        static foreach (index; 0 .. Configurers.length) {
            static if (isSetterAnnotation!(Configurers[index])) {

                debug(annotationScanDebug) trace(
                    typeid(Z), ".", member,
                    " field is marked with @setter annotation. Using it to confiugre component with provided arguments of ", Configurers[index].args
                );
                instantiator.addPropertyConfigurer(fieldConfigurer!(member, Z)(Configurers[index].args));
            }
        }
    }
}

/**
Field configurator policy that will set a field to value returned by a callback in @callback annotation
**/
@safe struct CallbackFieldConfiguratorPolicy {

    /**
    Configure instantiator to inject return value of callback from @callback annotation into field

    Params:
        member = field that will be injected
        Z = component type
        instantiator = component factory
        locator = locator for component dependencies
    **/
    static void configureField(string member, T : GenericFactory!Z, Z)(T instantiator, Locator!() locator) {

        alias Callbacks = allUDAs!(__traits(getMember, Z, member));

        static foreach (index; 0 .. Callbacks.length) {
            static if (isCallbackConfigurerAnnotation!(toType!(Callbacks[index]))) {

                debug(annotationScanDebug) trace(
                    typeid(Z), ".", member, " field is annotated with @callback annotation, using callback",
                    Callbacks[index].dg, " with ", Callbacks[index].args, " to inject field with data."
                );
                instantiator.addPropertyConfigurer(callbackConfigurer!Z(Callbacks[index].dg, Callbacks[index].args));
            }
        }
    }
}

/**
Field configurator policy that will try to inject a dependency that matches fields type for fields that are annotated with @autowired annotation
**/
@safe struct AutowiredFieldConfiguratorPolicy {

    /**
    Configure instantiator to inject into field a component identified by field's type if field has @autowired annotation.

    Params:
        member = field that will be injected
        Z = component type
        instantiator = component factory
        locator = locator for component dependencies
    **/
    static void configureField(string member, T : GenericFactory!Z, Z)(T instantiator, Locator!() locator) {
        alias field = Alias!(__traits(getMember, Z, member));

        alias Callbacks = allUDAs!field;

        static foreach (index; 0 .. Callbacks.length) {{
            static if (isAutowiredAnnotation!(Callbacks[index])) {

                RuntimeReference reference;

                mixin(transformToReference("reference", "field"));

                debug(annotationScanDebug) trace(typeid(Z), ".", member, " field is annotated with @autowired annotation, injecting it with ", reference);

                instantiator.addPropertyConfigurer(fieldConfigurer!(member, Z)(reference));
            }
        }}
    }
}

/**
Method configurator policy that will call a method with resolved arguments from @setter annotation.
**/
@safe struct SetterMethodConfiguratorPolicy {

    /**
    Configure instantiator to call @setter annotated method with arguments from annotation

    Params:
        Z = component type
        member = method that would be called by factory
        instantiator = component factory
        locator = locator for component dependencies
    **/
    static void configureMethod(string member, T : GenericFactory!Z, Z)(T instantiator, Locator!() locator) {

        static foreach (overload; __traits(getOverloads, Z, member)) {{

            alias Configurers = allUDAs!overload;

            static foreach (index; 0 .. Configurers.length) {
                static if (isSetterAnnotation!(Configurers[index])) {
                    debug(annotationScanDebug) trace(typeid(Z), ".", member, " method is marked with @setter annotation, injecting it with ", Configurers[index].args);
                    instantiator.addPropertyConfigurer(methodConfigurer!(member, Z)(Configurers[index].args));
                }
            }
        }}
    }
}

/**
Method configurator policy that will call callback from @callback annotated methods.
**/
@safe struct CallbackMethodConfiguratorPolicy {

    /**
    Configre instantiator to call callback from @callback annotation with arguments that are stored in annotation

    Params:
        Z = component type
        member = method which is annotated with @callback. It is supposed that callback will use it somehow in logic.
        instantiator = component factory
        locator = locator for component dependencies
    **/
    static void configureMethod(string member, T : GenericFactory!Z, Z)(T instantiator, Locator!() locator) {

        static foreach (overload; __traits(getOverloads, Z, member)) {{

            alias Configurers = allUDAs!overload;

            static foreach (index; 0 .. Configurers.length) {
                static if (isCallbackConfigurerAnnotation!(toType!(Configurers[index]))) {

                    debug(annotationScanDebug) trace(typeid(Z), ".", member, " method is marked with @callback annotation, using callback", Configurers[index].dg, " with ", Configurers[index].args, " to configure component.");
                    instantiator.addPropertyConfigurer(callbackConfigurer!Z(Configurers[index].dg, Configurers[index].args));
                }
            }
        }}
    }
}

/**
Method configurator policy that will call method annotated with @autowire with arguments extracted from locator identified by qualifier, name or their type.
**/
@safe struct AutowiredMethodConfiguratorPolicy {

    /**
    Configure instantiator to call a method annotated with @autowired with arguments extracted from locator

    Params:
        Z = component type
        member = method that is annotated with @autowired annotation
        instantiator = component factory
        locator = locator for component dependencies
    **/
    static void configureMethod(string member, T : GenericFactory!Z, Z)(T instantiator, Locator!() locator) {
        static if (member != "__ctor") {
            static foreach (overload; __traits(getOverloads, Z, member)) {{

                alias Configurers = allUDAs!overload;

                static foreach (index; 0 .. Configurers.length) {
                    static if (isAutowiredAnnotation!(Configurers[index])) {
                        auto references = makeFunctionParameterReferences!overload.expand;

                        debug(annotationScanDebug) trace(typeid(Z), ".", member, " method is marked with @autowired annotation, injecting it with ", references);

                        instantiator.addPropertyConfigurer(methodConfigurer!(member, Z)(references));
                    }
                }
            }}
        }
    }
}

/**
Check if a policy implements transformer interface.

A transformer is a policy that takes a type, and optionally a member of it, and transform it
into a component factory using annotations from component, or member.

Params:
    T = type to be tested for interface implementation
    X = a test object that is used to test templated methods of policy
Returns:
    true if it implements Transformer interface, false otherwise
**/
enum bool isTransformer(T, X = Object) = is(T == struct) && is(typeof(&T.transform!X) : void function (Locator!(), Storage!(ObjectFactory, string)));

/**
A transformer that creates out of a type a GenericFactory for passed type
**/
@safe struct TypeTransformer(FactoryPolicy, ConfigurerPolicy)
    if (isFactoryPolicy!FactoryPolicy && isConfiguratorPolicy!ConfigurerPolicy) {

    /**
    Transform type T into a GenericFactory!T

    Params:
        T = type which is transformed into it's factory
        locator = locator for T's dependencies
    Returns:
        instance of GenericFactory!T, or null if T is not transformable into a factory
    **/
    static auto transform(T)(Locator!() locator)
        if (is(T)) {
        auto instantiator = FactoryPolicy.createFactory!T(locator);

        if (instantiator is null) {
            return instantiator;
        }

        ConfigurerPolicy.configure(instantiator, locator);

        return instantiator;
    }
}

/**
Transformer that wraps results of another transformer in WrappingFactory
**/
@safe struct ObjectFactoryTransformer(TransformerPolicy) {

    /**
    Wrap up results of another transformer into WrappingFactory

    Params:
        T = type of component that is transformed

    Returns:
        null if T is not transformable, or instance of WrappingFactory that wraps result of TransformerPolicy
    **/
    static auto transform(T)(Locator!() locator)
        if (is(T)) {

        auto instantiator = TransformerPolicy.transform!T(locator);

        if (instantiator is null) {
            return cast(WrappingFactory!(typeof(instantiator))) null;
        }

        return new WrappingFactory!(typeof(instantiator))(instantiator);
    }
}

/**
Check if T implements ContainerAdder interface.

A ContainerAdder is component that is responsible to scan
a symbol for it's members, transform them using passed Transformers,
and add them to storage.

Params:
    T = component that is tested for ContainerAdder interface.
    X = a dummy symbol used to test templated methods of component

Note:
    Due to possibility to store any kind of symbol in X (not only types),
    the use of this checker is limited in use for generic testing.
    Ex. ContainerAdder for modules and types are technically different interfaces
    and will fail the checker when are tested both with same X argument
    (module is not a type), though they are conceptually the same.
Returns:
    true if it implements ContainerAdder interface, false otherwise
**/
enum bool isContainerAdder(T, alias X = Object) =
    is(T == struct) &&
    is(typeof(&T.scan!X) : V function (X, Y), X : Locator!(), Y : Storage!(Factory!Object, string), V);

/**
Check if T implements component storing interface.

The responsibility of component storing policy is to
store component's factory into appropiate storage,
by apropiate identity, using information about type T.

Params:
    T = type that is tested for interface compliance
    X = component type against which T's templates are tested to comply to interface
Returns:
    true if it implements the interface, false otherwise
**/
enum bool isComponentStoringPolicy(T, X = Object) =
    is(T == struct) &&
    is(
        typeof(&T.store!X) : ComponentStoringResult function (F, Locator!(), S),
        F : Factory!Z,
        Z,
        S : Storage!(Factory!Z, string)
    );

/**
Check if T implements identity resolver interface.

The responsibility of identity resolver policy is to
find an identity for component that is to be stored based
on information provided on passed type.

Params:
    T = type that is tested for interface compliance
    X = component type against which T's templates are tested to comply to interface
Returns:
    true if it implements the interface, false otherwise
**/
enum bool isIdentityResolverPolicy(T, X = Object) =
    is(T == struct) &&
    is(
        typeof(&T.resolve!X) : string function (F),
        F : Factory!Z,
        Z
    );

/**
Check if T implements storage resolver interface.

The responsibility of storage resolver policy is to
find a storage for component which will store component
based on information provided on passed type.

Params:
    T = type that is tested for interface compliance
    X = component type against which T's templates are tested to comply to interface
Returns:
    true if it implements the interface, false otherwise
**/
enum bool isStorageLocatorPolicy(T, X = Object) =
    is(T == struct) &&
    is(
        typeof(&T.search!X) : Storage!(Factory!Z, string) function (F, Locator!(), S),
        F : Factory!Z,
        Z,
        S : Storage!(Factory!Z, string)
    );

/**
Check if T implements identity aliasing interface.

The responsibility of identity aliasing policy is to
find aliases of component's identity that should be registered
in component storage.

Params:
    T = type that is tested for interface compliance
    X = component type against which T's templates are tested to comply to interface
Returns:
    true if it implements the interface, false otherwise
**/
enum bool isAliasingPolicy(T, X = Object) =
    is(T == struct) &&
    is(
        typeof(&T.link!X) : void function (string, AliasAware!string)
    );

/**
Result of storing a component into a storage.
**/
struct ComponentStoringResult {

    /**
    Primary identity of stored component
    **/
    string identity;

    /**
    Storage where it was stored.
    **/
    Storage!(ObjectFactory, string) storage;
}

/**
A default implementation of component storing policy that looks for @qualifier and @contained annotations to store component factory.
**/
@safe struct ComponentStoringPolicy(IdentityResolverPolicy, StorageResolvingPolicy, AliasingPolicyImpl) {
    /**
    Store component factory into storage.

    Store component factory into storage. The storage where component is stored
    on presence of @contained annotation on T, will be extracted from locator, otherwise
    storage passed as argument is used. The identity of component by default is
    it's type FQN, but is overriden by @qualifier annotation.

    Params:
        factory = component factory to be stored
        locator = locator that is used to fetch storage in case of @contained annotation
        storage = storage were component is stored when no @contained annotation is provided
    **/
    static ComponentStoringResult store(alias T)(Factory!Object factory, Locator!() locator, Storage!(Factory!Object, string) storage) {

        string identity = IdentityResolverPolicy.resolve!T(factory);

        auto destinationStorage = StorageResolvingPolicy.search!T(factory, locator, storage);

        if ((identity !is null) && (destinationStorage !is null)) {
            destinationStorage.set(factory, identity);

            AliasAware!string aliasingContainer = (() @trusted => cast(AliasAware!string) destinationStorage)();
            if (aliasingContainer !is null) {
                AliasingPolicyImpl.link!T(identity, aliasingContainer);
            }

            return ComponentStoringResult(identity, destinationStorage);
        }


        return ComponentStoringResult.init;
    }
}

/**
A implementation that will chain several storing policies, triggerring multiple registrations of same component.
**/
@safe struct ChainedComponentStoringPolicy(ComponentStoringPolicies...)
    if (allSatisfy!(isComponentStoringPolicy, ComponentStoringPolicies)) {

    /**
    Store component factory into multiple storages by using multiple policies.

    Params:
        factory = component factory to be stored
        locator = locator that is used to fetch storage in case of @contained annotation
        storage = storage were component is stored when no @contained annotation is provided
    **/
    static ComponentStoringResult store(alias T)(Factory!Object factory, Locator!() locator, Storage!(Factory!Object, string) storage) {
        ComponentStoringResult result;
        foreach (ComponentStoringPolicy; ComponentStoringPolicies) {
            result = ComponentStoringPolicy.store!T(factory, locator, storage);

            if (result !is ComponentStoringResult.init) {
                break;
            }
        }

        return result;
    }
}

/**
Default implementation of storage policy used by adders.
**/
alias ComponentStoringPolicyImpl = ComponentStoringPolicy!(
    IdentityResolverPolicyImpl,
    StorageLocatorPolicyImpl,
    AliasingPolicyImpl
);

/**
Qualifier implementation of aliasing policy.
**/
@safe struct QualifiedAnnotationAliasingPolicy {

    /**
    Alias an identity in a aliasing container based on qualifier annotations on component.

    Params:
        identity = main identity of component registered in aliased container.
        aliasingContainer = container that is keeping aliasing information.
    **/
    static void link(alias T)(string identity, AliasAware!string aliasingContainer) {

        alias Qualifiers = allUDAs!T;
        static foreach (index; 0 .. Qualifiers.length) {
            static if (isQualifierAnnotation!(Qualifiers[index])) {
                if (identity != Qualifiers[index].id) {
                    debug(annotationScanDebug) trace(
                        fullyQualifiedName!T, " is marked with @qualifier annotation, aliasing identitity ",
                        identity, " of component to ", Qualifiers[index].id
                    );

                    aliasingContainer.link(identity, Qualifiers[index].id);
                }
            }
        }
    }
}

/**
By identifier implementation of aliasing policy.
**/
@safe struct IdentifierAliasingPolicy {

    /**
    Alias an identity in a aliasing container based on it's identifier.

    Params:
        identity = main identity of component registered in aliased container.
        aliasingContainer = container that is keeping aliasing information.
    **/
    static void link(alias T)(string identity, AliasAware!string aliasingContainer) {

        static if (is(typeof(__traits(identifier, T)))) {
            static immutable identifier = __traits(identifier, T);
            if (identifier != identity) {
                debug(annotationScanDebug) trace(
                    fullyQualifiedName!T, " has identifier of ", identifier, ", aliasing it to identitity of ", identity
                );

                aliasingContainer.link(identity, identifier[]);
            }
        }
    }
}

/**
By type implementation of aliasing policy.
**/
@safe struct TypeAliasingPolicy {

    /**
    Alias an identity in a aliasing container based on type of component.

    Params:
        identity = main identity of component registered in aliased container.
        aliasingContainer = container that is keeping aliasing information.
    **/
    static void link(alias T)(string identity, AliasAware!string aliasingContainer) {

        static if (is(typeof({ auto test = typeid(T); }))) {

            if (typeid(T).toString != identity) {
                debug(annotationScanDebug) trace(
                    typeid(T), " has identity ", identity, " which is not FQN of component, aliasing it to ", typeid(T), " of component using typeid"
                );
                aliasingContainer.link(identity, typeid(T).toString);
            }

            if ((typeid(T).toString != fullyQualifiedName!T) && (fullyQualifiedName!T != identity)) {
                debug(annotationScanDebug) trace(
                    typeid(T), " has identity ", identity, " which is not FQN of component, aliasing it to ", typeid(T), " of component using fullyQualifiedName"
                );
                aliasingContainer.link(identity, fullyQualifiedName!T);
            }
        }
    }
}

/**
Chaining implementation of aliasing policy, calling other passed policies.
**/
@safe struct ChainedAliasingPolicy(Policies...)
    if (allSatisfy!(isAliasingPolicy, Policies)) {

    /**
    Alias an identity in a aliasing container using aliasing policies passed to this policy.

    Params:
        identity = main identity of component registered in aliased container.
        aliasingContainer = container that is keeping aliasing information.
    **/
    static void link(alias T)(string identity, AliasAware!string aliasingContainer) {
        static foreach (Policy; Policies) {
            Policy.link!T(identity, aliasingContainer);
        }
    }
}

/**
Default configuration of aliasing policy
**/
alias AliasingPolicyImpl = ChainedAliasingPolicy!(
    QualifiedAnnotationAliasingPolicy,
    IdentifierAliasingPolicy,
    TypeAliasingPolicy
);

/**
A implementation storage locator policy that searches for storage of component based on @contained annotation
**/
@safe struct ContainedAnnotationStorageLocatorPolicy {

    /**
    Find a storge in locator based upon @contained annotation

    Params:
        factory = component factory to be stored
        locator = locator that is used to fetch storage in case of @contained annotation is present
        storage = default storage
    **/
    static Storage!(Factory!Object, string) search(alias T)(Factory!Object factory, Locator!() locator, Storage!(Factory!Object, string) storage) {
        string id;

        alias ContainedAnnotations = allUDAs!T;
        static foreach (index; 0 .. ContainedAnnotations.length) {
            static if (isContainedAnnotation!(ContainedAnnotations[index])) {

                if (locator.has(ContainedAnnotations[index].id)) {
                    debug(annotationScanDebug) trace(
                        typeid(T), " is marked with custom @contained annotation, using storage identified by ",
                        ContainedAnnotations[index].id, " to store component factory"
                    );
                    id = ContainedAnnotations[index].id;
                }
            }
        }

        if (id !is null) {
            return locator.locate!(Storage!(Factory!Object, string))(id);
        }

        return null;
    }
}

/**
A implementation storage locator policy that will return default storage for component which is passed as argument to search.
**/
@safe struct DefaultStorageLocatorPolicy {

    /**
    Find a storge in locator based upon @contained annotation

    Params:
        factory = component factory to be stored
        locator = locator that is used to fetch storage in case of @contained annotation
        storage = default storage
    **/
    static Storage!(Factory!Object, string) search(alias T)(Factory!Object factory, Locator!() locator, Storage!(Factory!Object, string) storage) {

        return storage;
    }
}

/**
A implementation storage locator policy that will apply other policies in chain until one provides a storage for storing data.
**/
@safe struct ChainedStorageLocatorPolicy(StorageLocatorPolicies...)
    if (allSatisfy!(isStorageLocatorPolicy, StorageLocatorPolicies)) {

    /**
    Get default storage for component.

    Params:
        factory = component factory to be stored
        locator = locator that is used to fetch storage in case of @contained annotation
        storage = default storage
    **/
    static Storage!(Factory!Object, string) search(alias T)(Factory!Object factory, Locator!() locator, Storage!(Factory!Object, string) storage) {

        static foreach (StorageLocatorPolicy; StorageLocatorPolicies) {{
            auto destination = StorageLocatorPolicy.search!T(factory, locator, storage);

            if (destination !is null) {
                return destination;
            }
        }}

        return null;
    }
}

/**
Default policy implementation for searching of storage for component
**/
alias StorageLocatorPolicyImpl = ChainedStorageLocatorPolicy!(
    ContainedAnnotationStorageLocatorPolicy,
    DefaultStorageLocatorPolicy
);

/**
A policy for resolving identity of component by annotation.
**/
@safe struct QualifiedAnnotationIdentityResolverPolicy {

    /**
    Resolve identity of component by qualified annotations on it.

    The first qualified annotation is returned from list of annotations. If no annotations
    are on the component T, null is returned.

    Params:
        factory = component factory to be stored

    Returns:
        identity of component based on annotation or null.
    **/
    static string resolve(alias T)(Factory!Object factory) {
        string identity;

        alias Qualifiers = allUDAs!T;
        static foreach (index; 0 .. Qualifiers.length) {{
            static if (isQualifierAnnotation!(Qualifiers[index])) {
                debug(annotationScanDebug) trace(
                    fullyQualifiedName!T, " is marked with @qualifier annotation, using ", Qualifiers[index].id, " as main identity for component."
                );
                identity = Qualifiers[index].id;
                break;
            }
        }}

        return identity;
    }
}

/**
A policy for resolving identity of component by it's type.
**/
@safe struct TypeIdentityResolverPolicy {

    /**
    Resolve identity of component by FQN of it's type.

    Params:
        factory = component factory to be stored

    Returns:
        FQN of component type as it's identity.
    **/
    static string resolve(alias T)(Factory!Object factory) {

        debug(annotationScanDebug) trace(
            fullyQualifiedName!T, " has no custom identities, using it's type FQN as main identity."
        );
        return fullyQualifiedName!T;
    }
}

/**
A policy for resolving identity of component by it's identifier.
**/
@safe struct IdentifierBasedIdentityResolverPolicy {

    /**
    Resolve identity of component by identifier attached to it.

    Params:
        factory = component factory to be stored

    Returns:
        identifier as identity of component or null.
    **/
    static string resolve(alias T)(Factory!Object factory) {

        static if (is(typeof(__traits(identifier, T)))) {
            static immutable string identifier = __traits(identifier, T);
            debug(annotationScanDebug) trace(
                fullyQualifiedName!T, " has identifier ", identifier, " using it as main identity for component."
            );

            return identifier;
        } else {

            return null;
        }
    }
}

/**
A policy for resolving identity of component by applying other components in chain.
**/
@safe struct ChainedIdentityResolverPolicy(IdentityResolverPolicies...)
    if (allSatisfy!(isIdentityResolverPolicy, IdentityResolverPolicies)) {

    /**
    Resolve identity of component by FQN of it's type.

    Params:
        factory = component factory to be stored

    Returns:
        FQN of component type as it's identity.
    **/
    static string resolve(alias T)(Factory!Object factory) {

        static foreach (IdentityResolverPolicy; IdentityResolverPolicies) {{
            string identity = IdentityResolverPolicy.resolve!T(factory);

            if (identity !is null) {
                return identity;
            }
        }}

        return null;
    }
}

/**
Default implementation of identity resolving policy
**/
alias IdentityResolverPolicyImpl = ChainedIdentityResolverPolicy!(
    QualifiedAnnotationIdentityResolverPolicy,
    TypeIdentityResolverPolicy
);

/**
ContainerAdder that chains a set of ContainerAdders on a symbol.
**/
@safe struct ChainedContainerAdder(ContainerAdderPolicies...) {
    import aermicioi.aedi.util.traits : getMember;

    /**
    Check if at least one ContainerAdder supports passed symbol

    Params:
        T = symbol that at least one ContainerAdder, must know how to scan
    Returns:
        true if at least one ContainerAdder knows how to scan symbol, false otherwise
    **/
    enum bool isSupported(alias T) = anySatisfied!(T, staticMap!(ApplyRight!(getMember, "isSupported"), ContainerAdderPolicies));

    /**
    Apply all ContainerAdders that know how to scan T symbol

    Params:
        T = symbol to be scanned
        locator = locator of components, used by transformer that is applied on members of scanned T symbol
        storage = the storage that will store component factories from transformed members of T symbol
    **/
    static void scan(alias T)(Locator!() locator, Storage!(ObjectFactory, string) storage)
        if (isSupported!T) {
        foreach (ContainerAdderPolicy; ContainerAdderPolicies) {
            static if (ContainerAdderPolicy.isSupported!T) {
                ContainerAdderPolicy.scan!T(locator, storage);
            }
        }
    }
}

/**
Applies a transformer on passed symbol if it is a type.
**/
@safe struct TypeContainerAdder(TypeTransformerPolicy, ComponentStoringPolicy = ComponentStoringPolicyImpl)
    if (isComponentStoringPolicy!ComponentStoringPolicy) {

    /**
    Check if symbol T is a type definition.

    Params:
        T = symbol to be tested
    Returns:
        true if it is a type, false otherwise
    **/
    enum bool isSupported(alias T) = is(T);

    /**
    Transform T component into a factory using TypeTransformerPolicy

    Params:
        T = component type
        locator = component locator used by transformed component factory
        storage = storage wich will contain component factory transformed out of T
    **/
    static void scan(T)(Locator!() locator, Storage!(ObjectFactory, string) storage)
        if (isSupported!T) {

        auto transformed = TypeTransformerPolicy.transform!T(locator);

        if (transformed is null) {
            return;
        }

        ComponentStoringPolicy.store!T(transformed, locator, storage);
    }
}

/**
ContainerAdder that scans a type for inner static types, to transform and store into a storage.
**/
@safe struct InnerTypeContainerAdder(ContainerAdderPolicy) {

    /**
    Check if T symbol is a type

    Params:
        T = symbol to be tested

    Returns:
        true if it is a type, false otherwise
    **/
    enum bool isSupported(alias T) = is(T);

    /**
    Scan type T for inner static types, to transform them and store in storage

    Params:
        T = type that will be scanned for inner static types
        locator = locator of components used by transformed component factories
        storage = storage which will contain transformed component factories
    **/
    static void scan(T)(Locator!() locator, Storage!(ObjectFactory, string) storage)
        if(isSupported!T) {

        foreach (member; __traits(allMembers, T)) {
            static if (isPublic!(T, member) && is(Alias!(__traits(getMember, T, member)))) {

                ContainerAdderPolicy.scan!(getMember!(T, member))(locator, storage);
                scan!(getMember!(T, member))(locator, storage);
            }
        }
    }
}

/**
ContainerAdder that will scan a module for it's members, to transform into component factories and add them into a storage
**/
@safe struct ModuleContainerAdder(ContainerAdderPolicy) {
    import std.algorithm : startsWith;
    /**
    Check if T symbol is a module.

    Params:
        T = symbol to be tested

    Returns:
        true if it is a module, false otherwise
    **/
    enum bool isSupported(alias T) = T.stringof.startsWith("module");

    /**
    Scan module T, transform it's members into component factories, and store them into storage.

    Params:
        T = module that is scanned
        locator = locator of components used by transformed component factories
        storage = storage which will contain component factories
    **/
    static void scan(alias T)(Locator!() locator, Storage!(ObjectFactory, string) storage)
        if (isSupported!T) {

        foreach (member; __traits(allMembers, T)) {
            static if (isPublic!(T, member) && is(Alias!(__traits(getMember, T, member)))) {
                ContainerAdderPolicy.scan!(getMember!(T, member))(locator, storage);
            }
        }
    }
}

/**
ContainerAdder that will ignore specific packages.

Params:
    pack = package that will be ignored.
    ContainerAdderPolicy = policy run on not ignored packages.
**/
@safe struct IgnoringContainerAdder(string pack, ContainerAdderPolicy) {
    import std.algorithm : startsWith;
    import std.traits : packageName;
    /**
    Check if T symbol is a module.

    Params:
        T = symbol to be tested

    Returns:
        true if it is a module, false otherwise
    **/
    enum bool isSupported(alias T) = !packageName!T.startsWith(pack) && ContainerAdderPolicy.isSupported!T;

    /**
    Scan T if it is not in ignored package.

    Params:
        T = module that is scanned
        locator = locator of components used by transformed component factories
        storage = storage which will contain component factories
    **/
    static void scan(alias T)(Locator!() locator, Storage!(ObjectFactory, string) storage)
        if (isSupported!T) {
        ContainerAdderPolicy.scan!T(locator, storage);
    }
}

/**
ContainerAdder that will scan a type for it's methods, and use them to create component factories out of their return type
**/
@safe struct FactoryMethodContainerAdder(
    ByTypeComponentStoringPolicy = ComponentStoringPolicyImpl,
    ByMethodComponentStoringPolicy = ComponentStoringPolicy!(
        ChainedIdentityResolverPolicy!(
            QualifiedAnnotationIdentityResolverPolicy,
            IdentifierBasedIdentityResolverPolicy
        ),
        StorageLocatorPolicyImpl,
        AliasingPolicyImpl
    ),
    ByTypeAliasingPolicy = TypeAliasingPolicy
) if (isComponentStoringPolicy!ByTypeComponentStoringPolicy && isComponentStoringPolicy!ByMethodComponentStoringPolicy && isAliasingPolicy!ByTypeAliasingPolicy) {
    import std.algorithm : startsWith;

    /**
    Check if symbol T is a type or module

    Params:
        T = symbol to be tested

    Returns:
        true if it is a type, false otherwise
    **/
    enum bool isSupported(alias T) = isModule!T || isType!T;

    /**
    ditto
    **/
    enum bool isModule(alias T) = T.stringof.startsWith("module");

    /**
    ditto
    **/
    enum bool isType(alias T) = is(T);

    /**
    Scan T's methods, for methods annotated with @component annotation, transform them into component factories
    that will use them to create components of returned type.

    Params:
        T = type to be scanned
        locator = locator of components used by component factories
        storage = storage which will contain component factories
    **/
    static void scan(alias T)(Locator!() locator, Storage!(ObjectFactory, string) storage)
        if (isSupported!T) {

        static foreach (member; __traits(allMembers, T)) {{
            static if (isPublic!(T, member) && isSomeFunction!(__traits(getMember, T, member))) {

                static foreach (overload; __traits(getOverloads, T, member)) {{

                    alias FactoryMethods = allUDAs!overload;

                    static foreach (index; 0 .. FactoryMethods.length) {{
                        static if (isComponentAnnotation!(FactoryMethods[index])) {
                            auto factory = new WrappingFactory!(GenericFactoryImpl!(ReturnType!overload))(
                                new GenericFactoryImpl!(ReturnType!overload)(locator)
                            );

                            if (factory !is null) {
                                auto params = makeFunctionParameterReferences!overload.expand;

                                debug(annotationScanDebug) trace(fullyQualifiedName!T, ".", member, " is annotated with @component annotation, using it as constructor for component with args ", params);
                                static if (isModule!T) {
                                    auto instanceFactory = functionInstanceFactory(&overload, params);
                                } else static if (__traits(isStaticFunction, overload)) {
                                    auto instanceFactory = factoryMethodBasedFactory!(T, member)(params);
                                } else {
                                    auto instanceFactory = factoryMethodBasedFactory!(T, member)(lref!T, params);
                                }

                                import aermicioi.aedi.storage.decorator : Decorator;

                                static if (is(typeof(factory) : Decorator!X, X : GenericFactory!Z, Z)) {
                                    factory.decorated.setInstanceFactory = instanceFactory;
                                } else static if (is(typeof(factory) : GenericFactory!Z, Z) && !is(Z == Object)) {
                                    factory.setInstanceFactory = instanceFactory;
                                }

                                ComponentStoringResult result;
                                result = ByMethodComponentStoringPolicy.store!overload(factory, locator, storage);

                                if (result !is ComponentStoringResult.init) {
                                    AliasAware!string container = (delegate AliasAware!string () @trusted => cast(AliasAware!string) result.storage)();

                                    if (container !is null) {
                                        ByTypeAliasingPolicy.link!(ReturnType!overload)(result.identity, container);
                                    }
                                } else {

                                    ByTypeComponentStoringPolicy.store!(ReturnType!overload)(factory, locator, storage);
                                }
                            }
                        }
                    }}
                }}
            }
        }}
    }
}

/**
Implementation of field scanning configurator policy, with built in field configurators.
**/
alias FieldScanningConfiguratorPolicyImpl = FieldScanningConfiguratorPolicy!(
        SetterFieldConfiguratorPolicy,
        CallbackFieldConfiguratorPolicy,
        AutowiredFieldConfiguratorPolicy
    );

/**
Implementation of method scanning configurator policy, with built in method configurators.
**/
alias MethodScanningConfiguratorPolicyImpl = MethodScanningConfiguratorPolicy!(
        ConstructorMethodConfiguratorPolicy,
        AutowiredConstructorMethodConfiguratorPolicy,
        SetterMethodConfiguratorPolicy,
        CallbackMethodConfiguratorPolicy,
        AutowiredMethodConfiguratorPolicy
    );

/**
Implementation of configurator policy, with built in configurators
**/
alias ConfiguratorPolicyImpl = ChainedConfiguratorPolicy!(
            FieldScanningConfiguratorPolicyImpl,
            MethodScanningConfiguratorPolicyImpl,
            AllocatorConfiguratorPolicy,
            CallbackFactoryConfiguratorPolicy,
            ValueFactoryConfiguratorPolicy,
            GenericConfigurerConfiguratorPolicy
        );

/**
Implementation of factory policy, with built in factory creators
**/
alias FactoryPolicyImpl = FallbackFactoryPolicy!(
    GenericFactoryPolicy,
    GenericFactoryAnnotationPolicy
);

/**
Implementation of type to type factory transformer, with built in funcionality
**/
alias TypeTransformerImpl = TypeTransformer!(
        FactoryPolicyImpl,
        ConfiguratorPolicyImpl
    );

/**
Implementation of object wrapping factory wrapping TypeTransformerImpl
**/
alias ObjectFactoryTransformerImpl =
    ObjectFactoryTransformer!(
        TypeTransformerImpl
    );

/**
Implementation of module container adder, featuring built in scanners
**/
alias ModuleContainerAdderImpl(TransformerPolicy = ObjectFactoryTransformerImpl) = ModuleContainerAdder!(
        IgnoringContainerAdder!("std",
            ChainedContainerAdder!(
                IgnoringContainerAdder!("std", TypeContainerAdder!TransformerPolicy),
                IgnoringContainerAdder!("std", InnerTypeContainerAdder!(TypeContainerAdder!TransformerPolicy)),
                IgnoringContainerAdder!("std", FactoryMethodContainerAdder!()),
            )
        )
    );

/**
Customizable implementation of container adder, with built in functionality
**/
alias ContainerAdderImpl(TransformerPolicy = ObjectFactoryTransformerImpl) = ChainedContainerAdder!(
        IgnoringContainerAdder!("std", TypeContainerAdder!TransformerPolicy),
        IgnoringContainerAdder!("std", InnerTypeContainerAdder!(TypeContainerAdder!TransformerPolicy)),
        IgnoringContainerAdder!("std", FactoryMethodContainerAdder!()),
        ModuleContainerAdderImpl!TransformerPolicy
    );

/**
Template for defining scanning functions instantiated with particular container adder policy.

The functions defined in this template mixin are the entry point for running scans over symbols that
are desired to be added into a container. The template will instantiate $(D_INLINECODE scan) family of functions
that will use passed container adder policy to scan symbols passed to them. It is advised to define your own
set of scanning methods in case when additional scanning and transformation logic is expected.
**/
@safe mixin template Scanner(ContainerAdderPolicy) {

    /**
    Scan symbol T for possible components using ContainerAdderPolicy

    Params:
        storage = storage that will contain component factories
        locator = locator of components used to by component factories
    **/
    void scan(alias T)(Storage!(ObjectFactory, string) storage, Locator!() locator) {
        debug(annotationScanDebug) trace(fullyQualifiedName!T, " will be scanned for possible components.");

        ContainerAdderPolicy.scan!T(locator, storage);
    }

    /**
    ditto
    **/
    void scan(alias T, X...)(Storage!(ObjectFactory, string) storage, Locator!() locator) {

        scan!T(storage, locator);

        static if (X.length > 0) {

            scan!X(storage, locator);
        }
    }

    /**
    Scan symbol T for possible components using ContainerAdderPolicy

    Params:
        storage = identity by which to search storage in locator, that will be used to store components
        locator = locator of components used to by component factories
    **/
    void scan(alias T)(string storage, Locator!() locator) {

        scan!T(locator.locate!(Storage!(ObjectFactory, string))(storage), locator);
    }

    /**
    ditto
    **/
    void scan(alias T, X...)(string storage, Locator!() locator) {

        scan!(T, X)(locator.locate!(Storage!(ObjectFactory, string))(storage), locator);
    }

    /**
    Scan symbol T for possible components using ContainerAdderPolicy

    Params:
        container = container where to store and from which to locate dependencies for components
    **/
    void scan(alias T)(ConfigurableContainer container) {

        scan!T(container, container);
    }


    void scan(alias T, St : Storage!(ObjectFactory, string) = Storage!(ObjectFactory, string))(Locator!() locator) {

        scan!T(locator.locate!St, locator);
    }

    /**
    ditto
    **/
    void scan(alias T, St : Storage!(ObjectFactory, string), X...)(Locator!() locator) {

        scan!(T, St)(locator);

        static if (X.length > 0) {

            scan!X(locator);
        }
    }

    /**
    ditto
    **/
    void scan(alias T, X...)(Locator!() locator) {
        scan!T(locator);

        static if (X.length > 0) {

            scan!X(locator);
        }
    }
}

/**
Default implementation of $(D_INLINECODE scan) family of functions featuring all scanning features provided by library.
**/
mixin Scanner!(ContainerAdderImpl!());

private template allUDAs(alias symbol) {
    alias allUDAs = AliasSeq!(__traits(getAttributes, symbol));
}

private template toValue(T) {
    enum toValue = T();
}

private template toValue(alias T) {
     alias toValue = T;
}

/**
A small utility function that will resolve method arguments using a locator and look also for annotations on arguments.

Params:
    locator = locator used to prepare list of arguments for function
    overload = function for which to prepare arguments. The func itself must not be an overloaded set of functions.
    args = list of args that should override existing references by type of argument.

Returns:
    a tuple with all required arguments prefilled.
**/
auto prepare(alias overload, Args...)(Locator!() locator, out Parameters!overload parameters, Args args) {
    import std.traits : FunctionTypeOf;

    auto references = makeFunctionParameterReferences!(overload)().expand;
    static foreach (index, arg; parameters) {
        static if (is(Args[index] == typeof(arg))) {
            arg = args[index];
        } else {
            arg = references[index].resolve!(typeof(arg))(locator);
        }
    }
}

private alias makeFunctionParameterReferences(alias FunctionType) = aermicioi.aedi.factory.reference.makeFunctionParameterReferences!(FunctionType, transformToReference);

auto transformToReference(string reference, string symbol) {
    import aermicioi.aedi.factory.reference : transformToBasic = transformToReference;
    import std.range : chain, only, enumerate;
    import std.algorithm : joiner, map, substitute;
    import std.array : array;
    import std.utf : byChar;

    string delegate (string) toTypeGen = (s) => "toType!(" ~ s ~ ")";
    string delegate (string, string) typeEnforcedRefGen = (t, s) => "typeEnforcedRef!(" ~ toTypeGen(t) ~ ")(" ~ s ~ ")";
    string delegate (string) lrefGen = (s) => s ~ ".lref";
    string delegate (string, string) alternateGen = (f, s) => f ~ ".alternate(" ~ s ~ ")";

    return transformToBasic(reference, symbol) ~ "
                import std.meta : Filter;
                import aermicioi.aedi.configurer.annotation.annotation : isQualifierAnnotation;
                static foreach (qualifier; Filter!(
                    isQualifierAnnotation,
                    __traits(getAttributes, " ~ symbol ~ ")
                )) {
                    " ~ reference ~ " = " ~ alternateGen(typeEnforcedRefGen(symbol, lrefGen("qualifier.id")), typeEnforcedRefGen(symbol, reference)) ~ ";
                }
            ";
}