/**
This module provides fluent api based configuration of components with custom 
configuration errors.

License:
	Boost Software License - Version 1.0 - August 17th, 2003
    
    Permission is hereby granted, free of charge, to any person or organization
    obtaining a copy of the software and accompanying documentation covered by
    this license (the "Software") to use, reproduce, display, distribute,
    execute, and transmit the Software, and to prepare derivative works of the
    Software, and to permit third-parties to whom the Software is furnished to
    do so, all subject to the following:
    
    The copyright notices in the Software and this entire statement, including
    the above license grant, this restriction and the following disclaimer,
    must be included in all copies of the Software, in whole or in part, and
    all derivative works of the Software, unless such copies or derivative
    works are solely in the form of machine-executable object code generated by
    a source language processor.
    
    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
    SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
    FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
    ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
    DEALINGS IN THE SOFTWARE.

Authors:
	Alexandru Ermicioi
**/
module aermicioi.aedi.configurer.register.factory_configurer;

public import aermicioi.aedi.factory.reference : lref, anonymous;

import aermicioi.aedi.configurer.register.generic_factory_metadata_decorator;
import aermicioi.aedi.storage.storage;
import aermicioi.aedi.storage.locator;
import aermicioi.aedi.factory;
import aermicioi.aedi.storage.decorator;
import aermicioi.aedi.container.proxy_container;
import aermicioi.aedi.container.container;
import aermicioi.util.traits;
import aermicioi.aedi.exception;

import std.traits;
import std.meta;

/**
Construct aggregate using args.

Constructs aggregate using args, that are passed to function.
The function will attempt to find at least one construct that 
can accept passed argument list. If it fails, compiler will
produce error, with respective problems.
The argument list can contain beside simple values, references
to other data in locator. Arguments that are references to other data
won't be type checked.

Params:
	factory = the factory which will call constructor with passed arguments.
	args = a list of arguments that will be passed to constructor.
	
Returns:
	MetadataDecoratedGenericFactory!T.
**/

auto construct(T, Args...)(MetadataDecoratedGenericFactory!T factory, auto ref Args args) {
    factory.setInstanceFactory(constructorBasedFactory!T(factory.locator, args));
    
    return factory;
}

/**
Invoke T's method to create aggregate of type X.

Configures aggregate's factory to call method of factoryMethod with args,
in order to create aggregate of type X.
In case when method is not a static member, the function requires to
pass a instance of factoryMethod or a reference to it.
The algorithm will check for args compatiblity with parameters of 
factory method. No type check is done for arguments that are references
at compile time.

Params:
    factory = aggregate's factory that is configured to call factoryMethod methods to spawn aggregate
    factoryMethod = instance of factory method that will be used to instantiate aggregate
    args = a list of arguments passed to factory method
    T = type of factoryMethod
    method = the method that is called from T to instantiate aggregate
    W = either LocatorReference or T
    X = the return type of T.method member
**/
MetadataDecoratedGenericFactory!(X) factoryMethod(T, string method, X, W, Args...)(MetadataDecoratedGenericFactory!(X) factory, auto ref W factoryMethod, auto ref Args args)
    if (
        isNonStaticMethodCompatible!(T, method, Args) &&
        (is(W : T) || is(W : LocatorReference))
    ) {
    factory.setInstanceFactory(factoryMethodBasedFactory!(T, method)(factory.locator, factoryMethod, args));
    
    return factory;
}

/**
ditto
**/
MetadataDecoratedGenericFactory!(X) factoryMethod(T, string method, X, Args...)(MetadataDecoratedGenericFactory!(X) factory, auto ref Args args)
    if (
        isStaticMethodCompatible!(T, method, Args)
    ) {

    factory.setInstanceFactory(factoryMethodBasedFactory!(T, method)(factory.locator, args));    
    return factory;
}

/**
Invoke aggregate's method with supplied args.

Configures aggregate's factory to call specified method with passed args.
The function will check if the arguments passed to it are compatible with at 
least one method from possible overload set.
The args list can contain references to other objects in locator as well, though
no type compatibility checks will be performed at compile time.

Params:
	factory = the factory which will be configured to invoke method.
	args = the arguments that will be used to invoke method on the new object.
	
Returns:
	MetadataDecoratedGenericFactory!T.
**/
auto set(string property, T, Args...)(MetadataDecoratedGenericFactory!T factory, auto ref Args args) 
    if (!isField!(T, property)) {
    mixin assertObjectMethodCompatible!(T, property, Args);
    
    factory.addPropertyConfigurer(methodConfigurer!(property, T)(factory.locator, args));
    
    return factory;
}

/**
Set aggregate's public field to passed arg.

Configures aggregate's factory to set specified field to passed arg.
The function will check if passed argument is type compatible with specified field.
The argument can be a reference as well. In case of argument being reference to another data
in container, no type compatiblity checking will be done.

Params
    factory = the factory which will be configured to set property.
	arg = the value of property to be set, or reference to data in container.

Returns:
	MetadataDecoratedGenericFactory!T.
**/
auto set(string property, T, Arg)(MetadataDecoratedGenericFactory!T factory, auto ref Arg arg)
    if (isField!(T, property)) {
    mixin assertFieldCompatible!(T, property, Arg);
    
    factory.addPropertyConfigurer(fieldConfigurer!(property, T)(factory.locator, arg));
    
    return factory;
}
    
/**
Construct aggregate using a delegate.

Constructs aggregate using a delegate, and a list of arguments passed to delegate.

Params:
	factory = the factory which will use delegate to construct aggregate.
	dg = the delegate that is responsible for creating aggregate, given a list of arguments.
	args = the arguments that will be used by delegate to construct aggregate.
	
Returns:
	MetadataDecoratedGenericFactory!T.
**/
auto callback(T, Args...)(MetadataDecoratedGenericFactory!T factory, T delegate(Locator!(), Args) dg, auto ref Args args) {
    factory.setInstanceFactory(callbackFactory!T(factory.locator, dg, args));

    return factory;
}
    
/**
ditto
**/
auto callback(T, Args...)(MetadataDecoratedGenericFactory!T factory, T function(Locator!(), Args) dg, auto ref Args args) {
    factory.setInstanceFactory(callbackFactory!T(factory.locator, dg, args));
    
    return factory;
}

/**
Call dg on an aggregate that is in configuration phase.

Call dg on aggregate to perform some modifications, using args as input.

Params:
    factory = factory which will call dg with args.
    dg = delegate that will perform some modifications on aggregate using passed args.
    args = a list of arguments passed to dg.
    
Returns:
    MetadataDecoratedGenericFactory!T
**/
auto callback(T, Args...)(MetadataDecoratedGenericFactory!T factory, void delegate(Locator!(), T, Args) dg, auto ref Args args) {
    factory.addPropertyConfigurer(callbackConfigurer!T(factory.locator, dg, args));
    
    return factory;
}
    
/**
ditto
**/
auto callback(T, Args...)(MetadataDecoratedGenericFactory!T factory, void function(Locator!(), T, Args) dg, auto ref Args args) {
    factory.addPropertyConfigurer(callbackConfigurer!T(factory.locator, dg, args));
    
    return factory;
}

/**
ditto
**/
auto callback(T, Args...)(MetadataDecoratedGenericFactory!T factory, void delegate(Locator!(), ref T, Args) dg, auto ref Args args) {
    factory.addPropertyConfigurer(callbackConfigurer!T(factory.locator, dg, args));
    
    return factory;
}
    
/**
ditto
**/
auto callback(T, Args...)(MetadataDecoratedGenericFactory!T factory, void function(Locator!(), ref T, Args) dg, auto ref Args args) {
    factory.addPropertyConfigurer(callbackConfigurer!T(factory.locator, dg, args));
    
    return factory;
}

/**
Autowire a constructor, field or a method.

Autowire a constructor, field or a method.
A constructor is autowired only when no member is passed as argument.
When a member is passed as argument, it will be called with
a list of references (where args are identified by their type FQN) in
case when member is a function, or it will set the member to the 
value that is located in container by it's type FQN.
Note: In case of constructors as well as methods that are overloaded,
the first constructor or method from overload set is selected to be autowired.

Params:
    T = the aggregate type
    member = field or method of aggregate T
    factory = MetadataDecoratedGenericFactory where to inject the constructor or method configurer
    
Returns:
    MetadataDecoratedGenericFactory!T
**/
auto autowire(T)(MetadataDecoratedGenericFactory!T factory) 
    if (getMembersWithProtection!(T, "__ctor", "public").length > 0) {
    return factory.construct!(T)(staticMap!(toLref, Parameters!(getMembersWithProtection!(T, "__ctor", "public")[0])));
}

/**
ditto
**/
auto autowire(string member, T)(MetadataDecoratedGenericFactory!T factory) 
    if (getMembersWithProtection!(T, member, "public").length > 0) {
    return factory.set!(member)(staticMap!(toLref, Parameters!(getMembersWithProtection!(T, member, "public")[0])));
}
    
/**
ditto
**/
auto autowire(string member, T)(MetadataDecoratedGenericFactory!T factory) 
    if (isField!(T, member)) {
    return factory.set!(member)(lref!(typeof(getMember!(T, member))));
}

/**
Move constructed data from one container to another one.

Move constructed data from one container to another one.
Description

Params:
	factory = factory for constructed data
	storage = new location for factory

Returns:
	factory
**/
auto container(T)(MetadataDecoratedGenericFactory!T factory, Storage!(ObjectFactory, string) storage) {
    if (factory.storage !is null) {
        factory.storage.remove(factory.identity);
    }
    
    factory.storage = storage;
    factory.storage.set(factory.wrapper, factory.identity);
    
    return factory;
}

/**
ditto
**/
auto container(T)(MetadataDecoratedGenericFactory!T factory, string storageId) {
    import std.algorithm;
    
    auto storage = factory.locator.locate!(Storage!(ObjectFactory, string))(storageId);
    
    factory.storageIdentity = storageId;
    return factory.container(storage);
}

/**
Tag constructed data with some information.

Tag constructed data with some information.
Description

Params:
	factory = factory for constructed data
	tag = tag with which to tag factory.

Returns:
	factory
**/
auto tag(T, Z)(MetadataDecoratedGenericFactory!T factory, auto ref Z tag) {
    
    auto taggable = findDecorator!(Taggable!Z, ObjectFactoryDecorator)(factory.wrapper);
    
    if (taggable is null) {
        auto taggableDecorator = new TaggableFactoryDecorator!(Object, Z);
        taggableDecorator.decorated = factory.wrapper;
        factory.wrapper = taggableDecorator;
        
        taggable = taggableDecorator;
        factory.storage.set(factory.wrapper, factory.identity);
    }
    
    taggable.tag(tag);
    
    return factory;
}

//Due to BUG 17177, minimal usage is not possible.
//Mark constructed object to be provided through a proxy instead of directly doing so.
//
//Mark constructed object to be provided through a proxy instead of directly doing so.
//Object will be proxied only in case when the storage where it is stored support 
//storing of proxy object factories.
//
//Params:
//	factory = factory for constructed object
//
//Returns:
//	factory
//
//auto proxy(T)(MetadataDecoratedGenericFactory!T factory) {
//    import aermicioi.aedi.factory.proxy_factory;
//    import aermicioi.aedi.container.proxy_container;
//    
//    auto proxyAware = cast(ProxyContainer) factory.storage;
//    if (proxyAware !is null) {
//        proxyAware.set(
//            new ProxyObjectWrappingFactory!T(
//                new ProxyFactory!T(factory.identity, proxyAware.decorated)
//            ),
//            factory.identity,
//        );
//    }
//    
//    return factory;
//}

/**
Find a decorator in decorator chain that implements Needle type.

Find a decorator in decorator chain that implements Needle type.

Params:
	Needle = the type searched decorator should implement
	Haystack = type of the chain of decorators through which to traverse
	decorated = top of decorator chain.

Returns:
	Decorator or null if not found.
**/
Needle findDecorator(Needle, Haystack : Decorator!Z, Z, T)(T decorated) {
    
    Haystack decorator = cast(Haystack) decorated;
    Needle needle = cast(Needle) decorated;
    
    while ((needle is null) && (decorator !is null)) {
        decorator = cast(Haystack) decorator.decorated;
        needle = cast(Needle) decorator;
    }
    
    return needle;
}
