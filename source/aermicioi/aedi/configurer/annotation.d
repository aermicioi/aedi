/**
This module implements annotation based configuration of containers.

License:
	Boost Software License - Version 1.0 - August 17th, 2003
    
    Permission is hereby granted, free of charge, to any person or organization
    obtaining a copy of the software and accompanying documentation covered by
    this license (the "Software") to use, reproduce, display, distribute,
    execute, and transmit the Software, and to prepare derivative works of the
    Software, and to permit third-parties to whom the Software is furnished to
    do so, all subject to the following:
    
    The copyright notices in the Software and this entire statement, including
    the above license grant, this restriction and the following disclaimer,
    must be included in all copies of the Software, in whole or in part, and
    all derivative works of the Software, unless such copies or derivative
    works are solely in the form of machine-executable object code generated by
    a source language processor.
    
    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
    SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
    FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
    ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
    DEALINGS IN THE SOFTWARE.

Authors:
	Alexandru Ermicioi
**/
module aermicioi.aedi.configurer.annotation;

public import aermicioi.aedi.factory.factory : lref;

import aermicioi.aedi.configurer.configurer;
import aermicioi.aedi.storage.locator;
import aermicioi.aedi.storage.storage;
import aermicioi.aedi.container.container;
import aermicioi.aedi.factory.factory;
import aermicioi.aedi.factory.genericfactory;
import aermicioi.aedi.exception;
import aermicioi.util.traits;

import std.traits;
import std.meta;
import std.typecons;
import std.conv : to;
import std.algorithm;

/**
Annotation used to denote an instantiatable object that should be stored into an container.

A simple alias to original struct to conform to functional style below (Since type inferring is not required no need to define a function for it).
**/
alias component = Component;

/**
Annotation used to mark constructor or method for auto wiring.

A simple alias to original struct to conform to functional style below (Since type inferring is not required no need to define a function for it).
Marking a method/constructor with autowired annotation will make container to call it with arguments fetched from
locator by types of them.

Note: even if a method/constructor from an overloaded set is marked with autowired annotation, the first method from overload set
will be used. Due to that autowired annotation is recommended to use on methods/constrcutors that are not overloaded.

**/
alias autowired = Autowired;

/**
Annotation used to denote an instantiatable object that should be stored into an container.
**/
struct Component {
    GenericFactory!T factory(T)(Locator!() locator) {
        return new GenericFactoryImpl!(T)(locator);
    }
}

/**
Annotation used to mark a constructor to be used for instantiating of it (constructor injection).

Params:
    Args = tuple of argument types for arguments to be passed into a constructor.
**/
struct Constructor(Args...) {
    Tuple!Args args;
    
    this(Args args) {
        this.args = args;
    }
    
    InstanceFactory!T factoryContainer(T, string property)(Locator!() locator) {
        auto constructor = new ConstructorBasedFactory!(T, Args)(args.expand);
        constructor.locator = locator;
        
        return constructor;
        
    }
}

/**
Annotation used to mark a method to be called to configure instantiated object by container (setter injection).

Note: if an overloaded method is annotated with Setter, the method from overload set that matches argument list in Setter annotation 
will be called.

Params:
    Args = the argument types of arguments passed to method
**/
struct Setter(Args...) {
    Tuple!Args args;
    
    this(Args args) {
        this.args = args;
    }
    
    PropertyConfigurer!T factoryConfigurer(T, string method)(Locator!() locator) {
        auto method = new MethodConfigurer!(T, method, Args)(args.expand);
        method.locator = locator;
        
        return method;
    }
}

/**
Annotation used to mark constructor or method for auto wiring.

Marking a method/constructor with autowired annotation will make container to call it with arguments fetched from
locator by types of them.

Note: even if a method/constructor from an overloaded set is marked with autowired annotation, the first method from overload set
will be used. Due to that autowired annotation is recommended to use on methods/constrcutors that are not overloaded.

**/
struct Autowired {
    PropertyConfigurer!T factoryConfigurer(T, string method)(Locator!() locator) {
        
        alias params = Parameters!(__traits(getOverloads, T, method)[0]);
        auto references = tuple(staticMap!(toLref, params));
        
        auto method = new MethodConfigurer!(T, method, staticMap!(toLrefType, params))(references.expand);
        method.locator = locator;
        
        return method;
    }
    
    PropertyConfigurer!T factoryContainer(T)(Locator!() locator) {
        
        alias params = Parameters!(__traits(getOverloads, T, "__ctor")[0]);
        auto references = tuple(staticMap!(toLref, params));
        
        auto method = new ConstructorBasedFactory!(T, staticMap!(toLrefType, params))(references.expand);
        method.locator = locator;
        
        return method;
    }
}

/**
An annotation used to provide custom identity for an object in container.
**/
struct Qualifier {
    string id;
}

/**
When objects are registered into an aggregate container, this annotation marks in which sub-container it is required to store.
**/
struct Contained {
    string id;
}

/**
Annotation used to mark a constructor to be used for instantiating of it (constructor injection).

This function is a convenince function to automatically infer required types for underlying annotation.

Params:
    Args = tuple of argument types for arguments to be passed into a constructor.
    args = tuple of arguments to be passed into a constructor.
**/
auto constructor(Args...)(Args args) {
    return Constructor!Args(args);
}

/**
Annotation used to mark a method to be called to configure instantiated object by container (setter injection).

This function is a convenince function to automatically infer required types for underlying annotation.
Note: if an overloaded method is annotated with Setter, the method from overload set that matches argument list in Setter annotation 
will be called.

Params:
    Args = the argument types of arguments passed to method
    args = the arguments passed to method
**/
auto setter(Args...)(Args args) {
    return Setter!Args(args);
}

/**
An annotation used to provide custom identity for an object in container.

This function is a convenince function to automatically infer required types for underlying annotation.

Params:
    id = identity of object in container
**/
auto qualifier(string id) {
    return Qualifier(id);
}

/**
An annotation used to provide custom identity for an object in container by some interface.

This function is a convenince function to automatically infer required types for underlying annotation.

Params:
    I = identity of object in container
**/
auto qualifier(I)()
    if (is(I == interface) || is(I == class)) {
    return Qualifier(name!I);
}

/**
When objects are registered into an aggregate container, this annotation marks in which sub-container it is required to store.

This function is a convenince function to automatically infer required types for underlying annotation.

Params:
    id = identity of container where to store the object.
**/
auto contained(string id) {
    return Contained(id);
}

/**
Register an object into storage using annotations provided in it.

An object will be registered in storage only in case when it is annotated with @component annotation. In case when no @component
annotation is found, object is not registered in storage.

Params:
    T = type of object to be registered
    storage = the storage where to register the object
    locator = the locator used to find object dependencies
    id = identity by which object will be stored in storage
**/
auto componentScan(T)(Storage!(Factory, string) storage, Locator!() locator, string id)
    if (is(T == class)) {
    auto factory = componentScanImpl!T(locator);
    
    alias SubComponents = staticMap!(
        partialPrefixed!(
            getMember,
            T
        ),
        Filter!(
            templateAnd!(
                partialPrefixed!(
                    partialSuffixed!(
                        isProtection,
                        "public"
                    ),
                    T
                ),
                chain!(
                    isType,
                    partialPrefixed!(
                        getMember,
                        T
                    )
                ),
                chain!(
                    isClass,
                    partialPrefixed!(
                        getMember,
                        T
                    )
                )
            ),
            __traits(allMembers, T)
        )
    );
    
    static if (SubComponents.length > 0) {
        storage.componentScan!SubComponents(locator);
    }
    
    if (factory !is null) {
        storage.set(id, factory);
    }
    
    return storage;
}

/**
Register an object into storage by it's type FQN using annotations provided in it.

An object will be registered in storage only in case when it is annotated with @component annotation. In case when no @component
annotation is found, object is not registered in storage.

Params:
    T = type of object to be registered
    storage = the storage where to register the object
**/
auto componentScan(T)(Storage!(Factory, string) storage, Locator!() locator)
    if (is(T == class)) {
        
    alias qualifiers = Filter!(isQualifier, allUDAs!T);

    static if (qualifiers.length > 0) {
        return storage.storage.componentScan!T(locator, qualifiers[0].id);
    } else {
        return storage.componentScan!T(locator, name!T);
    }
}

/**
ditto
**/
auto componentScan(T)(ConfigurableContainer storage)
    if (is(T == class)) {
    
    return storage.componentScan!T(storage);
}

/**
Register an object into storage by I's interface FQN that it implements using annotations provided in it.

An object will be registered in storage only in case when it is annotated with @component annotation. In case when no @component
annotation is found, object is not registered in storage.

Params:
    I = the inteface that object implements.
    T = type of object to be registered
    storage = the storage where to register the object
**/
auto componentScan(I, T)(Storage!(Factory, string) storage, Locator!() locator)
    if (is(I == interface) && is(T == class) && is(T : I)) {
    
    alias qualifiers = Filter!(
        isQualifier,
        allUDAs!I
    );
    
    static if (qualifiers.length > 0) {
        return storage.componentScan!T(locator, qualifier[0].id);
    } else {
        return storage.componentScan!T(locator, name!I);
    }
}

/**
ditto
**/
auto componentScan(I, T)(ConfigurableContainer storage)
    if (is(I == interface) && is(T == class) && is(T : I)) {
    
    return storage.componentScan!(I, T)(storage);
}

/**
Register a set of objects by it's type, or implemented interface into a storage.

When registering an object by it's interface, next to interface it is required to specify the original type of object.
Note: An object will be registered in storage only in case when it is annotated with @component annotation. In case when no @component
annotation is found, object is not registered in storage.

Params:
    I = the inteface that object implements.
    T = type of object to be registered
    storage = the storage where to register the object
**/
auto componentScan(T, V...)(Storage!(Factory, string) storage, Locator!() locator)
    if (is(T == class)) {
    storage.componentScan!T(locator);
    
    return storage.componentScan!V(locator);
}

/**
ditto
**/
auto componentScan(T, V...)(ConfigurableContainer storage)
    if (is(T == class)) {
    
    return storage.componentScan!(T, V)(storage);
}
    
/**
ditto
**/
auto componentScan(I, T, V...)(Storage!(Factory, string) storage, Locator!() locator)
    if (is(I == interface) && is(T == class) && is(T : I)) {
    storage.componentScan!(I, T)(locator);

    return storage.componentScan!(V)(locator);
}

/**
ditto
**/
auto componentScan(I, T, V...)(ConfigurableContainer storage)
    if (is(I == interface) && is(T == class) && is(T : I)) {
    
    return storage.componentScan!(I, T, V)(storage);
}

/**
Scan a module and register all public objects that are annotated with @component annotation.

Note: An object will be registered in storage only in case when it is annotated with @component annotation. In case when no @component
annotation is found, object is not registered in storage.

Params:
    Module = module to scan for components.
    storage = the storage where to register the object
    locator = the locator used to fetch registered object's dependencies.
**/
auto componentScan(alias Module)(Storage!(Factory, string) storage, Locator!() locator) 
    if (startsWith(Module.stringof, "module ")) {
    
    alias components = staticMap!(
        partialPrefixed!(
            getMember,
            Module
        ),
        Filter!(
            templateAnd!(
                partialSuffixed!(
                    partialPrefixed!(
                        isProtection,
                        Module
                    ),
                    "public"
                ),
                chain!(
                    isType,
                    partialPrefixed!(
                        getMember,
                        Module
                    )
                ),
                chain!(
                    isClass,
                    partialPrefixed!(
                        getMember,
                        Module
                    )
                )
            ),
            __traits(allMembers, Module)
        )
    );
    
    storage.componentScan!components(locator);
    
    return storage;
}

/**
ditto
**/
auto componentScan(alias M)(ConfigurableContainer storage)
    if (startsWith(M.stringof, "module")) {
    
    return storage.componentScan!(M)(storage);
}

/**
Scan a set of modules and register all public objects that are annotated with @component annotation.

Due to limitations of D language currently it is impossible to recursively scan all public imports of a module to register all 
depencies of a package. Each particular module should be specified in order to register dependencies.
Note: An object will be registered in storage only in case when it is annotated with @component annotation. In case when no @component
annotation is found, object is not registered in storage.

Params:
    M = current module to scan.
    V = rest set of modules waiting for scan.
    storage = the storage where to register the object
    locator = the locator used to fetch registered object's dependencies.
**/
auto componentScan(alias M, V...)(Storage!(Factory, string) storage, Locator!() locator)
    if (startsWith(M.stringof, "module")) {
    storage.componentScan!M(locator);
    return storage.componentScan!V(locator);
}

/**
ditto
**/
auto componentScan(alias M, V...)(ConfigurableContainer storage)
    if (startsWith(M.stringof, "module")) {
    
    return storage.componentScan!(M, V)(storage);
}

/**
Register an object into a storage contained in storageLocator and identified by @container annotation using annotations provided in it.

An object will be registered in storage only in case when it is annotated with @component annotation. In case when no @component
annotation is found, object is not registered in storage.

Params:
    T = type of object to be registered
    storageLocator = the locator from which to fetch storage for object
    locator = locator used to find dependencies for object
    id = identity by which object will be stored in storage
**/
auto componentScan(T, R : Locator!())(R storageLocator, Locator!() locator, string id) 
    if (is (T == class) && !is(R : Storage!(Factory, string))) {
    
    alias containers = Filter!(
        isContained,
        allUDAs!T
    );
    
    static if (containers.length > 0) {
        string storageId = containers[0].id;
    } else {
        string storageId = "singleton";
    }
    
    auto storage = storageLocator.locate!(Storage!(Factory, string))(storageId);
    
    if (storage !is null) {
        
        storage.componentScan!T(locator, id);
    } else {
        
        throw new NotFoundException("Could not find storage to save factory for object of identity " ~ id);
    }
    
    return storageLocator;
}

/**
ditto
**/
auto componentScan(T, R : Locator!())(R locator, string id)
    if (is (T == class) && !is(R : Storage!(Factory, string))) {
    return locator.componentScan!T(locator, id);
}

/**
ditto
**/
auto componentScan(T, R : Locator!())(R storageLocator, Locator!() locator)
    if (is (T == class) && !is(R : Storage!(Factory, string))) {
    
    alias qualifiers = Filter!(
        isQualifier,
        allUDAs!T
    );
    
    static if (qualifiers.length > 0) {
        return storageLocator.componentScan!T(locator, qualifiers[0].id);
    } else {
        return storageLocator.componentScan!T(locator, name!T);
    }
}

/**
ditto
**/
auto componentScan(T, R : Locator!())(R locator)
    if (is (T == class) && !is(R : Storage!(Factory, string))) {
    return locator.componentScan!T(locator);
}

/**
ditto
**/
template componentScan(T, V...)
    if(is (T == class) && (V.length > 0)) {
        
    /**
    ditto
    **/
    auto componentScan(R : Locator!())(R storageLocator, Locator!() locator) 
        if (!is(R : Storage!(Factory, string))) {
        .componentScan!T(storageLocator, locator);
        
        return .componentScan!V(storageLocator, locator);
    }
    
    /**
    ditto
    **/
    auto componentScan(R : Locator!())(R locator) 
        if (!is(R : Storage!(Factory, string))) {
        .componentScan!T(locator, locator);
        
        return .componentScan!V(locator, locator);
    }
}

/**
Register an object into a storage contained in storageLocator and identified by @container annotation using annotations provided in it.

An object will be registered in storage only in case when it is annotated with @component annotation. In case when no @component
annotation is found, object is not registered in storage.

Params:
    I = interface implemented by object, by which to register it.
    T = type of object to be registered
    storageLocator = locator used to find storage for object
    locator = locator used to find dependencies for object
**/
auto componentScan(I, T, R : Locator!())(R storageLocator, Locator!() locator)
    if (is (I == interface) && is (T == class) && is (T : I) && !is(R : Storage!(Factory, string))) {
    alias qualifiers = Filter!(
        isQualifier,
        allUDAs!I
    );
    
    static if (qualifiers.length > 0) {
        return storageLocator.componentScan!T(locator, qualifiers[0].id);
    } else {
        return storageLocator.componentScan!T(locator, name!I);
    }
}

/**
ditto
**/
auto componentScan(I, T, R : Locator!())(R locator)
    if (is (I == interface) && is (T == class) && is (T : I) && !is(R : Storage!(Factory, string))) {
    
    return locator.componentScan!(I, T)(locator);
}

/**
ditto
**/
template componentScan(I, T, V...) 
    if (is (I == interface) && is (T == class) && is (T : I) && (V.length > 0)) {
        
    /**
    ditto
    **/
    auto componentScan(R : Locator!())(R storageLocator, Locator!() locator)
        if (!is(R : Storage!(Factory, string))) {

        .componentScan!(I, T)(storageLocator, locator);
        
        return .componentScan!(V)(storageLocator, locator);
    }

    /**
    ditto
    **/
    auto componentScan(R : Locator!())(R locator)
        if (!is(R : Storage!(Factory, string))) {
        
        .componentScan!(I, T)(locator);
        
        return .componentScan!(V)(locator);
    }
}

/**
Register module's objects into a storage contained in storageLocator and identified by @container annotation using annotations provided in it.

An object will be registered in storage only in case when it is annotated with @component annotation. In case when no @component
annotation is found, object is not registered in storage.

Params:
    M = module to scan for instantiable objects.
    storageLocator = locator used to find storage for objects
    locator = locator used to find object dependencies
**/
auto componentScan(alias M, R : Locator!())(R storageLocator, Locator!() locator) 
    if (M.stringof.startsWith("module ") && !is(R : Storage!(Factory, string)))  {
    
    alias components = getPossibleComponents!M;
    
    storageLocator.componentScan!components(locator);
    
    return storageLocator;
}

/**
ditto
**/
auto componentScan(alias M, R : Locator!())(R locator) 
    if (M.stringof.startsWith("module ") && !is(R : Storage!(Factory, string)))  {
    
    locator.componentScan!M(locator);
    
    return locator;
}

/**
ditto
**/
template componentScan(alias M, V...) 
    if (M.stringof.startsWith("module ") && (V.length > 0)) {
        
    /**
    ditto
    **/
    auto componentScan(R : Locator!())(R locatorStorage, Locator!() locator)
        if (!is(R : Storage!(Factory, string))) {
        
        .componentScan!M(locatorStorage, locator);
        return .componentScan!V(locatorStorage, locator);
    }
        
    /**
    ditto
    **/
    auto componentScan(R : Locator!())(R locator)
        if (!is(R : Storage!(Factory, string))) {
        
        .componentScan!M(locator);
        return .componentScan!V(locator);
    }
}

/**
Checks if a structure has factory method for GenericFactory.

This static interface is used by annotation system to identify annotations that mark an object as instantiable by container.
The @component annotation is such a structure that implements this static interface and therefore it is possible to use it to 
mark components instantiable. A "@component" annotation must have a factory method that returns a GenericFactory instance that
further will be used to configure an instantiable object. In such a way it is possbile to define other custom annotations that
return GenericFactory implementations that add/or behave differrently comparing to default implementation of GenericFactory.

Examples:
--------------------
    struct Component {
        GenericFactory!T factory(T)(Locator!() locator) {
            return new GenericFactoryImpl!(T)(locator);
        }
    }
--------------------
Params:
    T = the structure to be tested for interface compatibility
    Z = the type of object that T has to instantiate
    
Returns:
    true in case of structure implementing static interface, false otherwise.
**/
template canFactoryGenericFactory(alias T, Z) 
    if (!isTemplate!T) {
    alias canFactoryGenericFactory = canFactoryGenericFactory!(typeof(T), Z);
}

/**
ditto
**/
template canFactoryGenericFactory(T, Z)
    if (isAggregateType!T) {
    static if (hasMember!(T, "factory")) {
        alias factory = getMember!(T, "factory");
        
        enum bool canFactoryGenericFactory = is(ReturnType!(factory!Z) : GenericFactory!Z);
    } else {
        
        enum bool canFactoryGenericFactory = false;
    }
}

/**
Checks if a structure has factoryContainer method for InstanceFactory.

This static interface is used to find annotations that can provide a InstanceFactory for GenericFactory to be used by it to instantiate
the object. The @constructor annotation implements this annotation and therefore it is possible to use it to mark a constructor to be used
for object construction. Any annotation implementing this interface can be used by annotation system to configure objects.

Examples:
--------------------
    struct Constructor(Args...) {
        Tuple!Args args;
        
        this(Args args) {
            this.args = args;
        }
        
        InstanceFactory!T factoryContainer(T, string property)(Locator!() locator) {
            auto constructor = new ConstructorBasedFactory!(T, Args)(args.expand);
            constructor.locator = locator;
            
            return constructor;
            
        }
    }
--------------------
Params:
    T = the structure to be tested for interface compatibility
    Z = the type of object that T has to instantiate
    
Returns:
    true in case of structure implementing static interface, false otherwise.
**/
template canFactoryInstanceFactory(alias T, Z, string property = "__ctor") {
    alias canFactoryInstanceFactory = canFactoryInstanceFactory!(typeof(T), Z, property);
}

/**
ditto
**/
template canFactoryInstanceFactory(T, Z, string property = "__ctor") {
    static if (hasMember!(T, "factoryContainer")) {
        alias factory = getMember!(T, "factoryContainer");
        
        enum bool canFactoryInstanceFactory = is(ReturnType!(factory!(Z, property)) : InstanceFactory!Z);
    } else {
        
        enum bool canFactoryInstanceFactory = false;
    }
}

/**
Checks if a structure has factoryConfigurer method for PropertyConfigurer.

This static interface is used to find annotations that can provide a PropertyConfigurer for GenericFactory to be used by it to configure
the object. The @setter annotation implements this annotation and therefore it is possible to use it to mark a setter to be used
for object construction. Any annotation implementing this interface can be used by annotation system to configure objects.

Examples:
--------------------
    struct Setter(Args...) {
        Tuple!Args args;
        
        this(Args args) {
            this.args = args;
        }
        
        PropertyConfigurer!T factoryConfigurer(T, string method)(Locator!() locator) {
            auto method = new MethodConfigurer!(T, method, Args)(args.expand);
            method.locator = locator;
            
            return method;
        }
    }
--------------------
Params:
    T = the structure to be tested for interface compatibility
    Z = the type of object that T has to call T's property method
    property = the method of Z that T has to call
Returns:
    true in case of structure implementing static interface, false otherwise.
**/
template canFactoryPropertyConfigurer(alias T, Z, string property) {
    alias canFactoryPropertyConfigurer = canFactoryPropertyConfigurer!(typeof(T), Z, property);
}

/**
ditto
**/
template canFactoryPropertyConfigurer(T, Z, string property) {
    static if (hasMember!(T, "factoryConfigurer")) {
        alias factory = getMember!(T, "factoryConfigurer");
        
        enum bool canFactoryPropertyConfigurer = is(ReturnType!(factory!(Z, property)) : PropertyConfigurer!Z);
    } else {
        
        enum bool canFactoryPropertyConfigurer = false;
    }
}

private auto componentScanImpl(T)(Locator!() locator)
    if (is (T == class)) {
    debug {
        pragma(msg, "Scanning ", fullyQualifiedName!T);
    }
    alias Components = Filter!(
        partialSuffixed!(
            canFactoryGenericFactory,
            T
        ),
        allUDAs!T
    );
    
    static if (Components.length > 0) {
        GenericFactory!T factory = toValue!(Components[0]).factory!T(locator);
        
        debug {
            pragma(msg, "Found component");
        }
        
        alias headUdas = Filter!(
            partialSuffixed!(
                canFactoryInstanceFactory,
                T
            ),
            allUDAs!T
        );
        
        
        static if (headUdas.length > 0) {
            debug {
                pragma(msg, "Found container right on ", fullyQualifiedName!T);
            }
            
            factory.setConstructorFactory(headUdas[0].factoryContainer!(T, name!T)(locator));
        } else {
            alias containers = Filter!(
                templateAnd!(
                    partialSuffixed!(
                        partialPrefixed!(
                            isProtection,
                            T
                        ),
                        "public"
                    ),
                    chain!(
                        isSomeFunction,
                        partialPrefixed!(
                            getMember,
                            T
                        )
                    )
                ),
                __traits(allMembers, T)
            );
            
            static if (containers.length > 0) {
                foreach (container; containers) {
                    foreach (overload; __traits(getOverloads, T, container)) {
                        alias udas = Filter!(
                            partialSuffixed!(
                                canFactoryInstanceFactory,
                                T
                            ),
                            allUDAs!overload
                        );
                        
                        
                        static if (udas.length > 0) {
                            debug {
                                pragma(msg, "Found custom constructor for component on ", container, " with arguments ", Parameters!overload);
                            }
                            
                            factory.setConstructorFactory(udas[0].factoryContainer!(T, container)(locator));
                        }
                    }
                }
            }
        }
        
        alias methods = Filter!(
            templateAnd!(
                partialSuffixed!(
                    partialPrefixed!(
                        isProtection,
                        T
                    ),
                    "public"
                ),
                chain!(
                    isSomeFunction,
                    partialPrefixed!(
                        getMember,
                        T
                    )
                )
            ),
            __traits(allMembers, T)
        );
        
        foreach (method; methods) {
            foreach (overload; MemberFunctionsTuple!(T, method)) {
                alias udas = Filter!(
                    partialSuffixed!(
                        canFactoryPropertyConfigurer,
                        T,
                        method
                    ),
                    allUDAs!overload
                );

                static if (udas.length > 0) {
                    debug {
                        pragma(msg, "Found configurer for ", method);
                    }
                    
                    factory.addPropertyFactory(toValue!(udas[0]).factoryConfigurer!(T, method)(locator));
                }
            }
        }
        
        return factory;
    } else {
        debug {
            pragma(msg, "Not a component");
        }
        
        return null;
    }
}

private template isQualifier(alias T) {
    alias isQualifier = isQualifier!(typeof(T));
}

private template isQualifier(T) {
    enum bool isQualifier = is(T == Qualifier);
}

private template isContained(alias T) {
    alias isContained = isContained!(typeof(T));
}

private template isContained(T) {
    enum bool isContained = is(T == Contained);
}

private template isValue(T) {
    enum bool isValue = is (typeof(T));
}

private template isReturnTypeEq(alias symbol, Type)
    if (isSomeFunction!symbol) {
    enum bool isReturnTypeEq = is(ReturnType!symbol : Type);
}

private template isNamedTemplate(alias T, string name) {
    enum bool isNamedTemplate = isTemplate!T && (identifier!T == name);
}

private template isEqByFQDN(alias first, alias second) {
    enum bool isEqByFQDN = fullyQualifiedName!first == fullyQualifiedName!second;
}

private template instantiatonToTemplate(alias T, alias Template = T) {
    static if (isTemplateInstantiationOf!(T, Template)) {
        alias instantiatonToTemplate = Template;
    } else static if (isTemplate!T) {
        alias instantiatonToTemplate = T;
    }
}

private enum bool isTemplateInstantiationOf(T, alias Template) = is(T : Template!(Z), Z...);
private enum bool isTemplateInstantiationOf(alias T, alias Template) = is(typeof(T) : Template!(Z), Z...);

private template identifierEq(alias T, string identity) {
    enum bool identifierEq = identifier!T == identity;
}

private template allUDAs(alias symbol) {
    alias allUDAs = AliasSeq!(__traits(getAttributes, symbol));
}

private template toValue(T) {
    enum auto toValue = T();
}

private template toValue(alias T) {
    alias toValue = T;
}

private template isType(alias T) {
    static if (__traits(compiles, () { T z = T.init; })) {
        
        enum bool isType = true;
    } else {
    
        enum bool isType = false;
    }
}

private template isClass(alias T) {
    enum bool isClass = is(typeof(T) == class);
}

private template isClass(T) {
    enum bool isClass = is(T == class);
}

private template getPublicAggregateMembers(alias Symbol) {
    alias getPublicAggregateMembers = Filter!(
        templateAnd!(
            partialSuffixed!(
                partialPrefixed!(
                    isProtection,
                    Symbol
                ),
                "public"
            ),
            chain!(
                hasMembers,
                partialPrefixed!(
                    getMember,
                    Symbol
                )
            )
        ),
        __traits(allMembers, Symbol)
    );
}

private template getPossibleComponents(alias Symbol) {
    alias getPossibleComponents = staticMap!(
        partialPrefixed!(
            getMember,
            Symbol
        ),
        Filter!(
            templateAnd!(
                partialSuffixed!(
                    partialPrefixed!(
                        isProtection,
                        Symbol
                    ),
                    "public"
                ),
                chain!(
                    isType,
                    partialPrefixed!(
                        getMember,
                        Symbol
                    )
                ),
                chain!(
                    isClass,
                    partialPrefixed!(
                        getMember,
                        Symbol
                    )
                )
            ),
            __traits(allMembers, Symbol)
        )
    );
}

