/**
This module implements annotation based configuration of containers.

License:
	Boost Software License - Version 1.0 - August 17th, 2003
    
    Permission is hereby granted, free of charge, to any person or organization
    obtaining a copy of the software and accompanying documentation covered by
    this license (the "Software") to use, reproduce, display, distribute,
    execute, and transmit the Software, and to prepare derivative works of the
    Software, and to permit third-parties to whom the Software is furnished to
    do so, all subject to the following:
    
    The copyright notices in the Software and this entire statement, including
    the above license grant, this restriction and the following disclaimer,
    must be included in all copies of the Software, in whole or in part, and
    all derivative works of the Software, unless such copies or derivative
    works are solely in the form of machine-executable object code generated by
    a source language processor.
    
    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
    SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
    FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
    ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
    DEALINGS IN THE SOFTWARE.

Authors:
	Alexandru Ermicioi
**/
module aermicioi.aedi.configurer.annotation;

public import aermicioi.aedi.factory.factory : lref;

import aermicioi.aedi.configurer.configurer;
import aermicioi.aedi.storage.locator;
import aermicioi.aedi.storage.storage;
import aermicioi.aedi.storage.wrapper;
import aermicioi.aedi.container.container;
import aermicioi.aedi.factory.factory;
import aermicioi.aedi.factory.genericfactory;
import aermicioi.aedi.factory.proxy_factory;
import aermicioi.aedi.exception;
import aermicioi.util.traits;

import std.traits;
import std.meta;
import std.typecons;
import std.conv : to;
import std.algorithm;

/**
Annotation used to denote an aggregate that should be stored into an container.
**/
struct ComponentAnnotation {
    
    /**
    Constructs a factory for aggregate of type T
    
    Params:
    	T = the aggregate type
    	locator = locator used to extract needed dependencies for T
    	
    Returns:
    	GenericFactory!T for objects
    	GenericFactory!(Wrapper!T) for structs
    **/
    GenericFactory!T factory(T)(Locator!() locator)
        if (
            is(T == class)
        ) {
        return new GenericFactoryImpl!(T)(locator);
    }
        
    /**
    ditto
    **/
    GenericFactory!(Wrapper!T) factory(T)(Locator!() locator)
        if (
            is(T == struct)
        ) {
        return new GenericFactoryImpl!(Wrapper!T)(locator);
    }
}

/**
ditto
**/
alias component = ComponentAnnotation;

/**
Annotation used to mark a constructor to be used for aggregate instantiation.

Params:
    Args = tuple of argument types for arguments to be passed into a constructor.
**/
struct ConstructorAnnotation(Args...) {
    Tuple!Args args;
    
    /**
    Constructor accepting a list of arguments, that will be passed to constructor.
    
    Params:
    	args = arguments passed to aggregate's constructor
    **/
    this(Args args) {
        this.args = args;
    }
    
    /**
    Constructs a constructor based factory for aggregate of type T
    
    Params:
    	T = the aggregate type
    	locator = locator used to extract needed dependencies for T
    	
    Returns:
    	InstanceFactory!T for objects
    	InstanceFactory!(Wrapper!T) for structs
    **/
    InstanceFactory!T factoryContainer(T, string property)(Locator!() locator)
        if (is(T == class)) {
        auto constructor = new ConstructorBasedFactory!(T, Args)(args.expand);
        constructor.locator = locator;
        
        return constructor;
    }
    
    /**
    ditto
    **/
    InstanceFactory!(Wrapper!T) factoryContainer(T, string property)(Locator!() locator) 
        if (is(T == struct)) {
        auto constructor = new ConstructorBasedFactory!(T, Wrapper!T, Args)(args.expand);
        constructor.locator = locator;
        
        return constructor;
    }
}

/**
ditto
**/
auto constructor(Args...)(Args args) {
    return ConstructorAnnotation!Args(args);
}

/**
Annotation used to mark a member to be called or set (in case of fields), with args passed to setter.

Note: if an overloaded method is annotated with Setter, the method from overload set that matches argument list in Setter annotation 
will be called.

Params:
    Args = the argument types of arguments passed to method
**/
struct SetterAnnotation(Args...) {
    Tuple!Args args;
    
    /**
    Constructor accepting a list of arguments, that will be passed to method, or set to a field.
    
    Params:
    	args = arguments passed to aggregate's constructor
    **/
    this(Args args) {
        this.args = args;
    }
    
    /**
    Constructs a configurer that will call or set a member for aggregate of type T.
    
    Constructs a configurer that will call or set a member for aggregate of type T.
    In case when member is a method, it will be called with passed arguments.
    If method is an overload set, the method that matches argument list will be called.
    In case when member is a field, it will be set to first argument from Args list.
    
    Params:
    	T = the aggregate type
    	method = the member which setter will call or set.
    	locator = locator used to extract needed dependencies for T
    	
    Returns:
    	PropertyConfigurer!T for objects
    	PropertyConfigurer!(Wrapper!T) for structs
    **/
    PropertyConfigurer!T factoryConfigurer(T, string method)(Locator!() locator)
        if (
            is(T == class) &&
            !isField!(T, method)
        ) {
        mixin assertObjectMethodCompatible!(T, method, Args);
        
        auto method = new MethodConfigurer!(T, method, Args)(args.expand);
        method.locator = locator;
        
        return method;
    }
        
    /**
    ditto
    **/
    PropertyConfigurer!T factoryConfigurer(T, string method)(Locator!() locator)
        if (
            is(T == class) &&
            isField!(T, method) &&
            (Args.length == 1)
        ) {
        mixin assertFieldCompatible!(T, method, Args);
        
        auto method = new FieldConfigurer!(T, method, Args[0])(args[0]);
        method.locator = locator;
        
        return method;
    }
    
    /**
    ditto
    **/
    PropertyConfigurer!(Wrapper!T) factoryConfigurer(T, string method)(Locator!() locator)
        if (
            is(T == struct) &&
            !isField!(T, method)
        ) {
        mixin assertObjectMethodCompatible!(T, method, Args);
        
        auto method = new MethodConfigurer!(T, method, Wrapper!T, Args)(args.expand);
        method.locator = locator;
        
        return method;
    }
        
    /**
    ditto
    **/
    PropertyConfigurer!(Wrapper!T) factoryConfigurer(T, string method)(Locator!() locator)
        if (
            is(T == struct) &&
            isField!(T, method) &&
            (Args.length == 1)
        ) {
        mixin assertFieldCompatible!(T, method, Args);
            
        auto method = new FieldConfigurer!(T, method, Wrapper!T, Args[0])(args[0]);
        method.locator = locator;
        
        return method;
    }
}

/**
ditto
**/
auto setter(Args...)(Args args) {
    return SetterAnnotation!Args(args);
}

/**
Annotation that specifies a delegate to be used to instantiate aggregate.

Params:
	Z = the type of aggregate that will be returned by the delegate
	Args = type tuple of args that can be passed to delegate.
**/
struct CallbackFactoryAnnotation(Z, Dg, Args...)
    if ((is(Dg == Z delegate (Locator!(), Args)) || is(Dg == Z function (Locator!(), Args)))) {
    Tuple!Args args;
    Dg dg;
    
    /**
    Constructor accepting a factory delegate, and it's arguments.
    
    Params:
    	dg = delegate that will factory an aggregate
    	args = list of arguments passed to delegate.
    **/
    this(Dg dg, ref Args args) {
        this.dg = dg;
        this.args = tuple(args);
    }
    
    /**
    Constructs a factory that uses delegate to instantiate an aggregate of type T.
    
    Params:
    	T = the aggregate type
    	locator = locator used to extract needed dependencies for T, it is also passed to delegate as first argument.
    	
    Returns:
    	InstanceFactory!T for objects
    	InstanceFactory!(Wrapper!T) for structs
    **/
    InstanceFactory!T factoryContainer(T, string p = "")(Locator!() locator)
        if (is(T == class) && is(Z : T)) {
        auto callback = new CallbackFactory!(T, Dg, Args)(dg, args.expand);
        callback.locator = locator;
        
        return callback;
    }
    
    /**
    ditto
    **/
    InstanceFactory!(Wrapper!T) factoryContainer(T, string p = "")(Locator!() locator)
        if (is(T == struct) && is(Z : T)) {
        auto callback = new CallbackFactory!(
            Wrapper!T,
            Wrapper!T function (Locator!() loc, Dg dg, Args args),
            Dg, 
            Args)(
            function Wrapper!T(Locator!() loc, Dg dg, Args args) {
                return new Wrapper!T(dg(loc, args));
            },
            dg, 
            args.expand
        );
        callback.locator = locator;
        
        return callback;
    }
}

/**
ditto
**/
auto fact(T, Args...)(T delegate(Locator!(), Args) dg, Args args) {
    return CallbackFactoryAnnotation!(T, T delegate(Locator!(), Args), Args)(dg, args);
}

/**
ditto
**/
auto fact(T, Args...)(T function(Locator!(), Args) dg, Args args) {
    return CallbackFactoryAnnotation!(T, T function(Locator!(), Args), Args)(dg, args);
}

/**
Annotation that specifies a delegate to be used to configure aggregate somehow.

Params:
	Z = the type of aggregate that will be returned by the delegate
	Args = type tuple of args that can be passed to delegate.
**/
struct CallbackConfigurerAnnotation(Z, Dg, Args...) 
    if (
        is(Dg == void delegate (Locator!(), Z, Args)) || 
        is(Dg == void function (Locator!(), Z, Args)) ||
        is(Dg == void delegate (Locator!(), ref Z, Args)) || 
        is(Dg == void function (Locator!(), ref Z, Args))
    ){
    Tuple!Args args;
    Dg dg;
    
    /**
    Constructor accepting a configurer delegate, and it's arguments.
    
    Params:
    	dg = delegate that will be used to configure an aggregate
    	args = list of arguments passed to delegate.
    **/
    this(Dg dg, ref Args args) {
        this.dg = dg;
        this.args = tuple(args);
    }
    
    /**
    Constructs a configurer that uses delegate to configure an aggregate of type T.
    
    Params:
    	T = the aggregate type
    	locator = locator that can be used by delegate to extract some custom data.
    	
    Returns:
    	PropertyConfigurer!T for objects
    	PropertyConfigurer!(Wrapper!T) for structs
    **/
    PropertyConfigurer!T factoryConfigurer(T, string p = "")(Locator!() locator)
        if (is(T == class) && is(T : Z)) {
        auto callback = new CallbackConfigurer!(T, Dg, Args)(dg, args.expand);
        callback.locator = locator;
        
        return callback;
    }
    
    /**
    ditto
    **/ 
    PropertyConfigurer!(Wrapper!T) factoryConfigurer(T, string p = "")(Locator!() locator)
        if (is(T == struct) && is(T : Z)) {
        auto callback = new CallbackConfigurer!(
            Wrapper!T,
            void function (Locator!(), Wrapper!T, Dg, Args),
            Dg,
            Args
        )(
            function void(Locator!() loc, Wrapper!T obj, Dg dg, Args args) {
                dg(loc, obj.value, args);
            },
            dg, 
            args.expand
        );
        callback.locator = locator;
        
        return callback;
    }
}

/**
ditto
**/
auto callback(T, Args...)(void delegate (Locator!(), ref T, Args) dg, Args args) {
    return CallbackConfigurerAnnotation!(T, void delegate (Locator!(), ref T, Args), Args)(dg, args);
}

/**
ditto
**/
auto callback(T, Args...)(void function (Locator!(), ref T, Args) dg, Args args) {
    return CallbackConfigurerAnnotation!(T, void function (Locator!(), ref T, Args), Args)(dg, args);
}

/**
ditto
**/
auto callback(T, Args...)(void delegate (Locator!(), T, Args) dg, Args args) {
    return CallbackConfigurerAnnotation!(T, void delegate (Locator!(), T, Args), Args)(dg, args);
}

/**
ditto
**/
auto callback(T, Args...)(void function (Locator!(), T, Args) dg, Args args) {
    return CallbackConfigurerAnnotation!(T, void function (Locator!(), T, Args), Args)(dg, args);
}

/**
Annotation used to mark constructor or method for auto wiring.

Marking a method/constructor with autowired annotation will make container to call it with arguments fetched from
locator by types of them.

Note: even if a method/constructor from an overloaded set is marked with autowired annotation, the first method from overload set
will be used. Due to that autowired annotation is recommended to use on methods/constrcutors that are not overloaded.

**/
struct AutowiredAnnotation {
    PropertyConfigurer!T factoryConfigurer(T, string method)(Locator!() locator)
        if (
            is(T == class) &&
            !isField!(T, method) &&
            isSomeFunction!(getMember!(T, method))
        ) {
        
        alias params = Parameters!(__traits(getOverloads, T, method)[0]);
        auto references = tuple(staticMap!(toLref, params));
        
        auto method = new MethodConfigurer!(T, method, staticMap!(toLrefType, params))(references.expand);
        method.locator = locator;
        
        return method;
    }
        
    PropertyConfigurer!T factoryConfigurer(T, string property)(Locator!() locator)
        if (
            is(T == class) &&
            isField!(T, property)
        ) {
        
        alias paramType = typeof(getMember!(T, property));
        
        auto lref = toLref!paramType;
        auto method = new FieldConfigurer!(T, property, toLrefType!paramType)(lref);
        method.locator = locator;
        
        return method;
    }
        
    PropertyConfigurer!(Wrapper!T) factoryConfigurer(T, string method)(Locator!() locator)
        if (
            is(T == struct) &&
            !isField!(T, method) &&
            isSomeFunction!(getMember!(T, method))
        ) {
        
        alias params = Parameters!(__traits(getOverloads, T, method)[0]);
        auto references = tuple(staticMap!(toLref, params));
        
        auto method = new MethodConfigurer!(T, method, Wrapper!T, staticMap!(toLrefType, params))(references.expand);
        method.locator = locator;
        
        return method;
    }
        
    PropertyConfigurer!(Wrapper!T) factoryConfigurer(T, string property)(Locator!() locator)
        if (
            is(T == struct) &&
            isField!(T, property)
        ) {
        
        alias paramType = typeof(getMember!(T, property));
        
        auto lref = toLref!paramType;
        auto method = new FieldConfigurer!(T, property, Wrapper!T, toLrefType!paramType)(lref);
        method.locator = locator;
        
        return method;
    }
    
    InstanceFactory!T factoryContainer(T, string property)(Locator!() locator)
        if (
            is(T == class)
        ) {
        alias params = Parameters!(__traits(getOverloads, T, "__ctor")[0]);
        auto references = tuple(staticMap!(toLref, params));
        
        auto method = new ConstructorBasedFactory!(T, staticMap!(toLrefType, params))(references.expand);
        method.locator = locator;
        
        return method;
    }
}

/**
ditto
**/
alias autowired = AutowiredAnnotation;

/**
An annotation used to provide custom identity for an object in container.
**/
struct QualifierAnnotation {
    string id;
}

/**
An annotation used to provide custom identity for an object in container.

This function is a convenince function to automatically infer required types for underlying annotation.

Params:
    id = identity of object in container
**/
auto qualifier(string id) {
    return QualifierAnnotation(id);
}

/**
An annotation used to provide custom identity for an object in container by some interface.

This function is a convenince function to automatically infer required types for underlying annotation.

Params:
    I = identity of object in container
**/
auto qualifier(I)()
    if (is(I == interface) || is(I == class)) {
    return QualifierAnnotation(name!I);
}

/**
When objects are registered into an aggregate container, this annotation marks in which sub-container it is required to store.
**/
struct ContainedAnnotation {
    string id;
}

/**
When objects are registered into an aggregate container, this annotation marks in which sub-container it is required to store.

This function is a convenince function to automatically infer required types for underlying annotation.

Params:
    id = identity of container where to store the object.
**/
auto contained(string id) {
    return ContainedAnnotation(id);
}

/**
Register an object into storage using annotations provided in it.

An object will be registered in storage only in case when it is annotated with @component annotation. In case when no @component
annotation is found, object is not registered in storage.

Params:
    T = type of object to be registered
    storage = the storage where to register the object
    locator = the locator used to find object dependencies
    id = identity by which object will be stored in storage
**/
auto componentScan(T)(Storage!(Factory, string) storage, Locator!() locator, string id) {
    auto factory = componentScanImpl!T(locator);
    
    alias SubComponents = staticMap!(
        partialPrefixed!(
            getMember,
            T
        ),
        Filter!(
            templateAnd!(
                partialPrefixed!(
                    partialSuffixed!(
                        isProtection,
                        "public"
                    ),
                    T
                ),
                chain!(
                    isType,
                    partialPrefixed!(
                        getMember,
                        T
                    )
                ),
                chain!(
                    isClass,
                    partialPrefixed!(
                        getMember,
                        T
                    )
                )
            ),
            __traits(allMembers, T)
        )
    );
    
    static if (SubComponents.length > 0) {
        storage.componentScan!SubComponents(locator);
    }
    
    if (factory !is null) {
        storage.set(id, factory);
    }
    
    return storage;
}

/**
Register an object into storage by it's type FQN using annotations provided in it.

An object will be registered in storage only in case when it is annotated with @component annotation. In case when no @component
annotation is found, object is not registered in storage.

Params:
    T = type of object to be registered
    storage = the storage where to register the object
**/
auto componentScan(T)(Storage!(Factory, string) storage, Locator!() locator) {
        
    alias qualifiers = Filter!(isQualifier, allUDAs!T);

    static if (qualifiers.length > 0) {
        return storage.componentScan!T(locator, qualifiers[0].id);
    } else {
        return storage.componentScan!T(locator, name!T);
    }
}

/**
ditto
**/
auto componentScan(T)(ConfigurableContainer storage) {
    
    return storage.componentScan!T(storage);
}

/**
Register an object into storage by I's interface FQN that it implements using annotations provided in it.

An object will be registered in storage only in case when it is annotated with @component annotation. In case when no @component
annotation is found, object is not registered in storage.

Params:
    I = the inteface that object implements.
    T = type of object to be registered
    storage = the storage where to register the object
**/
auto componentScan(I, T)(Storage!(Factory, string) storage, Locator!() locator)
    if (is(I == interface) && is(T == class) && is(T : I)) {
    
    alias qualifiers = Filter!(
        isQualifier,
        allUDAs!I
    );
    
    static if (qualifiers.length > 0) {
        return storage.componentScan!T(locator, qualifier[0].id);
    } else {
        return storage.componentScan!T(locator, name!I);
    }
}

/**
ditto
**/
auto componentScan(I, T)(ConfigurableContainer storage)
    if (is(I == interface) && is(T == class) && is(T : I)) {
    
    return storage.componentScan!(I, T)(storage);
}

/**
Register a set of objects by it's type, or implemented interface into a storage.

When registering an object by it's interface, next to interface it is required to specify the original type of object.
Note: An object will be registered in storage only in case when it is annotated with @component annotation. In case when no @component
annotation is found, object is not registered in storage.

Params:
    I = the inteface that object implements.
    T = type of object to be registered
    storage = the storage where to register the object
**/
auto componentScan(T, V...)(Storage!(Factory, string) storage, Locator!() locator) {
    storage.componentScan!T(locator);
    
    return storage.componentScan!V(locator);
}

/**
ditto
**/
auto componentScan(T, V...)(ConfigurableContainer storage) {
    
    return storage.componentScan!(T, V)(storage);
}
    
/**
ditto
**/
auto componentScan(I, T, V...)(Storage!(Factory, string) storage, Locator!() locator)
    if (is(I == interface) && is(T == class) && is(T : I)) {
    storage.componentScan!(I, T)(locator);

    return storage.componentScan!(V)(locator);
}

/**
ditto
**/
auto componentScan(I, T, V...)(ConfigurableContainer storage)
    if (is(I == interface) && is(T == class) && is(T : I)) {
    
    return storage.componentScan!(I, T, V)(storage);
}

/**
Scan a module and register all public objects that are annotated with @component annotation.

Note: An object will be registered in storage only in case when it is annotated with @component annotation. In case when no @component
annotation is found, object is not registered in storage.

Params:
    Module = module to scan for components.
    storage = the storage where to register the object
    locator = the locator used to fetch registered object's dependencies.
**/
auto componentScan(alias Module)(Storage!(Factory, string) storage, Locator!() locator) 
    if (startsWith(Module.stringof, "module ")) {
    
    alias components = staticMap!(
        partialPrefixed!(
            getMember,
            Module
        ),
        Filter!(
            templateAnd!(
                partialSuffixed!(
                    partialPrefixed!(
                        isProtection,
                        Module
                    ),
                    "public"
                ),
                chain!(
                    isType,
                    partialPrefixed!(
                        getMember,
                        Module
                    )
                ),
                chain!(
                    isClass,
                    partialPrefixed!(
                        getMember,
                        Module
                    )
                )
            ),
            __traits(allMembers, Module)
        )
    );
    
    storage.componentScan!components(locator);
    
    return storage;
}

/**
ditto
**/
auto componentScan(alias M)(ConfigurableContainer storage)
    if (startsWith(M.stringof, "module")) {
    
    return storage.componentScan!(M)(storage);
}

/**
Scan a set of modules and register all public objects that are annotated with @component annotation.

Due to limitations of D language currently it is impossible to recursively scan all public imports of a module to register all 
depencies of a package. Each particular module should be specified in order to register dependencies.
Note: An object will be registered in storage only in case when it is annotated with @component annotation. In case when no @component
annotation is found, object is not registered in storage.

Params:
    M = current module to scan.
    V = rest set of modules waiting for scan.
    storage = the storage where to register the object
    locator = the locator used to fetch registered object's dependencies.
**/
auto componentScan(alias M, V...)(Storage!(Factory, string) storage, Locator!() locator)
    if (startsWith(M.stringof, "module")) {
    storage.componentScan!M(locator);
    return storage.componentScan!V(locator);
}

/**
ditto
**/
auto componentScan(alias M, V...)(ConfigurableContainer storage)
    if (startsWith(M.stringof, "module")) {
    
    return storage.componentScan!(M, V)(storage);
}

/**
Register an object into a storage contained in storageLocator and identified by @container annotation using annotations provided in it.

An object will be registered in storage only in case when it is annotated with @component annotation. In case when no @component
annotation is found, object is not registered in storage.

Params:
    T = type of object to be registered
    storageLocator = the locator from which to fetch storage for object
    locator = locator used to find dependencies for object
    id = identity by which object will be stored in storage
**/
auto componentScan(T, R : Locator!())(R storageLocator, Locator!() locator, string id) 
    if (!is(R : Storage!(Factory, string))) {
    
    alias containers = Filter!(
        isContained,
        allUDAs!T
    );
    
    static if (containers.length > 0) {
        string storageId = containers[0].id;
    } else {
        string storageId = "singleton";
    }
    
    auto storage = storageLocator.locate!(Storage!(Factory, string))(storageId);
    
    if (storage !is null) {
        
        storage.componentScan!T(locator, id);
    } else {
        
        throw new NotFoundException("Could not find storage to save factory for object of identity " ~ id);
    }
    
    return storageLocator;
}

/**
ditto
**/
auto componentScan(T, R : Locator!())(R locator, string id)
    if (!is(R : Storage!(Factory, string))) {
    return locator.componentScan!T(locator, id);
}

/**
ditto
**/
auto componentScan(T, R : Locator!())(R storageLocator, Locator!() locator)
    if (!is(R : Storage!(Factory, string))) {
    
    alias qualifiers = Filter!(
        isQualifier,
        allUDAs!T
    );
    
    static if (qualifiers.length > 0) {
        return storageLocator.componentScan!T(locator, qualifiers[0].id);
    } else {
        return storageLocator.componentScan!T(locator, name!T);
    }
}

/**
ditto
**/
auto componentScan(T, R : Locator!())(R locator)
    if (!is(R : Storage!(Factory, string))) {
    return locator.componentScan!T(locator);
}

/**
ditto
**/
template componentScan(T, V...)
    if((V.length > 0)) {
        
    /**
    ditto
    **/
    auto componentScan(R : Locator!())(R storageLocator, Locator!() locator) 
        if (!is(R : Storage!(Factory, string))) {
        .componentScan!T(storageLocator, locator);
        
        return .componentScan!V(storageLocator, locator);
    }
    
    /**
    ditto
    **/
    auto componentScan(R : Locator!())(R locator) 
        if (!is(R : Storage!(Factory, string))) {
        .componentScan!T(locator, locator);
        
        return .componentScan!V(locator, locator);
    }
}

/**
Register an object into a storage contained in storageLocator and identified by @container annotation using annotations provided in it.

An object will be registered in storage only in case when it is annotated with @component annotation. In case when no @component
annotation is found, object is not registered in storage.

Params:
    I = interface implemented by object, by which to register it.
    T = type of object to be registered
    storageLocator = locator used to find storage for object
    locator = locator used to find dependencies for object
**/
auto componentScan(I, T, R : Locator!())(R storageLocator, Locator!() locator)
    if (is (I == interface) && is (T == class) && is (T : I) && !is(R : Storage!(Factory, string))) {
    alias qualifiers = Filter!(
        isQualifier,
        allUDAs!I
    );
    
    static if (qualifiers.length > 0) {
        return storageLocator.componentScan!T(locator, qualifiers[0].id);
    } else {
        return storageLocator.componentScan!T(locator, name!I);
    }
}

/**
ditto
**/
auto componentScan(I, T, R : Locator!())(R locator)
    if (is (I == interface) && is (T == class) && is (T : I) && !is(R : Storage!(Factory, string))) {
    
    return locator.componentScan!(I, T)(locator);
}

/**
ditto
**/
template componentScan(I, T, V...) 
    if (is (I == interface) && is (T == class) && is (T : I) && (V.length > 0)) {
        
    /**
    ditto
    **/
    auto componentScan(R : Locator!())(R storageLocator, Locator!() locator)
        if (!is(R : Storage!(Factory, string))) {

        .componentScan!(I, T)(storageLocator, locator);
        
        return .componentScan!(V)(storageLocator, locator);
    }

    /**
    ditto
    **/
    auto componentScan(R : Locator!())(R locator)
        if (!is(R : Storage!(Factory, string))) {
        
        .componentScan!(I, T)(locator);
        
        return .componentScan!(V)(locator);
    }
}

/**
Register module's objects into a storage contained in storageLocator and identified by @container annotation using annotations provided in it.

An object will be registered in storage only in case when it is annotated with @component annotation. In case when no @component
annotation is found, object is not registered in storage.

Params:
    M = module to scan for instantiable objects.
    storageLocator = locator used to find storage for objects
    locator = locator used to find object dependencies
**/
auto componentScan(alias M, R : Locator!())(R storageLocator, Locator!() locator) 
    if (M.stringof.startsWith("module ") && !is(R : Storage!(Factory, string)))  {
    
    alias components = getPossibleComponents!M;
    
    storageLocator.componentScan!components(locator);
    
    return storageLocator;
}

/**
ditto
**/
auto componentScan(alias M, R : Locator!())(R locator) 
    if (M.stringof.startsWith("module ") && !is(R : Storage!(Factory, string)))  {
    
    locator.componentScan!M(locator);
    
    return locator;
}

/**
ditto
**/
template componentScan(alias M, V...) 
    if (M.stringof.startsWith("module ") && (V.length > 0)) {
        
    /**
    ditto
    **/
    auto componentScan(R : Locator!())(R locatorStorage, Locator!() locator)
        if (!is(R : Storage!(Factory, string))) {
        
        .componentScan!M(locatorStorage, locator);
        return .componentScan!V(locatorStorage, locator);
    }
        
    /**
    ditto
    **/
    auto componentScan(R : Locator!())(R locator)
        if (!is(R : Storage!(Factory, string))) {
        
        .componentScan!M(locator);
        return .componentScan!V(locator);
    }
}

/**
Checks if a structure has factory method for GenericFactory.

This static interface is used by annotation system to identify annotations that mark an object as instantiable by container.
The @component annotation is such a structure that implements this static interface and therefore it is possible to use it to 
mark components instantiable. A "@component" annotation must have a factory method that returns a GenericFactory instance that
further will be used to configure an instantiable object. In such a way it is possbile to define other custom annotations that
return GenericFactory implementations that add/or behave differrently comparing to default implementation of GenericFactory.

Examples:
--------------------
    struct Component {
        GenericFactory!T factory(T)(Locator!() locator) {
            return new GenericFactoryImpl!(T)(locator);
        }
    }
--------------------
Params:
    T = the structure to be tested for interface compatibility
    Z = the type of object that T has to instantiate
    
Returns:
    true in case of structure implementing static interface, false otherwise.
**/
template canFactoryGenericFactory(alias T, Z) 
    if (!isTemplate!T) {
    alias canFactoryGenericFactory = canFactoryGenericFactory!(typeof(T), Z);
}

/**
ditto
**/
template canFactoryGenericFactory(T, Z)
    if (isAggregateType!T) {

    static if (hasMember!(T, "factory")) {
        alias factory = getMember!(T, "factory");
        
        alias checker = templateOr!(
            chain!(
                partialPrefixed!(
                    isDerived,
                    ReturnType!(factory!Z)
                ),
                chain!(
                    GenericFactory,
                    Wrapper
                )
            ),
            chain!(
                partialPrefixed!(
                    isDerived,
                    ReturnType!(factory!Z)
                ),
                GenericFactory
            )
        );
        enum bool canFactoryGenericFactory = checker!Z;
    } else {
        
        enum bool canFactoryGenericFactory = false;
    }
}

/**
Checks if a structure has factoryContainer method for InstanceFactory.

This static interface is used to find annotations that can provide a InstanceFactory for GenericFactory to be used by it to instantiate
the object. The @constructor annotation implements this annotation and therefore it is possible to use it to mark a constructor to be used
for object construction. Any annotation implementing this interface can be used by annotation system to configure objects.

Examples:
--------------------
    struct SetterAnnotation(Args...) {
        Tuple!Args args;
        
        this(Args args) {
            this.args = args;
        }
        
        InstanceFactory!T factoryContainer(T, string property)(Locator!() locator) {
            auto constructor = new ConstructorBasedFactory!(T, Args)(args.expand);
            constructor.locator = locator;
            
            return constructor;
            
        }
    }
--------------------
Params:
    T = the structure to be tested for interface compatibility
    Z = the type of object that T has to instantiate
    
Returns:
    true in case of structure implementing static interface, false otherwise.
**/
template canFactoryInstanceFactory(alias T, Z, string property = "__ctor") {
    alias canFactoryInstanceFactory = canFactoryInstanceFactory!(typeof(T), Z, property);
}

/**
ditto
**/
template canFactoryInstanceFactory(T, Z, string property = "__ctor") {
    static if (hasMember!(T, "factoryContainer")) {
        alias factory = getMember!(T, "factoryContainer");
        
        alias checker = templateOr!(
            chain!(
                partialPrefixed!(
                    isDerived,
                    ReturnType!(factory!(Z, property))
                ),
                chain!(
                    InstanceFactory,
                    Wrapper
                )
            ),
            chain!(
                partialPrefixed!(
                    isDerived,
                    ReturnType!(factory!(Z, property))
                ),
                InstanceFactory
            )
        );
        enum bool canFactoryInstanceFactory = checker!Z;
    } else {
        
        enum bool canFactoryInstanceFactory = false;
    }
}

/**
Checks if a structure has factoryConfigurer method for PropertyConfigurer.

This static interface is used to find annotations that can provide a PropertyConfigurer for GenericFactory to be used by it to configure
the object. The @setter annotation implements this annotation and therefore it is possible to use it to mark a setter to be used
for object construction. Any annotation implementing this interface can be used by annotation system to configure objects.

Examples:
--------------------
    struct Setter(Args...) {
        Tuple!Args args;
        
        this(Args args) {
            this.args = args;
        }
        
        PropertyConfigurer!T factoryConfigurer(T, string method)(Locator!() locator) {
            auto method = new MethodConfigurer!(T, method, Args)(args.expand);
            method.locator = locator;
            
            return method;
        }
    }
--------------------
Params:
    T = the structure to be tested for interface compatibility
    Z = the type of object that T has to call T's property method
    property = the method of Z that T has to call
Returns:
    true in case of structure implementing static interface, false otherwise.
**/
template canFactoryPropertyConfigurer(alias T, Z, string property = "") {
    alias canFactoryPropertyConfigurer = canFactoryPropertyConfigurer!(typeof(T), Z, property);
}

/**
ditto
**/
template canFactoryPropertyConfigurer(T, Z, string property = "") {
    static if (hasMember!(T, "factoryConfigurer")) {
        alias factory = getMember!(T, "factoryConfigurer");

        alias checker = templateOr!(
            chain!(
                partialPrefixed!(
                    isDerived,
                    ReturnType!(factory!(Z, property))
                ),
                chain!(
                    PropertyConfigurer,
                    Wrapper
                )
            ),
            chain!(
                partialPrefixed!(
                    isDerived,
                    ReturnType!(factory!(Z, property))
                ),
                PropertyConfigurer
            )
        );
        enum bool canFactoryPropertyConfigurer = checker!Z;
    } else {
        
        enum bool canFactoryPropertyConfigurer = false;
    }
}

public auto componentScanImpl(T)(Locator!() locator) {
    debug {
        pragma(msg, "Scanning ", fullyQualifiedName!T);
    }
    
    alias Components = Filter!(
        partialSuffixed!(
            canFactoryGenericFactory,
            T
        ),
        allUDAs!T
    );
    
    static if (Components.length > 0) {
        auto factory = toValue!(Components[0]).factory!T(locator);
        
        debug {
            pragma(msg, "Found component");
        }
        
        alias constructorUdas = Filter!(
            partialSuffixed!(
                canFactoryInstanceFactory,
                T
            ),
            allUDAs!T
        );
        
        alias configurerUdas = Filter!(
            partialSuffixed!(
                canFactoryPropertyConfigurer,
                T
            ),
            allUDAs!T
        );
        
        foreach (configurer; configurerUdas) {
            debug {
                pragma(msg, "Found configurer ", name!configurer, " on ", name!T, " declaration");
            }
            
            factory.addPropertyFactory(toValue!(configurer).factoryConfigurer!(T, "")(locator));
        }
        
        static if (constructorUdas.length > 0) {
            debug {
                pragma(msg, "Found constructor right on ", name!T);
            }
            
            factory.setConstructorFactory(toValue!(constructorUdas[0]).factoryContainer!(T, name!T)(locator));
        } else {
            alias instantiatorHolders = Filter!(
                templateAnd!(
                    partialSuffixed!(
                        partialPrefixed!(
                            isProtection,
                            T
                        ),
                        "public"
                    ),
                    eq!"__ctor",
                    chain!(
                        isSomeFunction,
                        partialPrefixed!(
                            getMember,
                            T
                        )
                    )
                ),
                __traits(allMembers, T)
            );
            
            foreach (instantiatorHolder; instantiatorHolders) {
                foreach (overload; __traits(getOverloads, T, instantiatorHolder)) {
                    alias udas = Filter!(
                        partialSuffixed!(
                            canFactoryInstanceFactory,
                            T
                        ),
                        allUDAs!overload
                    );
                    
                    static if (udas.length > 0) {
                        debug {
                            pragma(msg, "Found custom constructor for ", name!T, " on ", instantiatorHolder, " with arguments ", Parameters!overload);
                        }
                        
                        factory.setConstructorFactory(toValue!(udas[0]).factoryContainer!(T, instantiatorHolder)(locator));
                    }
                }
            }
        }
        
        alias configurerHolders = Filter!(
            templateAnd!(
                partialSuffixed!(
                    partialPrefixed!(
                        isProtection,
                        T
                    ),
                    "public"
                ),
                templateNot!(eq!"__ctor")
            ),
            __traits(allMembers, T)
        );
        
        foreach (member; configurerHolders) {
            
            static if (isSomeFunction!(getMember!(T, member))) {
                foreach (overload; __traits(getOverloads, T, member)) {
                    alias udas = Filter!(
                        partialSuffixed!(
                            canFactoryPropertyConfigurer,
                            T,
                            member
                        ),
                        allUDAs!overload
                    );
    
                    foreach (uda; udas) {
                        debug {
                            pragma(msg, "Found configurer ", name!uda, " for ", name!T, "'s method ", member);
                        }
                        
                        factory.addPropertyFactory(toValue!(udas[0]).factoryConfigurer!(T, member)(locator));
                    }
                }
            } else static if (isField!(T, member)) {
                
                alias udas = Filter!(
                    partialSuffixed!(
                        canFactoryPropertyConfigurer,
                        T,
                        member
                    ),
                    allUDAs!(getMember!(T, member))
                );
                
                foreach (uda; udas) {
                    debug {
                        pragma(msg, "Found configurer ", name!uda, " for ", name!T, "'s field ", member);
                    }
                    
                    factory.addPropertyFactory(toValue!(uda).factoryConfigurer!(T, member)(locator));
                }
            }
        }

        return factory;
    } else {
        debug {
            pragma(msg, "Not a component");
        }
        
        return null;
    }
}

private template isQualifier(alias T) {
    alias isQualifier = isQualifier!(typeof(T));
}

private template isQualifier(T) {
    enum bool isQualifier = is(T == QualifierAnnotation);
}

private template isContained(alias T) {
    alias isContained = isContained!(typeof(T));
}

private template isContained(T) {
    enum bool isContained = is(T == ContainedAnnotation);
}

private template isValue(T) {
    enum bool isValue = is (typeof(T));
}

private template isReturnTypeEq(alias symbol, Type)
    if (isSomeFunction!symbol) {
    enum bool isReturnTypeEq = is(ReturnType!symbol : Type);
}

private template isNamedTemplate(alias T, string name) {
    enum bool isNamedTemplate = isTemplate!T && (identifier!T == name);
}

private template isEqByFQDN(alias first, alias second) {
    enum bool isEqByFQDN = fullyQualifiedName!first == fullyQualifiedName!second;
}

private template instantiatonToTemplate(alias T, alias Template = T) {
    static if (isTemplateInstantiationOf!(T, Template)) {
        alias instantiatonToTemplate = Template;
    } else static if (isTemplate!T) {
        alias instantiatonToTemplate = T;
    }
}

private enum bool isTemplateInstantiationOf(T, alias Template) = is(T : Template!(Z), Z...);
private enum bool isTemplateInstantiationOf(alias T, alias Template) = is(typeof(T) : Template!(Z), Z...);

private template identifierEq(alias T, string identity) {
    enum bool identifierEq = identifier!T == identity;
}

private template allUDAs(alias symbol) {
    alias allUDAs = AliasSeq!(__traits(getAttributes, symbol));
}

private template toValue(T) {
    enum auto toValue = T();
}

private template toValue(alias T) {
    alias toValue = T;
}

private template isType(alias T) {
    static if (__traits(compiles, () { T z = T.init; })) {
        
        enum bool isType = true;
    } else {
    
        enum bool isType = false;
    }
}

private template isClass(alias T) {
    enum bool isClass = is(typeof(T) == class);
}

private template isClass(T) {
    enum bool isClass = is(T == class);
}

private template isStruct(alias T) {
    enum bool isStruct = is(typeof(T) == struct);
}

private template isStruct(T) {
    enum bool isStruct = is(T == struct);
}

private template getPublicAggregateMembers(alias Symbol) {
    alias getPublicAggregateMembers = Filter!(
        templateAnd!(
            partialSuffixed!(
                partialPrefixed!(
                    isProtection,
                    Symbol
                ),
                "public"
            ),
            chain!(
                hasMembers,
                partialPrefixed!(
                    getMember,
                    Symbol
                )
            )
        ),
        __traits(allMembers, Symbol)
    );
}

private template getPossibleComponents(alias Symbol) {
    alias getPossibleComponents = staticMap!(
        partialPrefixed!(
            getMember,
            Symbol
        ),
        Filter!(
            templateAnd!(
                partialSuffixed!(
                    partialPrefixed!(
                        isProtection,
                        Symbol
                    ),
                    "public"
                ),
                chain!(
                    isType,
                    partialPrefixed!(
                        getMember,
                        Symbol
                    )
                ),
                chain!(
                    templateOr!(
                        isClass,
                        isStruct
                    ),
                    partialPrefixed!(
                        getMember,
                        Symbol
                    )
                )
            ),
            __traits(allMembers, Symbol)
        )
    );
}

